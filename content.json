{"meta":{"title":"Stefan's Blog","subtitle":"Stay hungry , Stay foolish.","description":"Record learning tutorials and life insights.","author":"Stefan","url":"https://Stefancharles.xyz","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-17T12:48:27.402Z","updated":"2019-08-17T12:48:27.402Z","comments":true,"path":"404.html","permalink":"https://Stefancharles.xyz/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-08-18T05:25:14.550Z","updated":"2019-08-13T20:24:54.000Z","comments":true,"path":"projects/index.html","permalink":"https://Stefancharles.xyz/projects/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-18T12:40:13.421Z","updated":"2019-08-18T12:40:13.421Z","comments":true,"path":"about/index.html","permalink":"https://Stefancharles.xyz/about/index.html","excerpt":"","text":"[][3] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][4] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][5] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][6] 我是个卑微的保安，将就职于塞科睿提公司，喜欢美剧，音乐。 关于塞科睿提塞科睿提普拉斯即“Security-Plus”，公司致力于物联网安全服务。公司的服务宗旨是：“Born For Security”。 欢迎加入我们公司～"},{"title":"公司成员","date":"2019-11-11T02:12:20.515Z","updated":"2019-11-11T02:12:20.515Z","comments":true,"path":"friends/index.html","permalink":"https://Stefancharles.xyz/friends/index.html","excerpt":"","text":"如果有想进入我们公司的话，请联系塞科睿提公司CEO。 名称： Sercurity-Plus网址： https://stefancharles.xyz标签： PYPY"},{"title":"所有分类","date":"2019-08-17T08:17:15.729Z","updated":"2019-08-17T08:17:15.729Z","comments":true,"path":"blog/categories/index.html","permalink":"https://Stefancharles.xyz/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-08-17T12:47:55.937Z","updated":"2019-08-17T12:47:55.937Z","comments":true,"path":"blog/tags/index.html","permalink":"https://Stefancharles.xyz/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【RoboMaster】识别能量机关","slug":"EnergyAgency","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-08T07:16:56.454Z","comments":true,"path":"2020/02/08/EnergyAgency/","link":"","permalink":"https://Stefancharles.xyz/2020/02/08/EnergyAgency/","excerpt":"识别能量机关这个寒假，我负责处理能量机关（大小神符）的处理。因为RoboMaster网上开源代码很多，本着不重复造轮子的理念，另外如果我自己写全部的代码能不能成功识别还是个问题。所以本次代码和思想借鉴了很多论坛和网址，我会在文末附上链接。","text":"识别能量机关这个寒假，我负责处理能量机关（大小神符）的处理。因为RoboMaster网上开源代码很多，本着不重复造轮子的理念，另外如果我自己写全部的代码能不能成功识别还是个问题。所以本次代码和思想借鉴了很多论坛和网址，我会在文末附上链接。 操作环境 Windows 10 2004预览版 Visual Studio 2019 OpenCV 3.4.5 后面考虑移植问题，这里先暂不考虑。 预处理图像和之前车牌识别中的颜色识别一样，首先我们去除一些对我们识别没用的颜色，保留我们需要的颜色。这一步通过红蓝颜色通道互减可以方便的得到符合条件的灰度图。然后在灰度图上进行二值化。 1234567891011//分割颜色通道vector&lt;Mat&gt; imgChannels;split(srcImage, imgChannels);//获得目标颜色图像的灰度图#ifdef REDMat midImage2 = imgChannels.at(2) - imgChannels.at(0);#endif#ifndef REDMat midImage2 = imgChannels.at(0) - imgChannels.at(2);#endifthreshold(midImage2, midImage2, 100, 255, CV_THRESH_BINARY); #ifdef RED是一个技巧，当你在代码的开头写了#define RED，那么就会执行ifdef RED到#endif其中的代码，当你注释#define RED就执行ifndef RED后的代码，这样比较方便调试代码。 二值化后的待击打的扇叶如上图所示，可以看到箭头与箭头之间有很大空隙，如果直接进行轮廓查找的话会得到许多小轮廓，而不能把整个作为一个轮廓，所以需要对图片进行膨胀操作。腐蚀和膨胀都是针对于白色区域而言的，腐蚀就是白色区域减少，膨胀就是白色区域增加。再闭运算，消除扇叶上可能存在的小洞。 123456int structElementSize = 2;Mat element = getStructuringElement(MORPH_RECT, Size(2 * structElementSize + 1, 2 * structElementSize + 1), Point(structElementSize, structElementSize));dilate(midImage2, midImage2, element);structElementSize = 3;element = getStructuringElement(MORPH_RECT, Size(2 * structElementSize + 1, 2 * structElementSize + 1), Point(structElementSize, structElementSize));morphologyEx(midImage2, midImage2, MORPH_CLOSE, element); 经过上面代码的操作，图片大概如下： 查找扇叶首先查找轮廓： 123456//查找轮廓vector&lt;vector&lt;Point&gt;&gt; contours2;vector&lt;Vec4i&gt; hierarchy2;findContours(midImage2, contours2, hierarchy2, CV_RETR_TREE, CHAIN_APPROX_SIMPLE);RotatedRect rect_tmp2;bool findTarget = 0; 然后遍历轮廓，通过面积进行筛选。当轮廓为空时停止筛选。可以用hierarchy.size()来判断。 因为后面for遍历轮廓时需要条件，这里补充有关hierarchy的点。 hierarchy Optional output vector (e.g. std::vectorcv::Vec4i), containing information about the image topology. It has as many elements as the number of contours. For each i-th contour contours[i], the elements hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous,parent, or nested contours, the corresponding elements of hierarchy[i] will be negative. 大概意思就是说，hierarchy包含了轮廓的拓扑结构，hierarchy[i][0]~hierarchy[i][3] 中，0代表与当前轮廓平级的后一个轮廓的的索引编号、1代表与当前轮廓平级的前一个轮廓的索引编号、2代表当前轮廓的子轮廓的索引编号、3代表当前轮廓的父轮廓的索引编号。 所以遍历轮廓的语句会写成for(int i=0;i&gt;=0;i=hierarchy[i][0]) 在这个遍历中进行一系列操作。首先对每个轮廓的宽高进行处理使宽大于高，统一宽为长度长的一边。然后求得矩形的面积把小轮廓筛除。再应用透视变换，矫正成规则矩形。 仿射变换后平行四边形的各边仍操持平行，透视变换结果允许是梯形等四边形，所以仿射变换是透视变换的子集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152if (hierarchy2.size()) for (int i = 0; i &gt;= 0; i = hierarchy2[i][0]) &#123; //找出轮廓的最小外接矩形 rect_tmp2 = minAreaRect(contours2[i]); //将矩形的四个点保存在P中 Point2f P[4]; rect_tmp2.points(P); //为透视变换做准备 Point2f srcRect[4]; Point2f dstRect[4]; double width; double height; //矫正提取的叶片的宽高 width = getDistance(P[0], P[1]); height = getDistance(P[1], P[2]); if (width &gt; height) &#123; srcRect[0] = P[0]; srcRect[1] = P[1]; srcRect[2] = P[2]; srcRect[3] = P[3]; &#125; else &#123; swap(width, height); srcRect[0] = P[1]; srcRect[1] = P[2]; srcRect[2] = P[3]; srcRect[3] = P[0]; &#125; //通过面积筛选 double area = height * width; if (area &gt; 5000) &#123; cout &lt;&lt; hierarchy2[i] &lt;&lt; endl; //求得矩形的面积把小轮廓筛除 dstRect[0] = Point2f(0, 0); dstRect[1] = Point2f(width, 0); dstRect[2] = Point2f(width, height); dstRect[3] = Point2f(0, height); // 应用透视变换，矫正成规则矩形 Mat transform = getPerspectiveTransform(srcRect, dstRect); Mat perspectMat; warpPerspective(midImage2, perspectMat, transform, midImage2.size()); imshow(\"warpdst\", perspectMat); // 提取扇叶图片 Mat testim; testim = perspectMat(Rect(0, 0, width, height)); &#125; 经过上面的处理，最终分出两种图像。一种是需要击打的扇叶。像个锤子。 另一种是已经击打过的扇叶： 接下来就是对这两种图像二分类。方法有很多，我看到过还有人用yolo什么的。这里我使用车牌识别里简单的字符相减或者SVM。 字符相减（模板匹配）代码如下： 123456789101112131415161718192021222324252627282930313233double value;Mat tmp1;resize(testim, tmp1, Size(42, 20));//imshow(\"temp1\", tmp1);//用于保存匹配得分vector&lt;double&gt; Vvalue1; //识别待打击的扇叶vector&lt;double&gt; Vvalue2; //识别已经打击过的扇叶for (int j = 1; j &lt;= 6; j++)&#123;value = TemplateMatch(tmp1, templ[j], matchLoc, CV_TM_CCOEFF_NORMED);Vvalue1.push_back(value);&#125;for (int j = 7; j &lt;= 8; j++)&#123;value = TemplateMatch(tmp1, templ[j], matchLoc, CV_TM_CCOEFF_NORMED);Vvalue2.push_back(value);&#125;int maxv1 = 0, maxv2 = 0;//找出匹配值最大的序号for (int t1 = 0; t1 &lt; 6; t1++)&#123; if (Vvalue1[t1] &gt; Vvalue1[maxv1]) &#123; maxv1 = t1; &#125;&#125;for (int t2 = 0; t2 &lt; 2; t2++)&#123; if (Vvalue2[t2] &gt; Vvalue2[maxv2]) &#123; maxv2 = t2; &#125;&#125; 后期更新本博客","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"RoboMaster","slug":"RoboMaster","permalink":"https://Stefancharles.xyz/tags/RoboMaster/"}]},{"title":"【前端】初识JavaScript","slug":"getStartWithJS","date":"2020-02-04T16:00:00.000Z","updated":"2020-02-07T14:19:54.910Z","comments":true,"path":"2020/02/05/getStartWithJS/","link":"","permalink":"https://Stefancharles.xyz/2020/02/05/getStartWithJS/","excerpt":"初识JavaScript在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们仅花了十天时间就把JavaScript的原型设计出来了。 JavaScript的最初命名为Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中被重命名为JavaScript。","text":"初识JavaScript在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们仅花了十天时间就把JavaScript的原型设计出来了。 JavaScript的最初命名为Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中被重命名为JavaScript。 ECMAScript因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。 所以说，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。 1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。 1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成为了ECMAScript最著名的实现之一。除此之外，ActionScript和JScript也都是ECMAScript规范的实现语言。 JavaScript概论1.一般来说，完整的JavaScript包括以下3个部分： ECMAScript，描述了该语言的语法和基本对象 文档对象模型（DOM），描述处理网页内容的方法和接口 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 2.JavaScript的基本特点如下： 是一种解释性脚本语言（代码不进行预编译）。 主要用来向HTML页面添加交互行为。 可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。 3.JavaScript常用来完成以下任务： 嵌入动态文本于HTML页面 对浏览器事件作出响应 读写HTML元素 在数据被提交到服务器之前验证数据 检测访客的浏览器信息 控制cookies，包括创建和修改等 JavaScript快速入门JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到head中： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;StudyCode&lt;/title&gt; &lt;script&gt; alert(\"Hello!Stefan\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 预览如下： 由&lt;script&gt;...&lt;/script&gt;包含的代码是JavaScript代码，它将直接被浏览器执行。一旦引入外部JS文件，该script则内部的JS代码不会被执行。 第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;StudyCode&lt;/title&gt; &lt;script src=\"helloJS.js\"&gt;&lt;/script&gt; &lt;script&gt; document.write(\"Document Test\"); console.log(\"Console Test\") &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 把JavaScript代码放入一个单独的.js文件中更利于维护代码，并且多个页面可以各自引用同一份.js文件。 可以在同一个页面中引入多个.js文件。 数据类型NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型： 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 比较运算符当对Number做比较时，可以通过比较运算符得到一个布尔值。JavaScript允许对任意数据类型做比较。 12false == 0; // truefalse === 0; // false JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： 1NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： 1isNaN(NaN); // true 数组JavaScript的数组可以包括任意数据类型。 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： 123var arr = ['A', 'B', 'C'];arr[1] = 99;arr; // arr现在变为['A', 99, 'C'] 大多数编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] 通过unshift()可以往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse()把整个Array的元素反向： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array。concat()方法并没有修改当前Array，而是返回了一个新的Array。： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字。 与其他编程语言相比，这里JS申明一个变量用var即可。这种变量本身类型不固定的语言称之为动态语言。 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串,用双引号也行，引号不可嵌套var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 对象JavaScript的对象是一组由键-值组成的无序集合。 123456var person = &#123; name: 'Stefan', age: 21, tags: ['js', 'C', 'Android'], GF:Null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了4个键值对，其中每个键又称为对象的属性，例如，person的name属性为&#39;Stefan&#39;，GF属性为null。 和其他编程语言相似，要获取一个对象的属性，用对象变量.属性名的方式： 12person.name; // 'Stefan'person.GF; // null MapMap是一组键值对的结构，具有极快的查找速度。 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值替换。 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤，数字3和字符串&#39;3&#39;是不同的元素。： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 用for ... of循环遍历集合，用法如下： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 更好的方式是直接使用iterable内置的forEach方法。 Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身： 1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 简单点来整： 1234var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; console.log(element);&#125;);","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Stefancharles.xyz/tags/JavaScript/"}]},{"title":"【Git】相关问题","slug":"gitproblems","date":"2020-01-31T16:00:00.000Z","updated":"2020-02-01T13:15:19.313Z","comments":true,"path":"2020/02/01/gitproblems/","link":"","permalink":"https://Stefancharles.xyz/2020/02/01/gitproblems/","excerpt":"Git提交问题今天提交Git时本地提示提交上去，但是github上没有记录。之前我使用的是HTTPS的方式提交，今天改为SSH提交。","text":"Git提交问题今天提交Git时本地提示提交上去，但是github上没有记录。之前我使用的是HTTPS的方式提交，今天改为SSH提交。 生成 SSH 密钥打开Git Bash，输出以下命令。 1cd ~/.ssh 这是用来检查有没有已经存在的密钥。 如果提示不存在目录。就使用 ssh-keygen 生成密钥： 123456ssh-keygen -t rsa -C \"your_email@example.com\"# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa):Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 第一次回车确认路径，第二次回车输入passphrase，这个可以是空。第三次回车确认passphrase。 1234Your identification has been saved in /home/you/.ssh/id_rsa.Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is:…………………此处是密钥内容…………………… your_email@example.com 绑定Deploy keys找到刚刚路径下生成的id_rsa.pub文件，用vscode打开，复制全部公钥。然后去github对应的仓库的设置里绑定Deploy keys。（Settings –&gt; Deploy keys –&gt; Add deploy key） 测试配置是否成功： 1ssh -T git@github.com 权限过大问题我在win10 20 04的版本上到这一步测试时报错： 123456789@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for '/Users/sailfish/.ssh/id_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key \"/Users/sailfish/.ssh/id_rsa\": bad permissionsgit@ip's password:Permission denied, please try again. 看样子应该是权限过大问题。网上搜索得到了一个解决的命令： 12cd ~/.sshchmod 700 id_rsa 再次测试，发现并没有用。估计在linux下才管用吧。 经过探索，我在win下需要设置.ssh文件夹的访问权限。下图所示。 设置好上面的后，再测试配置。正常提示如下 1Hi stefan! You have successfully authenticated, but GitHub does not provide shell access. 提交博客到提交博客时报错如下： 12345678910Please tell me who you are.Rungit config --global user.email \"you@example.com\"git config --global user.name \"Your Name\"to set your account's default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got 'name@stefan.(none)') 首先按照提示来设置全局的git 配置，发现没有用。 于是剑走偏锋，直接设置博客目录下的.git目录下的config文件。在该文件后面加几行： 123[user]email=your emailname=your name 再次Deploy，终于解决问题了。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://Stefancharles.xyz/tags/Git/"}]},{"title":"【HTTP协议】安卓网络编程基础","slug":"http","date":"2020-01-20T16:00:00.000Z","updated":"2020-01-24T15:37:40.592Z","comments":true,"path":"2020/01/21/http/","link":"","permalink":"https://Stefancharles.xyz/2020/01/21/http/","excerpt":"安卓网络编程基础-Http协议Http即HyperText Transfer Protocol，也就是超文本传输协议。","text":"安卓网络编程基础-Http协议Http即HyperText Transfer Protocol，也就是超文本传输协议。 Http协议定义 协议就是约定的意思，内容是Http相关的格式。 http协议是基于TCP/IP协议之上的应用层协议。 Http工作流程 客户端发起一个请求，然后服务器处理请求，做出响应。 这个流程是一定的，换句话说，请求一定是客户端请求，响应一定是服务端响应。 不可以是服务端向客户端发起请求，也不可以是客户端做出响应。 特殊情况：这个服务器跟另外一个服务器通过http请求。 这种情况是有的，但是当发起请求那一刻，它就被当作客户端。 Http不保存状态当一个请求，一个响应完成时，那么一个http的请求就完成了。当然也有特殊情况，就是无网了，你发不起请求。然后服务器处理超时了，你也得不到结果。 http是无状态协议，也就是不保存状态。一次请求完成后，下一次再发起请求，又是新的。该设置什么内容设置什么内容，要给什么参数给什么参数。 http无状态，那怎么知道这个请求用户已经登录了呢？登录状态保存在哪里呢？所以就引入了cookies这个东西了。在cookies里可以保存一个令牌(token)，每次请求的时候，把这个令牌作为参数给服务器校验，这样子就可以知道这个用户的登录状态。 Http请求方式 get post put delete head trace options connect 一般而言常用的是get和post。通常情况下： get：用于请求数据 post：用于提交数据 put：用于更新数据 delete：用于删除数据 同一个接口，不同的请求方式作用就不一样。 RESTful:(Representational State Transfer)RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。 Http响应码响应码是服务器给客户端结果码。 Http请求格式 请求行 请求头 Host 要访问的主机 Connection 连接保持，http1.1有，1.0没有这个。keep-alive可以提高效率，在一定时间里不断开tcp连接，进行下一个请求 Content-Length 内容长度，指的是后面请求正文的数据长度 Accept 响应内容格式，也就是返回内容格式 Origin 这个是源（不是标准http里的内容，这里是chrome加的） User-Agent 用户客户端相关的信息，比如说浏览器，操作系统信息之类的 Content-Type 提交的内容类型 Referer 来源，访问入口。 Accept-Encoding 响应内容的编码格式 Accept-Language 响应内容的语言 Cookie cookies 使用抓包软件进行抓包： Http响应格式 响应行 响应头 空行 响应体","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"},{"name":"Http","slug":"Http","permalink":"https://Stefancharles.xyz/tags/Http/"}]},{"title":"【爱情公寓五】人生下一站","slug":"NextStopOfLife","date":"2020-01-15T16:00:00.000Z","updated":"2020-02-01T12:46:08.509Z","comments":true,"path":"2020/01/16/NextStopOfLife/","link":"","permalink":"https://Stefancharles.xyz/2020/01/16/NextStopOfLife/","excerpt":"从《爱情公寓四》在2014年开播后，到如今2020年历经6年，《爱情公寓五》近几天终于开播了。 而很多人看了《爱情公寓五》的前几集后就吐槽爱情公寓变味了，已经不一样了。 可是，为什么一定要和原来一样呢？ 错觉的地久天长，其实是一无所有。——《虹之间》","text":"从《爱情公寓四》在2014年开播后，到如今2020年历经6年，《爱情公寓五》近几天终于开播了。 而很多人看了《爱情公寓五》的前几集后就吐槽爱情公寓变味了，已经不一样了。 可是，为什么一定要和原来一样呢？ 错觉的地久天长，其实是一无所有。——《虹之间》 爱的回归线 第一集，美嘉说：“如果你不愿意发朋友圈，那就别发了。我愿意给你更多时间准备，我想从你的角度思考问题。” 子乔说：”我不会回避我的过去，但我也希望我有新的未来。我知道，我身边这个女生是我想共度余生的人。“ 当熟悉的《爱的回归线》bgm响起来，很多回忆渐渐浮现。 那个喜欢party的美嘉，那个在酒吧扇吕子乔大嘴巴，喊着“我一口盐汽水喷死你”的美嘉。那个没有正式工作、撩妹却不懂责任的吕子乔。还有那个拼命抢回美嘉手链的吕子乔。 离开&amp;告别在戏外，《爱情公寓》系列一直被贴上“抄袭”的标签，（这点并不是我这篇博客想表达的重点），这也导致了一些最初的演员的离开。比如王传君和金世佳。 在戏内，宛瑜和展博为了梦想离开；关谷和悠悠为了爱情离开。寥寥数笔交代了曾小贤去了阿拉善，缺席了大部分剧情。 这些当初人物的离开或许是很多人觉得变味的原因之一吧。觉得已经不一样了…… 可是，为什么一定要和原来一样呢？ 毕竟，每个人都在长大啊。 子乔和美嘉总要长大，如果子乔和原来一样，能做个好爸爸吗？ 小贤和一菲总要长大，如果曾老师一直很原来一样，迷迷糊糊 ，一菲能把自己交给他吗？ 有的人又说了，关谷和悠悠不见了，展博和宛瑜离开了 。但是，如果你想想那些曾经陪你看爱情公寓的朋友们，他们12号晚上和你一起等着爱5的开播吗。这就不一定了。因为我们总会不断地告别很多人，我们也会离开很多人。 爱情公寓的10年就正好像我们的10年，总有人要离开，总有人要长大。 如果30多的子乔，美嘉，曾老师，一菲，还和10年前一样打打闹闹，那才是真正的开玩笑。 爱情公寓总有人要离去，80 90 00总要一代一代的交替着。 就如上面写的， 宛瑜和展博为了梦想离开；关谷和悠悠为了爱情离开； 可以想到的是， 一菲和小贤装修房子后说不定会离开；美嘉和子乔有孩子后说不定会离开。 他们的离开好像是告诉我们：一个时代的结束，我们要长大。 留下的像极了美嘉的咖喱酱，像极了一菲的大力，像极了子乔的赵海棠。他们也会长大，为了各自的理由离开。 人生下一站有人说，试着把清晰度调到标清，把自己调到几年前的模式，你就会发现，爱情公寓还是那个爱情公寓。 我们一开始就接受了剧里没工作也可以不断撩妹的吕子乔，没收听率而且意外频发的《你的月亮我的心》也不会被砍等等许多“不合现实”的设定。这些设定在现实生活中就如同乌托邦一样不存在。 在剧情里，所有困难都不算困难，用爱发电是合理的，朋友不会因为离开而变得生疏，爱情也不会因为房子存款而变化。 或许可以这么猜测： 我们觉得以前的《爱情公寓》好看，是因为那时候我们还没长大，我们还相信,也许有一天我们会遇到那样一群人， 会过上那样的生活。 六年后的现在，经历了时间的我们能一眼识破童话和现实的区别。换句话说，我们变得越来越“不懂味”了。 如果可以的话，就用这最后一季和10年前的自己好好挥手告别吧。而后，好好的迎接人生的下一个阶段吧。 他们都开始走向人生下一站了。 我们也要去下一站了。 用了10年的时间，不就是等一个结局吗？ 可是，人生哪里有标准结局。 无论怎样，美嘉还在子乔身边 ，一菲还在小贤身边，宛瑜还在展博身边，悠悠还在关谷身边，张伟的身边有了大力。 虽然…，现实中自己身边的人早已离开。 无论怎样，至少留一点时间给自己吧。假装还不曾长大，假装在花瓣来的地方，真的有个叫爱情公寓的地方，情侣入住，房租减半，水电全免。在那里，爱可以发电，朋友是永远不会过时的陪伴。 2020.02.01更 安培冲过欧姆，寻找着法拉，充电到一个伏特，电键已断，我以库仑之名涌出，化为焦耳，为了你，烟消云散。当我作为自变量趋近于正无穷时，得到的函数值，就是你。 今天看到大结局了。之前还说到 “宛瑜和展博为了梦想离开；关谷和悠悠为了爱情离开；一菲和小贤装修房子后说不定会离开；美嘉和子乔有孩子后说不定会离开。” 结果第34集就给出了爱情公寓要被拆迁的剧情，这是所有人都得走的节奏啊。 以前的每一集或多或少都有一些能戳中笑点的地方，但是唯独第34集中的看似搞笑的笑点却莫名戳中泪点。 剧情脑补——2022年上海浦东新区伟大律师事务所 “王总放心，这个案子绝对没有问题。”张伟微笑着跟面前这个富贵逼人的老总握手。 “诸葛律师的推荐果然没错，这次非常感谢张律师了，那我就先告辞了。” “王总我再梳理梳理案件，就不亲自送你下去了，小刘，送王总下去。” 张伟微笑道。张伟目送王总离开办公室后便急忙打开手机想给赵海棠打个电话，他想知道大力回来了吗？他有些慌张急促，看向桌子上的戒指盒，平日的自信沉稳荡然无存。 “咚，咚。”有敲门声传来，张伟不耐烦地说道:“不好意思，下午有很重要的事，请先去预约。” 出乎意料的是，门直接被打开，张伟抬起头来，目光却瞬间呆滞，一位年轻女子走进来，面带笑意，眼里星河荡漾，坐到那把熟悉的椅子上，眼睛里写满了柔情和喜悦 张伟觉得大力又瘦了，可能是柏林没有一菲的蛋炒饭和他亲手煮的控盐泡面，又可能是大力在柏林很想他。张伟突然发现自己的超能力好像回来了，他听到了大力砰砰的急促的心跳声: “我叫诸葛大力，今年22岁，性别女，取向你，身高162，体重44，喜欢跟你约会逛街看电影，目前研究生毕业，我原本没有计划在22岁结婚，可这次回来我想让你做我老公。” 小草渴求雨露，花儿盼望阳光，地球静候彗星，我偷偷地看着你。 雨露滋润小草，阳光温暖花朵，彗星亲吻地球，我远远地看着你 小草承接雨露，花儿祝福阳光，地球告别彗星，我默默地看着你。 最后在我心里，爱情公寓就像一个乌托邦一样，正是因为现世中有着这么多的不如愿，才更突出了这个故事的可贵。在我心里它早已不是一个简单的喜剧故事，而是一个陪伴自己的挚友，正因为他一路来陪你走过风风雨雨看遍落花流水，人们才会如此渴望他有着一个美好的结局。即使暂时分离也无所谓，请记住，花瓣飘来的地方，那里就是爱情公寓。 当花瓣飘落地平线的时候，我们终将离去，再漫长的欢聚也有尽头，世上哪有不散温柔。当花瓣再次飞扬天空的时候，最好的朋友还会重逢，回忆点燃的灯火它永不熄灭，最爱的人是永远的守候。谨以此篇献给那些逝去的光阴，再见，爱情公寓；再见，青春。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://Stefancharles.xyz/categories/随笔/"}],"tags":[]},{"title":"【HTTP】Get和Post的区别","slug":"GetAndPost","date":"2020-01-12T16:00:00.000Z","updated":"2020-01-21T09:39:36.771Z","comments":true,"path":"2020/01/13/GetAndPost/","link":"","permalink":"https://Stefancharles.xyz/2020/01/13/GetAndPost/","excerpt":"Get和Post的区别Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。","text":"Get和Post的区别Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 Get根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 （1）安全的意味着该操作用于获取信息而非修改信息。GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 （2）幂等的意味着对同一URL的多个请求应该返回同样的结果。 幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。幂等有一下几种定义：对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。 在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。 Post根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 表面现像上面是原理性的区别，我们再从表面现像上面看看GET和POST的区别： （1）1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 （2）提交数据大小区别 1.因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于一些浏览器理论上没有长度限制，其限制取决于操作系统的支持。 2. POST是没有大小限制的，HTTP协议规范也没有进行大小限制，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 安全性区别POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为： (1)登录页面有可能被浏览器缓存； (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://Stefancharles.xyz/tags/Http/"}]},{"title":"【Ubuntu】Ubuntu的一些问题及解决方案汇总","slug":"ubuntuProblems","date":"2020-01-06T16:00:00.000Z","updated":"2020-01-12T11:48:45.855Z","comments":true,"path":"2020/01/07/ubuntuProblems/","link":"","permalink":"https://Stefancharles.xyz/2020/01/07/ubuntuProblems/","excerpt":"Ubuntu小毛病问题汇总无论是把Ubuntu作为开发工具还是作为日常使用的环境，总会碰到很多问题。虽然这些问题通过谷歌或者百度查找可以解决，但是通常而言后面如果再遇到这个问题又忘记具体解决方案或者命令了。所以特别开一个博客用来记录我遇到的一些问题及解决方案。 If I have to do a summary for this thing, so I would say, we have create our own demons.——《Iron Man3》","text":"Ubuntu小毛病问题汇总无论是把Ubuntu作为开发工具还是作为日常使用的环境，总会碰到很多问题。虽然这些问题通过谷歌或者百度查找可以解决，但是通常而言后面如果再遇到这个问题又忘记具体解决方案或者命令了。所以特别开一个博客用来记录我遇到的一些问题及解决方案。 If I have to do a summary for this thing, so I would say, we have create our own demons.——《Iron Man3》 外接显示器问题我的笔记本屏幕分辨率是1920×1080，外接显示器的分辨率是3840×2160。当我在Ubuntu下配置好显卡GTX1060的驱动后，我的外接显示器的分辨率竟然只能设置为2560×1440，看起来很难受。如果把分辨率设置成3840×2160，那外接显示器直接就没反应了。只能等20秒后自动重置。 虽然这个2560×1440勉强够用，但是本着解决问题的精神。经过我的尝试，在3840×2160下刷新率不能设置为60hz，当设置为59.94hz时就可以了。 这是Reddit网站上一个人的回答。 好了，现在分辨率可以了，但是因为缩放是100%，导致字特别小，在win10下我设置的缩放是150%。但是在Ubuntu设置里只有100%和200%缩放，200%太大，100%又太小。 1gsettings set org.gnome.mutter experimental-features &quot;[&apos;x11-randr-fractional-scaling&apos;]&quot; 解决方案就是上面的命令，用来开启缩放设置的实验性的功能。 终端流量走代理有的时候在终端使用git非常慢，所以想走代理流量，但是终端流量默认不走代理的。需要命令开启。 如果你是SSR,并且走的http的代理端口是12333，想执行wget或者curl来下载国外的东西，可以使用如下命令： 1export http_proxy=http://127.0.0.1:12333 如果是https那么就经过如下命令： 1export https_proxy=http://127.0.0.1:12333 以上命令是临时的，仅仅对你当前的终端生效。 不定期更新","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://Stefancharles.xyz/tags/Ubuntu/"}]},{"title":"【Ubuntu】Ubuntu和Win10双系统安装教程","slug":"installUbuntu","date":"2020-01-05T16:00:00.000Z","updated":"2020-01-07T07:00:56.928Z","comments":true,"path":"2020/01/06/installUbuntu/","link":"","permalink":"https://Stefancharles.xyz/2020/01/06/installUbuntu/","excerpt":"Ubuntu和Win10双系统安装教程前段时间我想更新一下我电脑里Ubuntu系统的内核，删除一些没用的内核，结果手贱的我多删了些东西导致网卡驱动没有了。虽然说可以有方法解决，但是我想着干脆再重装得了，顺便做一个教程记录安装的过程。 Today is the first day…of what’s left of you life.——《Iron Man 3》","text":"Ubuntu和Win10双系统安装教程前段时间我想更新一下我电脑里Ubuntu系统的内核，删除一些没用的内核，结果手贱的我多删了些东西导致网卡驱动没有了。虽然说可以有方法解决，但是我想着干脆再重装得了，顺便做一个教程记录安装的过程。 Today is the first day…of what’s left of you life.——《Iron Man 3》 准备阶段 一台可以上网的电脑 一个至少4GB的U盘 电脑内存至少4G 电脑处理器至少双核 下载镜像1.首先需要下载Ubuntu镜像文件。 点击这里去Ubuntu官方下载。 我下载的是19.10版本，这是目前新版本Ubuntu。当然你可以下载18.04.3长期支持版。系统当然是用新不用旧了。如果你觉得官方的下载链接很慢，你也可以点击下面的下载链接，下载种子后用迅雷进行下载。速度很快。 点击这里去下载19.10的种子文件，提取密码:1024。 2.下载U盘刻录软件。 这里有很多的工具可以进行刻录，我打算使用一个体积小但是功能强的小软件 Universal USB Installer。 点击这里去官网下载。 找到“Download”下载即可。 刻录U盘经过上面的两次下载，那么在你下载的路径下应该有ubuntu-19.10-desktop-amd64.iso文件和Universal-USB-Installer-1.9.9.0.exe软件。 注意：刻录U盘会格式化你的U盘，请务必提前备份U盘里重要的数据！ 首先双击U盘刻录软件Universal-USB-Installer-1.9.9.0.exe。 点击下方的”Create“即可开始刻录。刻录过程截图如下图，等几分钟即可。 磁盘分区如果你想把你用来主力工作的操作系统换成Ubuntu的话，那你就没有必要看这一章，请直接跳到安装就行。这一步是为了安装Windows和Ubuntu双系统。也就是说你以后可以选择进入哪一个系统。 首先打开windows10自带的磁盘管理如下图。 选一个你想安装Ubuntu的磁盘，然后右击这个磁盘，选择压缩卷。压缩卷的意思就是说分出多少空间出去。官方建议至少将Ubuntu安装在有25GB的空闲磁盘上。我这里就分75GB吧，因为还要安装编程软件什么的。这一步根据你的情况分。分完后会多出一块未使用灰色的区域，那说明这一步已经可以了。 正式安装Ubuntu1.首先百度或者谷歌查找你电脑品牌型号进入BIOS的快捷键。这一步就不多说了。不同的电脑进入BIOS的快捷键不一样。设置U盘为第一启动方式并关闭secure boot。然后重启电脑，从U盘启动。 从U盘启动后就是这个样子了。可以直接选择第三个“Install Ubuntu” 选项来进行安装，也可以和我一样选默认的第一个选项也行。第一个选项是体验Ubuntu。但是实际上体验的时候可以选择安装。那么我这里选择第一个后就回车。 然后桌面上有三个图标，双击第三个图标“Install Ubuntu 19.10”就可以进行安装了。 前面的语言选择你喜爱的语言。到这里的时候，请选择“其他选项”。下图注意序号三，这里请选择你挂载的/boot的设备，如果这里你选的默认的位置，那么你使用的就是Ubuntu引导win10。那你以后想卸载删除Ubuntu的时候将是一个麻烦事。 点击的“+”创建4个主要的基础分区（这里之前未分配的75G就是给ubuntu系统的75G），按以下参数设置4个主要的基础分区： 上图空间分配大小是参考，实际你分配的时候务必大于或者等于这么多。上面的表格主要是给你参考选择分区类型和挂载点。大小任你决定。 安装完成后，设置用户名和密码。 然后一直点击下一步，等待安装就行了。 结语到这里双系统的教程就结束了，当电脑开机的时候可以进行系统选择。至于安装Ubuntu后进行驱动更新，换国内源等事情下期有缘再见。","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://Stefancharles.xyz/tags/Ubuntu/"}]},{"title":"【Zigbee和STM32】智能家居系统","slug":"intelligentHome","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-06T07:14:17.782Z","comments":true,"path":"2020/01/05/intelligentHome/","link":"","permalink":"https://Stefancharles.xyz/2020/01/05/intelligentHome/","excerpt":"基于Zigbee和STM32的智能家居系统新的一年开始了，这个学期也差不多告一段落了，近段时间一直忙于做课程设计。空闲的时间相对于前几个星期来说有很多。毕竟一年结束了，本来在脑海了构想了很多话，想做一个关于过去一年里总结的博客， 但是这几天工作效率出奇的低，一直没能开始动手。现在先对Zigbee课程设计做一个总结当作热身吧。 Part of the journey is the end. ——Tony Stark 结束亦是旅途的一部分。——Tony Stark","text":"基于Zigbee和STM32的智能家居系统新的一年开始了，这个学期也差不多告一段落了，近段时间一直忙于做课程设计。空闲的时间相对于前几个星期来说有很多。毕竟一年结束了，本来在脑海了构想了很多话，想做一个关于过去一年里总结的博客， 但是这几天工作效率出奇的低，一直没能开始动手。现在先对Zigbee课程设计做一个总结当作热身吧。 Part of the journey is the end. ——Tony Stark 结束亦是旅途的一部分。——Tony Stark 设计方案概述 ​ 终端节点开发板采集温度等数据后发给协调器，协调器通过串口与STM32开发板相连接，STM32通过串口发给电脑。电脑使用我们自己开发的C#串口程序接收数据，将结果显示在电脑上。另一方面我们打算尝试开发板连接STM32端，将数据也发给STM32，STM32接ESP8266WiFi模块后发送数据至云平台，然后使用自己开发的手机端app接收云平台传来的数据，并上发数据给云平台，云平台将手机端的控制指令下发给32端，32端控制开发板亮灯或其他操作。 DHT11采集温度​ 在之前的实验中，当我使用DHT11在协议栈下总是无法正常采集温度，原因是DHT11需要有严格的时序，需要延时精确的10微秒等时间。而协议栈下会有很多事件打断定时器，从而无法产生精确的时间。 ​ 这一次，我询问了一些高手，终于发现了解决问题的关键。 1234567891011121314151617181920void Delay_us() //1 us延时&#123; MicroWait(1); &#125;void Delay_10us() //10 us延时&#123; MicroWait(10); &#125;void Delay_ms(uint Time)//n ms延时&#123; unsigned char i; while(Time--) &#123; for(i=0;i&lt;100;i++) Delay_10us(); &#125;&#125; ​ 没错，这里用的不是定时器计时，而是用的一个叫MicroWait(10)的函数。我们进这个函数看。发现这个函数事实上是另一个Onboard_wait(t)函数。这个函数是由开发板本身提供的onboard函数。这样一来就可以使用DHT11采集温湿度了。 1#define MicroWait(t) Onboard_wait(t) 终端节点终端节点要做的就两件事情，一个是采集温度然后发送给协调器，另一个事情就是接收来自协调器的控制命令并执行。 1234567891011121314151617181920212223242526272829303132void GenericApp_SendTheMessage(void)&#123; DHT11(); //温度采集 HalLedSet(HAL_LED_1,HAL_LED_MODE_ON); uint8 Temp[2]; Temp[0] = wendu_shi+0x30; Temp[1] = wendu_ge+0x30; uint8 humidity[2]; humidity[0] = shidu_shi+0x30; humidity[1] = shidu_ge+0x30; /*******串口打印*********/ HalUARTWrite(0,\"Temp:\",5); HalUARTWrite(0,Temp,2); HalUARTWrite(0,\" Hum:\",6); HalUARTWrite(0,humidity,2); HalLedSet(HAL_LED_1,HAL_LED_MODE_OFF); AF_DataRequest( &amp;GenericApp_DstAddr, &amp;GenericApp_epDesc, GENERICAPP_CLUSTERID, 2, humidity, &amp;GenericApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) ; AF_DataRequest( &amp;GenericApp_DstAddr, &amp;GenericApp_epDesc, GENERICAPP_TEMPCLUSTER, 2, Temp, &amp;GenericApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) ;&#125; 在终端节点加入协调器的网络后，进入面的GenericApp_SendTheMessage()函数里，在这个函数里调用DHT11()函数采集温度和湿度信息，把温度存到Temp数组里，湿度存到humidity数组里。然后设计两个簇分别将温度和湿度发送给协调器，这样设计的目的是为了方便协调器处理不同数据。 同时，终端节点需要接收来自协调器的控制信息，例如控制LED灯： 123456789101112131415161718192021222324252627void GenericApp_MessageMSGCB(afIncomingMSGPacket_t *pkt )&#123; char buf[7]; switch(pkt-&gt;clusterId) &#123; case (GENERICAPP_CLUSTERID): osal_memcpy(buf,pkt -&gt; cmd.Data,7); if(osal_memcmp(buf,\"LED_ON\",7)) &#123; HalLedSet(HAL_LED_2,HAL_LED_MODE_ON); &#125; if(osal_memcmp(buf,\"LED_OFF\",7)) &#123; HalLedSet(HAL_LED_2,HAL_LED_MODE_ON); &#125; case GENERICAPP_BROADCAST_CID: osal_memcpy(buf,pkt -&gt; cmd.Data,7); if(osal_memcmp(buf,\"LED_ON\",6)) &#123; HalLedSet(HAL_LED_2,HAL_LED_MODE_ON); &#125; if(osal_memcmp(buf,\"LED_OFF\",7)) &#123; HalLedSet(HAL_LED_2,HAL_LED_MODE_OFF); &#125; &#125;&#125; 协调器协调器收到来自终端节点的消息时，需要将数据交给32端。这里使用的是串口进行通信。也就是分簇进行消息处理，然后写到串口。这样温湿度数据就被交给32端了。 1234567891011121314151617181920212223void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )&#123; switch ( pkt-&gt;clusterId ) &#123; case GENERICAPP_CLUSTERID: HalLedSet(HAL_LED_1,HAL_LED_MODE_ON); osal_memcpy(humid, pkt-&gt;cmd.Data, 2); HalUARTWrite(0, humid, 2); HalUARTWrite(0, tmp, 2); Delay_ms(500); HalLedSet(HAL_LED_1,HAL_LED_MODE_OFF); break; case GENERICAPP_TEMPCLUSTER: HalLedSet(HAL_LED_1,HAL_LED_MODE_ON); HalUARTWrite(0, humid, 2); osal_memcpy(tmp, pkt-&gt;cmd.Data, 2); HalUARTWrite(0, tmp, 2); HalUARTWrite(0,\" \\n\",osal_strlen(\" \\n\")); Delay_ms(500); HalLedSet(HAL_LED_1,HAL_LED_MODE_OFF); break; &#125;&#125; 同时从串口接到32端发来的控制信息时，需要转发给终端节点，巧妙的地方在于，因为使用的是串口通信，这里就使用串口回调函数，关键代码如下： 1234567891011121314151617181920212223static void rxCB(uint8 port, uint8 event)&#123; osal_memset(uartbuf, 0, 32); HalUARTRead(0, uartbuf, 10); if (osal_memcmp(uartbuf, \"LED_ON\", 6)) &#123; AF_DataRequest(&amp;GenericApp_DstAddr, &amp;GenericApp_epDesc, GENERICAPP_BROADCAST_CID, (byte)osal_strlen(uartbuf) + 1, (byte *)&amp;uartbuf, &amp;GenericApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS); &#125; else if (osal_memcmp(uartbuf, \"LED_OFF\", 7)) &#123; AF_DataRequest(&amp;GenericApp_DstAddr, &amp;GenericApp_epDesc, GENERICAPP_BROADCAST_CID, (byte)osal_strlen(uartbuf) + 1, (byte *)&amp;uartbuf, &amp;GenericApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS); &#125;&#125; STM32端STM32端首先初始化中断分组，串口2，3。进行时钟初始化等，关键代码如下： 12345678NVIC_Priority_Group_Configuration(); SYSTICK_init(); uart_init(115200); delay_init(); LCD_Init(); rtc_init(NULL); USART3_Init(115200); USART2_Init(115200); 然后就是与云平台通信，事实上，ESP8266是通过串口和STM32进行通信。所以上面初始化的两个串口，一个是用于与协调器通信，另一个是用于ESP8266。与云平台通信的核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void cloud_task(void)&#123; char *temp = NULL; int8_t tempint=0,humidint=0; static uint32_t lastTime; static int8_t erroCount=0; int8_t error=0; char str[50]; if(F_AT_RX_FINISH) &#123; printf(AT_RX_BUF); USER_DataAnalysisProcess((char *)AT_RX_BUF); memset(IpData, 0x00, 128); ClrAtRxBuf(); &#125; if((uint32_t)(SYSTICK_get_time()-lastTime&gt;=500)&amp;&amp;(uint32_t)(SYSTICK_get_time()-lastTime&lt;=501)) &#123; RTC_Get(); tmp[0]=USART2_RX_BUF[2]; tmp[1]=USART2_RX_BUF[3]; tmp[2]='\\0'; sscanf(tmp, \"%d\", &amp;tempint); humid[0]=USART2_RX_BUF[0]; humid[1]=USART2_RX_BUF[1]; humid[2]='\\0'; sscanf(humid, \"%d\", &amp;humidint); USART2_RX_STA=0; sprintf(str,\"%d-%d-%d %d:%d:%d\",calendar.w_year,calendar.w_month,calendar.w_date,calendar.hour,calendar.min,calendar.sec); if(tempint!=0) error=SE_SendSensor((char *)\"temperature\", tempint, (char *)str); ClrAtRxBuf(); &#125; if((uint32_t)(SYSTICK_get_time()-lastTime&gt;=1000)) &#123; lastTime=SYSTICK_get_time(); RTC_Get(); tmp[0]=USART2_RX_BUF[2]; tmp[1]=USART2_RX_BUF[3]; sscanf(tmp, \"%d\", &amp;tempint); humid[0]=USART2_RX_BUF[0]; humid[1]=USART2_RX_BUF[1]; sscanf(humid, \"%d\", &amp;humidint); USART2_RX_STA=0; sprintf(str,\"%d-%d-%d %d:%d:%d\",calendar.w_year,calendar.w_month,calendar.w_date,calendar.hour,calendar.min,calendar.sec); if(humidint!=0) error=SE_SendSensor((char *)\"humidity\", humidint, (char *)str); ClrAtRxBuf(); &#125;&#125; 上面的函数是不断轮询F_AT_RX_FINISH，如果有内容就对内容进行解析。 一方面是USER_DataAnalysisProcess函数用于解析云平台发来的控制信息。另一方面，就是调用SE_SendSensor函数把采集到的数据进行上传到云平台。 解析开关灯，其实是解析一种json格式的数据，关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void USER_DataAnalysisProcess(char *RxBuf)&#123; char *cmdid = NULL; uint8_t TxetBuf[128]; if(strstr((const char *)RxBuf, (const char *)PING_REQ) != NULL) &#123; if(ESP8266_IpSend((char *)PING_RSP, strlen((const char *)PING_RSP)) &lt; 0) &#123; DBG_B_INFO(\"心跳包失败\\r\\n\"); &#125; else &#123; DBG_B_INFO(\"心跳包\\r\\n\"); &#125; &#125; else if(strstr((const char *)RxBuf, (const char *)\"\\\"t\\\":5\") != NULL) &#123; if(strstr((const char *)RxBuf, (const char *)\"\\\"apitag\\\":\\\"bool_work\\\"\") != NULL) &#123; memset(TxetBuf,0x00,128); if((strstr((const char *)RxBuf, (const char *)\"\\\"data\\\":1\") != NULL)) &#123; DBG_B_INFO(\"开灯\"); u2_printf(\"LED_ON\"); cmdid = USER_GetJsonValue((char *)RxBuf, (char *)\"cmdid\"); sprintf((char *)TxetBuf,\"&#123;\\\"t\\\":6,\\\"cmdid\\\":%s,\\\"status\\\":0,\\\"data\\\":1&#125;\",cmdid); if(ESP8266_IpSend((char *)TxetBuf, strlen((char *)TxetBuf)) &lt; 0) &#123; DBG_B_INFO(\"发送响应失败\"); &#125; &#125; else if((strstr((const char *)RxBuf, (const char *)\"\\\"data\\\":0\") != NULL)) &#123; DBG_B_INFO(\"关灯\"); u2_printf(\"LED_OFF\"); cmdid = USER_GetJsonValue((char *)RxBuf, (char *)\"cmdid\"); sprintf((char *)TxetBuf,\"&#123;\\\"t\\\":6,\\\"cmdid\\\":%s,\\\"status\\\":0,\\\"data\\\":0&#125;\",cmdid); if(ESP8266_IpSend((char *)TxetBuf, strlen((char *)TxetBuf)) &lt; 0) &#123; DBG_B_INFO(\"发送响应失败\"); &#125; &#125; &#125; &#125;&#125; 当然这部分的代码可以进行拓展，例如说可以加入控制继电器等等。稍加改动即可。值得注意的是这里需要事先设置好云平台那边的apitag，apitag一定要一致才可正常收发数据。安卓端也是同理。 32端除了与云平台进行通信，还要动态刷新LCD显示屏。这部分关键代码如下： 12345LCD_ShowString(30,60,200,16,16,\"Temperature:\"); LCD_ShowString(130,60,200,16,16,tmp); LCD_ShowString(30,100,200,16,16,\"Humidity:\");LCD_ShowString(120,100,200,16,16,humid);LCD_ShowString(30,280,200,16,16,\"(c) Security Plus Inc.\"); 安卓端安卓端这边的设计一时半会也讲不清，这里先假设你有一定的云平台开发经验。下面链接是我之前暑假期间写的，可以先去看看。 传送门：新大陆安卓端笔记(一) 我这里就主要写下关键的部分。安卓端主要使用新大陆的SDK进行通信。可以显示温度和湿度信息到仪表盘上，并且可以控制灯和风扇等。 关键的获取温度代码如下： 123456789101112131415161718192021public void getTemperature() &#123; netWorkBusiness.getSensor(deviceID, \"temperature\", new NCallBack&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt;() &#123; @Override public void onResponse(final Call&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt; call, final Response&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt; response) &#123; BaseResponseEntity baseResponseEntity = response.body(); if (baseResponseEntity != null) &#123; final Gson gson = new Gson(); JSONObject jsonObject; String msg = gson.toJson(baseResponseEntity); try &#123; jsonObject = new JSONObject(msg); //解析数据. JSONObject resultObj = (JSONObject) jsonObject.get(\"ResultObj\"); String TempValue = resultObj.getString(\"Value\"); temperature_d = Double.valueOf(TempValue).intValue(); temperature = (int) temperature_d; mDeviceTempHum.setTemp(temperature);//显示温度数据到仪表盘 &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 控制终端节点的关键代码如下： 1234567891011121314btn_light.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(!light_state)&#123; control(deviceID,\"bool_work\",1); // 开灯. btn_light.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, R.drawable.power_on); &#125; else&#123; control(deviceID,\"bool_work\",0); //关灯. btn_light.setCompoundDrawablesWithIntrinsicBounds(0,0,0,R.drawable.power_off); &#125; light_state = !light_state; &#125; &#125;); 实现结果安卓端 登录界面如上图。登录界面可以左右滑动切换背景。 这里有点意思的是，我使用的账号的调用API的密钥过期了，而我没有重新申请一个。导致我获取温度的时候一直失败，但是诡异的是我可以正常登录进去。我仔细检查了apitag等参数也没有问题，但是问题依然没解决。我以为新大陆那边改了api，于是我进调试模式试图获取一下登录后的用户token，这时回给我的不是token，而是过期提示。我这才发现密钥已经过期，重新申请后就正常获取温度了。 当密钥过期后不会返回token，我寻思着应该是这里返回的state依然和正常登录一样的，导致安卓端调用登录api时发现返回状态是成功登录，但是没有检查token是否返回数值。 登录成功后，进入主界面，可以看到温度和湿度信息，并通过下面的两个按钮来控制灯和风扇。按钮有两种状态，红色按钮代表关闭，绿色按钮代表开启。点击“查看历史温度”可以查看历史温度或者湿度的曲线图。 C#端串口老助手 这里串口线接到终端节点上，接32端时还是有很多问题，这里待解决。 总体概览 总体连接图就是这样的了。这几天实验室空调坏了，实验室温度只有18度。 经过我们小组成员的努力，改进了终端节点LED的响应速度。但是实际上的响应速度还是有点不理想，没有完美。主要原因可能是它使用的轮询的方式接收来自云平台的消息，而不是采用中断方式，这一点可以以后进行改进。 在云平台的网页端也可以看到温湿度变化趋势。 与本文不搭边的结语“Part of the journey is the end”，中文翻译大致是“结束亦是旅途的一部分。”。我个人感觉，如果把这句话翻译成中文倒缺了一点意味。 这句话是出自于电影《复仇者联盟-终局之战》里钢铁侠Stark在进行时空跳跃前给大家留下的全息留言中的一句话。以防这一次他离开就再也回不来而留下的“Last Words”。当我第一次在电影院听到他说这句话的时候，我听出了这句话里面的遗憾和不舍。对他自己而言，他已经有了一个完美的家庭，有一个爱他三千遍的小女儿。为了peter和其他消失的人能够“复活”，他冒着失去他所拥有的人的风险，如果他自己没能回来，那不能陪伴遗憾和不舍自然会有。对我们观众而言，从十年前的《钢铁侠1》开始到如今这个系列最后的完结，感觉就像几年前而已，没想到时间过得这么快，没想到都要面临Iron Man的离开，至少对我来说，我是感觉到深深的不舍和遗憾。 于是我把这句话设成了我的QQ的签名，再也没改过，这一晃差不多一年又过去了。这次考完考试的我又突然想再看一遍《 Endgame》。而这一次当我再看到那句话的时候，我又读到了新的意味，那是一种释然。告别的释然。遗憾和不舍中又带着告别的释然。我想到了什么，但是我又具体形容不出这种感觉。 我的意思是，一年的时间已经告一段落，每个人或多或少have lost something。这是一种结束，我试图让我自己看明白一个道理——结束也是旅途的一部分。我也试图让我自己面对结束的时候，尽力挥手告别就好。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"},{"name":"STM32","slug":"STM32","permalink":"https://Stefancharles.xyz/tags/STM32/"}]},{"title":"【C#】串口老助手","slug":"UartHelper","date":"2019-12-27T16:00:00.000Z","updated":"2019-12-28T04:36:12.968Z","comments":true,"path":"2019/12/28/UartHelper/","link":"","permalink":"https://Stefancharles.xyz/2019/12/28/UartHelper/","excerpt":"自制C#端串口老助手因为我打算在Zigbee课程设计中使用到电脑通过串口线与Zigbee开发板相连接，所以准备自己写一个C#端的串口老助手。方便我们后面进行工作。 Don’t forget the things you once have owned. Treasure the things you can’t get. Don’t give up the things belong yo you. Keep those lost things in memory.","text":"自制C#端串口老助手因为我打算在Zigbee课程设计中使用到电脑通过串口线与Zigbee开发板相连接，所以准备自己写一个C#端的串口老助手。方便我们后面进行工作。 Don’t forget the things you once have owned. Treasure the things you can’t get. Don’t give up the things belong yo you. Keep those lost things in memory. SerialPort 类在.NET Framework 2.0以上里提供了SerialPort类，该类主要实现串口数据通信等。点击这里去官方介绍。 其实大部分工作.Net已经帮我们做好了。所以总体来说，我们要做的事情其实很简单。 串口操作步骤首先实例化串口对象： 1SerialPort serialPort = new SerialPort(); 对串口的配置操作： 1234567serialPort.PortName = &quot;COM3&quot;;//串口名serialPort.BaudRate = 9600;//波特率serialPort.DataBits = 8;//数据位serialPort.Parity = Parity.None;//校验位serialPort.StopBits = StopBits.One;//停止位serialPort.ReadTimeout = 1000;//读串口延时serialPort.WriteTimeout = 1000;//写串口延时 打开和关闭串口： 12serialPort.Open();//打开串口serialPort.Close();//关闭串口 读写串口数据： 12345678910111213Byte[] InputBuf = new Byte[128];try&#123; serialPort.Read(InputBuf, 0, serialPort.BytesToRead); System.Threading.Thread.Sleep(50); ASCIIEncoding encoding = new ASCIIEncoding(); textBoxReceive.Text += encoding.GetString(InputBuf);&#125;catch (System.Exception ex)&#123; MessageBox.Show(ex.ToString()); return;&#125; 值得注意的是，一开始我用的ReadLine()方法，而ReadLine()是阻塞的，直至遇到一个换行符后返回。在读取数据时，如果一直没有遇到换行符，那么在等待ReadTimeout时间后，抛出一个TimeoutException。默认情况下，ReadTimeout为InfiniteTimeout。这样，ReadLine一直处于阻塞状态，直至有新一行数据到达。 这也就导致我一开始测试的时候一直提示在这里TimeoutException。可以在Zigbee开发板里的串口回调函数加入一换行符解决这个问题，但是在硬件端做这件事麻烦很多，而且传输了一些不是很有必要数据。所以我这里换一种方式，直接调用serialPort.Read方法读到一个Byte[]数组里。后面再转String输出到textBox里。 另外，WriteLine()方法也是阻塞的，如果另一方不能及时接收数据，就会引起TimeoutException异常。由于ReadLine()和WriteLine()方法都是阻塞式的，在程序使用SerialPort 进行串口通讯时，一般应该把读写操作交由其他线程处理，避免因为阻塞而导致程序不响应。 界面为了方便我们进行操作，我们画一个简单的界面。界面按喜好随意布置。 上图是一个Demo。左边是5个label和5个combobox，用来自由选择串口号，波特率等。当串口不处于打开状态时，这些combobox的enable才置true，否则置false。这里就在“打开/关闭串口”的button里的click事件写相关判断即可。 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private void buttonOpenCloseCom_Click(object sender, EventArgs e) &#123; if (!serialPort.IsOpen)//串口处于关闭状态 &#123; try &#123; if (comboBoxCom.SelectedIndex == -1) &#123; MessageBox.Show(&quot;Error: 无效的端口,请重新选择&quot;, &quot;Error&quot;); return; &#125; string strSerialName = comboBoxCom.SelectedItem.ToString(); string strBaudRate = comboBoxBaudRate.SelectedItem.ToString(); string strDataBit = comboBoxDataBit.SelectedItem.ToString(); string strCheckBit = comboBoxCheckBit.SelectedItem.ToString(); string strStopBit = comboBoxStopBit.SelectedItem.ToString(); Int32 iBaudRate = Convert.ToInt32(strBaudRate); Int32 iDataBit = Convert.ToInt32(strDataBit); serialPort.PortName = strSerialName;//串口号 serialPort.BaudRate = iBaudRate;//波特率 serialPort.DataBits = iDataBit;//数据位 switch (strStopBit) //停止位 &#123; case &quot;1&quot;: serialPort.StopBits = StopBits.One; break; case &quot;1.5&quot;: serialPort.StopBits = StopBits.OnePointFive; break; case &quot;2&quot;: serialPort.StopBits = StopBits.Two; break; default: MessageBox.Show(&quot;Error：停止位参数错误&quot;, &quot;Error&quot;); break; &#125; switch (strCheckBit) //校验位 &#123; case &quot;None&quot;: serialPort.Parity = Parity.None; break; case &quot;Odd&quot;: serialPort.Parity = Parity.Odd; break; case &quot;Even&quot;: serialPort.Parity = Parity.Even; break; default: MessageBox.Show(&quot;Error：校验位参数错误&quot;, &quot;Error&quot;); break; &#125; if (saveDataFile != null) &#123; saveDataFS = File.Create(saveDataFile); &#125; //打开串口 serialPort.Open(); //打开串口后设置将不再有效 comboBoxCom.Enabled = false; comboBoxBaudRate.Enabled = false; comboBoxDataBit.Enabled = false; comboBoxCheckBit.Enabled = false; comboBoxStopBit.Enabled = false; radioButtonSendDataASCII.Enabled = false; radioButtonSendDataHex.Enabled = false; radioButtonReceiveDataASCII.Enabled = false; radioButtonReceiveDataHEX.Enabled = false; buttonSendData.Enabled = true; Button_Refresh.Enabled = false; buttonOpenCloseCom.Text = &quot;关闭串口&quot;; &#125; catch(System.Exception ex) &#123; MessageBox.Show(&quot;Error:&quot; + ex.Message, &quot;Error&quot;); return; &#125; &#125; else //串口处于打开状态 &#123; serialPort.Close();//关闭串口 //串口关闭时设置有效 comboBoxCom.Enabled = true; comboBoxBaudRate.Enabled = true; comboBoxDataBit.Enabled = true; comboBoxCheckBit.Enabled = true; comboBoxStopBit.Enabled = true; radioButtonSendDataASCII.Enabled = true; radioButtonSendDataHex.Enabled = true; radioButtonReceiveDataASCII.Enabled = true; radioButtonReceiveDataHEX.Enabled = true; buttonSendData.Enabled = false; Button_Refresh.Enabled = true; buttonOpenCloseCom.Text = &quot;打开串口&quot;; if (saveDataFS != null) &#123; saveDataFS.Close(); // 关闭文件 saveDataFS = null;//释放文件句柄 &#125; &#125; &#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://Stefancharles.xyz/tags/C/"}]},{"title":"【NetSecurity】期末复习知识点","slug":"Netsecurereview","date":"2019-12-24T16:00:00.000Z","updated":"2019-12-27T03:40:00.462Z","comments":true,"path":"2019/12/25/Netsecurereview/","link":"","permalink":"https://Stefancharles.xyz/2019/12/25/Netsecurereview/","excerpt":"NetSecurity期末复习知识点本篇文章按计算机网络安全的PPT按章节进行知识点进行梳理。考试当天将会暂时关闭本博客。请理解。文中若有疏漏之处还请联系我改正。 世界依然美丽，却没有你想要守护的那些东西。你抛弃了那些东西，只为守护你自己。路的末端，万籁俱寂。回首怅望，再也找不见，那份即使燃烧生命也应紧握手中的美丽。——《隐形守护者-美丽世界线》 The world is still beautiful, but without those things you want to protect. You abandoned those things just to protect yourself. At the end of the road, everything is silent. Looking back, you will never see it again, even if the life is burning, the beauty in the hands should be shaken tightly.","text":"NetSecurity期末复习知识点本篇文章按计算机网络安全的PPT按章节进行知识点进行梳理。考试当天将会暂时关闭本博客。请理解。文中若有疏漏之处还请联系我改正。 世界依然美丽，却没有你想要守护的那些东西。你抛弃了那些东西，只为守护你自己。路的末端，万籁俱寂。回首怅望，再也找不见，那份即使燃烧生命也应紧握手中的美丽。——《隐形守护者-美丽世界线》 The world is still beautiful, but without those things you want to protect. You abandoned those things just to protect yourself. At the end of the road, everything is silent. Looking back, you will never see it again, even if the life is burning, the beauty in the hands should be shaken tightly. 第一章 概述1.网络安全的属性 机密性 完整性 可用性 非否认性 可控性 真实性 其中，机密性，完整性，可用性通常被认为是网络安全的三个基本属性。 2.OSI （Open System Interconnection Model）安全体系结构主要关注安全攻击，安全机制，安全服务。 3.安全攻击： 分类：安全攻击分为被动攻击和主动攻击。 被动攻击的特征是对传输进行窃听和监测。被动攻击的目的是获得传输的信息，不对信息作任何改动。被动攻击主要威胁信息的保密性。常见的被动攻击包括消息内容的泄漏和流量分析。 主动攻击主要威胁信息的完整性、可用性和真实性。主动攻击包括伪装，重放，消息篡改，拒绝服务。 4.安全机制： 定义：阻止安全攻击及恢复系统的机制称为安全机制。 分类：OSI 安全框架将安全机制分为特定的安全机制和普遍的安全机制。 特定的安全机制（与安全服务有关的机制） 包括：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制和公证。 普遍的安全机制 （与管理软件相关的机制）包括：可信功能机制、安全标签机制、事件检测机制、审计跟踪机制、安全恢复机制。 5.安全目标： 定义：信息安全的目标 是指能够满足一个组织或者个人的所有安全需求。 CIA：CIA 三元组的目标，即保密性(Confidentiality) ，完整性 (Integrity) 和可用性 (Availability)。 安全需求：可用性 (Availability)，完整性 (Integrity) ，保密性(Confidentiality)，可追溯性(Accountability)，保障(Assurance) 。 6.安全服务模型： 主要组成：支撑服务，预防服务，检测和恢复服务。 支撑服务主要有：鉴别，密钥管理，安全性管理，系统保护。 预防服务主要有：受保护的通信，认证，授权，访问控制，交易隐私，不可否认。 恢复服务主要有：审计，入侵检测，整体检验，恢复安全状态。 访问控制就是要根据一定的原则对合法用户的 访问权限 进行控制，以决定他可以访问那些资源以及以什么样的方式访问这些资源。 7.简述三种常用的访问控制策略。 （1）入网访问控制：入网访问控制是网络访问的第一层访问控制。对用户可规定所能登入到的服务器及获取的网络资源，控制准许用户入网的时间和登入入网的工作站点。用户的入网访问控制分为用户名和口令的识别与验证、用户账号的默认限制检查。该用户若有任何一个环节检查未通过，就无法登入网络进行访问。 （2）网络的权限控制：网络的权限控制是防止网络非法操作而采取的一种安全保护措施。用户对网络资源的访问权限通常用一个访问控制列表来描述。 从用户的角度，网络的权限控制可分为以下3类用户： 特殊用户。具有系统管理权限的系统管理员等。 一般用户。系统管理员根据实际需要而分配到一定操作权限的用户。 审计用户。专门负责审计网络的安全控制与资源使用情况的人员。 （3）目录级安全控制：目录级安全控制主要是为了控制用户对目录、文件和设备的访问，或指定对目录下的子目录和文件的使用权限。用户在目录一级制定的权限对所有目录下的文件仍然有效，还可进一步指定子目录的权限。 在网络和操作系统中，常见的目录和文件访问权限有：系统管理员权限（Supervisor）、读权限（Read）、写权限（Write）、创建权限（Create）、删除权限（Erase）、修改权限（Modify）、文件查找权限（File Scan）、控制权限（Access Control）等。一个网络系统管理员应为用户分配适当的访问权限，以控制用户对服务器资源的访问，进一步强化网络和服务器的安全。 8.简述什么是基于角色的访问控制RBAC。 基于角色的访问控制（Role-Based Access Control，RBAC）是通过对角色的访问所进行的控制。使权限与角色相关联，用户通过成为适当角色的成员而得到其角色的权限。可极大地简化权限管理。为了完成某项工作创建角色，用户可依其责任和资格分派相应的角色，角色可依新需求和系统合并赋予新权限，而权限也可根据需要从某角色中收回。减小了授权管理的复杂性，降低管理开销，提高企业安全策略的灵活性。 第二章 密码学1.密码学目标 隐私和保密性（privacy or confidentiality） 数据完整性（data integrity） 授权（authentication） 非否认（non repudiation） 2.密码系统包括以下四个方面：明文空间、密文空间、密钥空间、密码算法。 3.密码的分类 按照加密过程中转换操作的原理，可分为：代换密码和置换密码； 按照密钥的特点，可分为：对称密码和非对称密码； 按照加密方式不同（处理单元长度不同），可分为：分组密码和流密码（序列密码）。 4.密码学基本概念（五元组 P,C,K,E,D） P：明文空间，是所有可能的明文构成的集合 C：密文空间，是所有可能的密文构成的集合 K：密钥空间，是所有可能的密钥构成的集合 E和D分别表示加密算法和解密算法的集合。满足：对每一个k∈K，必然存在一个加密算法 ek 和一个解密算法 dk ，使得对任意m∈P，恒有 dk( ek (m)) = m。 明文：需要被隐蔽的消息称作明文，通常用m表示。 Message or Plaintext。 另一种说法：发送者要发送的信息未经过加密，可以直接分析表达的意思。 密文：将明文隐蔽后的结果称作密文，通常用c表示。 Ciphertext。 另一种说法：明文经过加密后的数据信息。 密钥( Key )：加/解密过程中使用到的明文，密文以外的其他参数。密钥又分为加密密钥和脱密密钥。 加密（ Encryption ）：将明文变换成密文的过程称作加密。 脱密（ Decryption ）：合法用户由密文恢复出明文的过程称作脱密。 加密算法：明文到密文的变换法则。 解密算法：密文到明文的变换法则。 5.MD5（Message-Digest Algorithm） MD5码以 512 位分组来处理输入的信息，且每一分组又被划分为16个32位子分组。 经过处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个 128 位散列值。 6.DES（Data Encryption Standard）参考书本P32 DES是一个分组加密算法，它以 64 位为分组对数据加密。 64 位一组的明文从算法的一端输入， 64 位的密文从另一端输出。DES 是一个对称算法：加密和解密用的是同一算法（除密钥编排不同以外）。密钥长度为56。 DES设计中使用了分组密码设计的两个原则：混淆（confusion）和扩散(diffusion)。 思路：DES对 64 位的明文分组进行操作。通过一个初始置换，将明文分成左半部分和右半部分，各 32 位长。然后进行 16 轮完全相同的运算，这些运算被称为函数 f ，在运算过程中数据与密钥结合。经过 16 轮后，左，右半部分合在一起经过一个末置换（初始置换的逆置换），这样该算法就完成了。 （1）初始置换IP 置换主要用于对明文中的各位进行换位，目的在于打乱明文中各位的排列顺序。 （2）16轮迭代 经过IP变换的64位结果分为两个部分L0和R0，作为16轮迭代的输入。密钥K经过拓展产生16个48位的子密钥，每一轮使用一个子密钥。整个16轮迭代适用于加密和解密。 （3）初始逆置换IP -1 对16轮迭代的输出R16L16进行初始逆置换。目的是为了使加密解密使用同一种算法。 F函数是16轮迭代阶段的核心，它包括四个过程： （1）拓展变换 把32位输入扩展为48位。 （2）子密钥混合 将扩展置换的48位结果与一个48位的子密钥进行异或得到48位的混合结果。 （3）S盒代换 S盒的功能是压缩替换，把上面48位的输入分成8组，每组6位，每组通过S盒之后变成4位输出，组合后变为32位。 （4）P盒置换 对来自S盒的32位输入做P替换，与IP和FP的操作类似，目的一样是为了打乱排列顺序，让下一轮的每一组数能够通过不同的S盒。 7.简述公钥密码体制的基本思想以及相对于传统密码体制的优势 （1）基本思想是把密钥分为两个部分：公钥和私钥。公钥可以向外界公布，私钥是保密的。 密钥中的任何一个可以用来加密，另一个用来解密。公钥私钥配合使用。 知道一个密钥无法求解另一个密钥。 （2）相对于传统密码体制，公钥密码体制的公钥可以记录在一个公共数据库或以可信的方式公开发放。私钥由持有者保存。这样任何人都可以通过公开的途径获得一个用户的公钥来进行保密通信。解密只能由私钥的持有者进行。简化了密钥的分配和分发。 （3）因为公钥密码体制的非对称性和私钥只由一个人私人持有的特性，使得公钥密码体制不仅可以像传统密码体制一样用于消息加密，实现保密通信外，还可以应用于数字签名，认证领域。 8.简述Vernam密码体制，并指出实际应用的难点在哪里？ （1）Vernam加密法也称一次一密(One-Time-Pad)，它使用与消息等长的且无重复的随机密钥来加密消息。密钥只对一个消息进行解密，之后丢弃不用。每条新消息都需要一个与其等长的新密钥。 （2）难点： 产生大规模随机密钥的实际困难。一次一密需要很长的密钥序列，且不允许重复，这需要很大的代价产生，传输和保存。 密钥的分配和维护。对于每一条发送的消息，需要提供发送方和接收方等长度的密钥。 9.RSA算法的理论基础是数论中“大整数的素因子分解困难问题”。 即求两个大素数的乘积容易，但是将一个大整数分解成两个大素数的乘积困难。 10.简述RSA算法密钥产生过程。 （1）随机选择两个大素数p和q，计算N=p*q。其中p，q必须保密。 （2）根据欧拉函数计算小于N的且与N互素的正整数的数目：r= (p-1)(q-1)。 （3）随机选择一个小于r的整数e，使e与r互质。并求e关于r的模逆元d。即求d令ed≡1(mod r )。 （4）销毁p和q。 (N，e)是公钥，(N，d) 是私钥。 11.简述RSA算法加密解密过程。 加密：明文以分组为单位进行加密。 C=Me mod n 解密： M = Cd mod n = (Me)d mod n 第三章 消息鉴别和数字签名1.简述数字签名的基本原理及过程。 假定接收方已知发送的公钥，则发送方可以用自己的私钥对整个消息或消息的散列码加密产生数字签名，接收方用发送方的公钥对签名进行验证从而确认签名和消息的真实性。 2.简述哈希函数需要具有哪些基本属性。 （1）单向性：对任意给定的散列码h，找到满足H(X)=h的x在计算上不可行。即给定散列函数h，由消息M计算散列值H(M)是容易的，但是由散列值H(M)计算消息M是不可行的。 （2）抗冲突性 强对抗碰撞性：满足以下条件 散列函数h的输入是任意长度的消息M 散列函数h的输出是固定长度的数值 给定h和M，计算h(M)是容易的。 给定散列函数h，寻找两个不同的消息M1和M2，使得其计算出来的散列值相同，在计算上是不可行的。 弱对抗碰撞性：前三个条件和强对抗碰撞性相同 给定h和一个随机选择的消息M，寻找消息M‘，使得两者计算出的散列值相同在计算上是不可行的。 （3）映射分布均匀性和差分分布均匀性 3.说明数字信封的主要流程以及数字信封的重要作用。 数字信封主要流程：在数字信封中，信息发送方采用对称密钥来加密信息内容，然后将此对称密钥用接收方的公钥来加密（这部分称数字信封）之后，将它和加密后的信息一起发送给接收方，接收方先用相应的私有密钥打开数字信封，得到对称密钥，然后使用对称密钥解开加密信息。 数字信封重要作用：数字信封既发挥了对称加密算法速度快、安全性好的优点，又发挥了非对称加密算法密钥管理方便的优点。数字信封技术结合了秘密密钥加密技术和公开密钥加密技术的优点，使用两个层次的加密来获得公开密钥（非对称密钥）技术的灵活性和秘密密钥（对称密钥）技术的高效性，保证信息的安全性。 基于公钥密码的数字签名的优点： 可验证：签字是可以被确认的。 防抵赖：发送方无法抵赖自己发送过报文。 防假冒：攻击者无法冒充发送者向接收方发送文件。 防篡改：接收方无法对收到的文件进行篡改。 防伪造：接收方无法对伪造对报文的签名。 第四章 身份认证1.公钥基础设施（Public key infrastructure） 定义：简单来说，PKI是基于公钥密码技术，支持公钥管理，提供真实性，保密性，完整性以及可追究性的安全服务，具有普适性的安全基础设施。 系统组成： 认证机构 (CA,certificate authority)：CA是PKI的核心执行机构，是PKI的主要组成部分。 数字证书库：证书库是CA颁发证书和撤销证书的集中存放地。 密钥备份及恢复系统 ：必须由可信机构来完成。只能恢复公钥，私钥不能备份。 证书作废系统 应用接口API 第五章 Internet安全1.网络层目前最常用的安全协议是 IPSec 协议，传输层常用的安全协议是 SSL/TLS 协议。 IPSec(Internet Protocol Security 互联网安全协议) SSL(Secure Sockets Layer 安全套接层) TLS(Transport Layer Security 传输层安全) 2.IPSec 工作模式 IPSec的安全功能主要通过IP认证头（AH）协议以及封装安全载荷（ESP）协议实现。AH和ESP都支持两种模式：传输模式和隧道模式。 IPSec协议(包括AH和ESP)既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面的保护分别是由IPSec两种不同的模式来提供。 其中，传输模式用来保护上层协议；通道模式用来保护整个IP数据报。 在传输模式中, IPSec先对上层协议进行封装，增加一IPSec头，对上层协议的数据进行保护，然后由IP协议对封装的数据进行处理，增加IP头; 在通道模式中，IPSec 对IP协议处理后的数据进行封装，增加一IPSec 头，对IP数据报进行保护，然后再由IP协议对封装的数据进行处理，增加新IP头。 第七章 防火墙1.扫描的主要功能。 扫描目标主机识别其工作状态（开/关机） 识别目标主机端口的状态（监听/关闭） 识别目标主机操作系统的类型和版本 识别目标主机服务程序的类型和版本 分析目标主机、目标网络的漏洞（脆弱点） 生成扫描结果报告 2.防火墙的主要功能。 建立一个集中的监视点 隔绝内、外网络，保护内部网络 强化网络安全策略 有效记录和审计内、外网络之间的活动 3.防火墙的主要缺点。 不能防范不经由防火墙的攻击 防火墙是一种被动安全策略执行设备，即对于新的未知攻击或者策略配置有误，防火墙就无能为力了 防火墙不能防止利用标准网络协议中的缺陷进行的攻击 防火墙不能防止利用服务器系统漏洞进行的攻击 防火墙不能防止数据驱动式的攻击 防火墙无法保证准许服务的安全性 防火墙不能防止本身的安全漏洞威胁 防火墙不能防止感染了病毒的软件或文件的传输 4.防火墙的三个基本特性。 内部网络和外部网络之间的所有网络数据流都必须经过防火墙 只有符合安全策略的数据流才能通过防火墙 防火墙自身应具有非常强的抗攻击免疫力 5.防火墙的类型。 按照防火墙的软硬件形式分类可分为软件防火墙、硬件防火墙、芯片级防火墙 按照防火墙的技术分类可分为包过滤型、应用代理型 按照防火墙体系结构分类可分为单一主机防火墙、路由器集成式防火墙、分布式防火墙 按照防火墙的性能分类可分为百兆级防火墙、千兆级防火墙 6.IDS优缺点 优点：实时监控网络安全状态 缺点：误报警，缓慢攻击，新的攻击模式 7.IDS分类 按照分析方法（检测方法）：异常检测模型（漏报率低，误报率高）、误用检测模型（误报低，漏报高） 按照数据来源：基于主机、基于网络、混合型 基于主机：视野集中，易于用户自定义，保护更加周密，对网络流量不敏感基于网络：侦测速度快，隐蔽性好，视野更宽，较少的检测器，占资源少 按系统各模块的运行方式：集中式、分布式 根据时效性：脱机分析、联机分析 近期更新，请不定期地刷新本页面来获取最新内容。","categories":[{"name":"复习","slug":"复习","permalink":"https://Stefancharles.xyz/categories/复习/"}],"tags":[{"name":"NetSecurity","slug":"NetSecurity","permalink":"https://Stefancharles.xyz/tags/NetSecurity/"}]},{"title":"【Zigbee】zigbee期末复习知识点","slug":"Zigbeereview","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-23T13:31:17.953Z","comments":true,"path":"2019/12/18/Zigbeereview/","link":"","permalink":"https://Stefancharles.xyz/2019/12/18/Zigbeereview/","excerpt":"Zigbee期末复习知识点本篇文章按Zigbee题库进行知识点进行梳理。考试当天将会暂时关闭本博客。请理解。文中若有疏漏之处还请联系我改正。 愿我们在抵达路的末端时，都不会后悔。——《隐形守护者》 May we never regret when we reach the end of the road.","text":"Zigbee期末复习知识点本篇文章按Zigbee题库进行知识点进行梳理。考试当天将会暂时关闭本博客。请理解。文中若有疏漏之处还请联系我改正。 愿我们在抵达路的末端时，都不会后悔。——《隐形守护者》 May we never regret when we reach the end of the road. Zigbee基础部分1.Zigbee协议栈层与层之间需要通过服务接入点（SAP）进行信息交换，而各层的服务接入点是采用称为“原语”操作来表述的。服务原语根据功能可分为4种类型，分别为： 请求（Request）原语， 用户实体要求服务做某项工作， 源（N+1)实体—&gt;源（N）实体 指示（Indication）原语， 用户实体被告知某事件发生， 目的（N）实体—&gt;目的（N+1)实体 响应（Response）原语， 用户实体表示对某事件的响应， 目的（N+1)实体—&gt;目的（N）实体 确认（Confirm）原语， 用户实体收到关于它的请求的答复， 源（N）实体—&gt;源（N+1）实体 2.Zigbee的基础是IEEE 802.15.4标准，其仅处理低级的物理层和MAC层协议，Zigbee联盟对网络层和应用层协议进行了标准化。 3.Zstack中Profile文件夹对应Zigbee软件架构中的AF层。 4.MAC层数据帧一共有4种帧类型：信标帧，数据帧，命令帧，确认帧。 5.zigbee的应用层由APS, AF, ZDO和制造商定义的应用对象组成。 6.APP层为zstack协议栈的应用层，是面向用户开发的，在这一层用户可以根据自己的需求建立所需要的项目，添加用户任务,并通过调用API实现项目所需要的功能。 7.物联网底层感知信息技术： RFID技术 传感器技术 二维码技术 8.网络层通过MCPS-SAP和MLME-SAP接口为MAC层提供接口。 9.网络层通过NLDE-SAP与NLME-SAP接口为应用层提供接口服务。具体来说，NLDE-SAP属于网络层与应用层数据服务接口。NLME-SAP属于网络层与应用层管理服务接口。 10.APS子层的构成和接口图。 Zigbee硬件1.属于CC2530物理存储器的是：RAM、Flash、SFR寄存器、信息页面 RAM有两大类，一种称为静态RAM（Static RAM/SRAM），SRAM速度非常快，是目前读写最快的存储设备，但是它非常昂贵，所以只在要求很苛刻的地方使用，如CPU的一级缓冲，二级缓冲。另一种称为动态RAM（Dynamic RAM/DRAM），DRAM保留数据的时间很短，速度也比SRAM慢，不过它还是比任何的ROM都要快，但从价格上来说DRAM相比SRAM要便宜很多。 2.Zigbee技术特点的是低功耗、低成本、大容量、可靠、时延短、灵活的网络拓扑结构；Zigbee是一种近距离 低复杂度 低功耗 低成本双向无线通讯技术。 3.CC2530的串口模式分为异步URAT模式和同步SPI模式。 4.CC2530包括3个8位输入/输出（I/O）端口，分别是P0、 P1、 P2。 5.Zigbee硬件分为三部分，即 CC2530核心板、协调器底板 和 路由器底板 。 6.在Zigbee网络中具有路由转发功能的节点是路由器节点。 7.CC2530的8051CPU有四个不同的存储空间，分别为CODE、DATA、XDATA和SFR。 通信1.Zigbee网络中实现点对点的通信需要使用单点寻址地址模式。 2.在Zigbee网络中协调器需要网络中的每个设备都收到数据使用广播寻址模式。 3.中国使用的Zigbee工作的频段是2.4GHz，定义了16个信道。 欧洲868MHz，信道1个；美国915MHz，信道10个。 4.IEEE 802.15.4 (物理层)的数字高频调制使用2.4G直接序列扩频技术。(direct-sequence spread spectrum，DSSS) Zigbee网络结构和拓扑结构1.Zigbee网络结构分为4层，从下至上分别为 物理层 MAC层 网络层 应用层 。 2.在Zigbee结构中物理层与硬件息息相关。在Zigbee结构中网络层与建立网络息息相关 3.介质访问控制层(MAC)帧被称为MAC协议数据单元(MPDU)，其长度不超过127个字节。它具有四种不同的帧形式，即 信标帧、数据帧、确认帧、命令帧。 4.数据帧的基本结构由三部分构成：同步头、需要传输的数据、帧尾 5.不属于Zigbee拓扑结构的是总线网络。 星形拓扑;树形拓扑;Mesh拓扑（网状拓扑） 6.在Zigbee协议架构中哪一组是属于IEEE802.15.4标准定义的物理层和MAC层。 7.Zigbee的应用层的组成： 应用支持子层（APS） Zigbee设备对象 （ZDO） Zigbee应用框架（AF） Zigbee设备模板制造商定义的应用对象 8.MAC层提供MAC层数据服务和 MAC层管理服务 ，并负责数据成帧。 9.ZDO层提供了Zigbee设备管理功能包括： 网络建立 发现网络 加入网络 应用端点的绑定 安全管理等服务 10.在应用程序框架（AF, Application Framework）内部，ZigBee 设备对象通过APSDE-SAP来收发数据。总共定义了240个不同的应用对象（Application Object），通过端点来描述，端点接口索引号为1~240。此外还有两个特殊端点： 端点0：只为ZDO的数据接口服务 端点255：供应用对象的广播数据接口功能 11.ZigBee：自愈功能：增加或者删除一个节点，节点位置发生变动，节点发生故障等等，网络都能够自我修复，并对网络拓扑结构进行相应的调整，无需人工干预，保证整个系统仍然能正常工作。 函数1.信息管理API函数： osal_msg_allocate() osal_msg_deallocate() osal_msg_send() osal_msg_receive()。 2.如果将CC2530的P1端口设置为外设I/O功能，需要设置P1SEL寄存器。 &lt;1&gt; PxSEL：端口功能选择，设置端口是通用I/O还是外设功能。 &lt;2&gt; PxDIR：作为通用I/O时，用来设置数据的传输方向。输入或者输出。 &lt;3&gt; PxINP：作为通用输入端口时，选择输入模式是上拉、下拉还是三态。 简答题1.列举常用的Zigbee芯片和Zigbee协议栈。 常见的Zigbee芯片为CC243X系列、CC253X系列和MC1322X系列。 Zigbee的协议栈分为3种： 非开源的协议栈：freescale解决方案和microchip解决方案 半开源的协议栈：TI公司开发的ZStack协议栈是一个半开源的Zigbee协议栈 开源的协议栈：Freakz是一个彻底开源的Zigbee协议栈。 2.简述Zstack协议栈中的两种地址类型。 64位IEEE地址：即MAC地址（也称“长地址”或“扩展地址”），是一个全球唯一的地址，一经分配将跟随设备一生。通常由制造商在设备出厂或被安装时设置。这些地址由IEEE组织来维护和分配。 16位网络地址：是设备加入网络后，由网络中的协调器分配给设备的地址（也称“短地址”），它在网络中是唯一的，用来在网络中鉴别设备和发送数据。对于协调器，网络地址固定为0x0000。 3.简述CC2530数据帧的产生过程 ⑴CC2530射频部分产生并自动传输物理层的同步头，包括帧引导序列和帧开始界定符（SFD）。 ⑵通过射频部分传输帧长度域和指定的字节数，包括MAC帧头和MAC负载 。 ⑶通过操作寄存器计算并自动传输帧尾（FSC）。 4.简述Zigbee网络层功能。 Zigbee网络中的设备有三种类型：协调器、路由器和终端节点，分别实现不同的功能。协调器具有建立新网络的能力。协调器和路由器具备允许设备加入网络或者离开网络、为设备分配网络内部的逻辑地址、建立和维护邻居表等功能。Zigbee终端节点只需要有加入或离开网络的能力即可。 5.简述终端节点的作用。 主要作用可以总结为以下两个方面： 数据的发送和接收：当一个设备发送数据时，必须指定发送目的节点的长地址或短地址以及端点来进行数据的发送和接收，并且发送方和接收方所使用的端点号必须一致。 绑定：如果设备之间需要绑定，那么在Zigbee的网络层必须注册一个或者多个端点来进行数据的发送和接收以及绑定表的建立。 6.简述协议栈的启动流程。 由协调器的组网（创建PAN ID），终端设备和路由设备发现网络以及加入网络。 基本流程：main()-&gt;osal_init_system()-&gt;osalInitTasks()-&gt;ZDApp_Init()，进协议栈初始化函数ZDApp_Init()-&gt;ZDOInitDevice()。 首先在ZMain.c的main函数中进入osal_init_system()函数，该函数通过创建任务表中定义的任务来初始化“任务”系统。这里面关键函数是osalInitTasks()，这个函数在任务初始化为每一层分配一个任务ID号，这个ID和事件处理函数对应成映射。ZDApp_Init()函数里初始化ZigBee协议栈网络，然后进入ZDOInitDevice()初始化设备。 另一种说法： Zmain.c —&gt; main () —&gt; osal_init_system(); // 任务调度初始化 osalInitTasks() —&gt;默认启动了最多9个任务，添加到队列 ，序号 : 0~8 最后通过调用GenericApp_Init（） 实现用户自定义任务的初始化（用户根据项目需要修改该函数）osal_start_system(); —&gt; 进入任务轮询处理 7.简述Zigbee的osal的工作原理。 taskArr数组里存放了所有任务的事件处理函数的地址， tasksCnt变量保存了当前的任务个数。tasksEvents是一个指向数组的指针，此数组保存了当前任务的状态。tasksArr[ ]中的第i个事件处理函数对应于tasksEvents中的第i个任务的事件。 在osal_init_system()这个函数中，osalInitTasks()被调用，所有任务的状态都被初始化为0。在main()函数中，进入osal_start_system()函数，此函数为一个死循环，在这个循环中，完成所有的事件分配。 当tasksEvents这个数组中的某个元素不为0，即代表此任务有事件需要响应。然后events = (tasksArr[idx])( idx, events ) 语句调用tasksArr数组里面相应的事件处理函数来响应事件。以上，OSAL就将需要响应的事件传递给了对应的任务处理函数进行处理。 8.凡符合什么条件的短距离通信就可以考虑采用ZigBee技术？ (1)需要数据采集或监控的网点多; (2)要求传输的数据量不大，而要求设备成本低; (3)要求数据传输可靠性高，安全性高; (4)要求设备体积很小，不便放置较大的充电电池或者电源模块; (5)可以用电池供电; (6)地形复杂，监测点多，需要较大的网络覆盖; (7)对于那些现有的移动网络的盲区进行覆盖; (8)已经使用了现存移动网络进行低数据量传输的遥测遥控系统。 程序设计1.编写点亮LED1以及设置LED1每隔500ms闪烁4次的函数。 点亮：HalLedSet(HAL_LED_1,HAL_LED_MODE_ON); 闪烁：HalLedBlink (HAL_LED_1,4,50,500); 近期更新，敬请期待","categories":[{"name":"复习","slug":"复习","permalink":"https://Stefancharles.xyz/categories/复习/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"【RFID】期末复习知识提纲","slug":"RFIDreview","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-22T13:44:47.293Z","comments":true,"path":"2019/12/16/RFIDreview/","link":"","permalink":"https://Stefancharles.xyz/2019/12/16/RFIDreview/","excerpt":"RFID复习提纲本篇文章按RFID考试题库里的章节进行知识点进行梳理。考试当天将会暂时关闭本博客。请理解。 We fight, because we knew we had nothing to lose.","text":"RFID复习提纲本篇文章按RFID考试题库里的章节进行知识点进行梳理。考试当天将会暂时关闭本博客。请理解。 We fight, because we knew we had nothing to lose. 第一章 传输线理论1.阻抗、导纳的含义 阻抗：对电路中的电流所起的阻碍作用叫做阻抗。 导纳：描述交流电通过电路或系统时的困难程度。 第二章 谐振电路 1.串联正弦交流电路发生谐振的条件是 UL = UC，即XL = XC，谐振时的谐振频率品质因数 Q=XL/R ，串联谐振又称为电压谐振。 2.在发生串联谐振时，电路中的感抗与容抗相等，此时电路中的阻抗最小，电流最 大，总阻抗Z= R。 3.谐振发生时，电路中的角频率w0 = 1/√LC ，f0=1/2π*√LC。 第三章 天线基础1.半波振子天线的长度为 λ/4。 2.在弯折线偶极子天线中，当天线弯折次数n增多、弯折高度h增加或者弯折角а增大后，天线的谐振频率降低。 3.已知天线的辐射功率为P∑=30W，且损耗功率为PL=5W。则天线输入功率：30+5=35w;效率:30÷35≈0.857。 4.用天线的辐射电阻P∑来度量天线辐射功率的能力，即辐射电阻越 大 天线的辐射能力越强。 5.天线辐射最强的方向所在波瓣称为 主瓣，其宽度是衡量天线最大辐射区域 尖锐程度 的物理量。 6.波瓣宽度越宽，方向性越 差 作用距离越 近 抗干扰能力越 弱 但是天线的覆盖范围越 大。 7.天线的种类很多，可以按照多种方式进行分类，其中按照波段可将天线分为 长波天线 中波天线 短波天线 超短波天线 微波天线 8.简述RFID系统中，读写器与标签之间是怎样进行无线通信的。 读写器产生高频振荡能量，经过传输线传输到发射天线，然后以电磁波形式向预定方向辐射。接收天线将接收到的电磁波能量通过馈线送到标签。 9.微带天线的特点 1.体积小、剖面低、重量轻、易于与载体共形； 2.成本低、易于批量生产，可方便地与馈电网络、器件和微带电路集成； 3.散射截面小、波瓣宽；易于实现线极化、圆极化、双极化和双频段工作； 5.效率低、功率容量低、高Q值、频带窄 第四章 RFID系统概论1.在QR code中，L级的纠错能力可以纠错7%数据码字。 2.物流二维码不是二维码类别。 3.自动识别技术的分类： 光符号识别技术 语音识别技术 生物计量识别技术 IC卡技术 条形码技术 射频识别（RFID）技术 4.ISBN条形码组成部分。 国际标准书号，简称ISBN，ISBN码由13位数字组成。中国内的ISBN组成结构：978 + 组号 + 出版社号 + 书名号 + 校验号 5.条形码和二维码组成结构上有什么不同？条形码相较于二维码的优缺点是什么？ 条形码是将宽度不等的多个黑条和空白，按一定的编码规则排列，以表达一组信息的图形标识符。 二维码是用某种特定的几何图形按一定规律在平面分布的黑白相间的图形。 条形码的优点：技术成熟、使用广泛、设备成本低廉 条形码的缺点：信息量少、只支持英文或数字、需与电脑数据库结合 6.二维码的主要用途，二维码可以包含哪些类型的数据？ 二维码现在广泛用于物流货品追踪，商业推广，电子身份识别防伪等服务。 二维码可以包含字母，数字，字符，中文，图片 声音等数据。 7.比较条形码与二维条形码 二维码与条形码的关系：二维码是条形码的一个分支 条形码特点： 1、可直接显示内容为英文、数字、简单符号 2、贮存数据不多，主要依靠计算机中的关联数据库 3、保密性不高 4、损污后可读性差 5、对读取设备要求较低 二维条形码特点： 1、可直接显示英文、中文、数字、符号、图型 2、贮存数据量大，可存放1K字符，可用扫描仪直接读取内容，无需另接数据库 3、保密性高 4、容错率高 5、对读取设备要求较高 8.简述RFID技术的的优点 1.体积小且形状多样：RFID标签在读取上并不受尺寸大小与形状限制。 2.耐环境性：RFID对水、油等物质却有极强的抗污性。在黑暗的环境中，RFID标签也能被读取。 3.可重复使用：标签具有读写功能，电子数据可反复覆盖，可以被回收而重复用。 4.穿透性强：标签在被纸张、木材和塑料等非金属或非透明的材质包裹的情况下也可以进行穿透性通讯。 5.数据安全性：标签内的数据通过循环冗余校验的方法来保证标签发送的数据准确性。 9.简述低频标签的优缺点 优点： 标签芯片一般采用普通的CMOS工艺，具有省电、廉价的特点； 工作频率不受无线电频率管制约束； 可以穿透水、有机组织、木材等； 非常适合近距离的、低速度的、数据量要求较少的识别应用等。 缺点： 标签存贮数据量较少； 只能适合低速、近距离识别应用； 与高频标签相比，标签天线匝数更多，成本更高。 第六章 RFID读写器1.低频RFID通信协议是ISO18000-2，高频RFID通信协议是ISO18000-3。 2.读写器由 天线，射频模块，逻辑控制模块 构成。 3.读写器的主要作用： 通过天线与RFID标签进行无线通信 可以实现对标签的内存数据的读写 4.未来的读写器的发展方向： 多功能 小型化 便携式 嵌入式 模块化 5.读写器主要功能： 与电子标签通信 标签供能 多标签识别 移动目标识别 6.高频读写器的工作频段是：13.56Mhz。高频读写器具有 防冲撞特性 ，可以读取多个电子标签。 7.高频读写器按照遵从的协议基本可以分为两类读写器：ISO/IEC14443读写器 和 ISO/IEC15693协议读写器。 8.ISO/IEC 14443 近耦合IC卡，最大的读取距离为10 cm。ISO/IEC 15693疏耦合IC卡，最大的读取距离为1 m。 9.高频读写器的应用： 一卡通 门禁 二代身份证 生产自动化 10.简述读写器中天线的功能 读写器的天线是发射和接收射频载波信号的设备，负责电流信号和射频载波信号的互换。 11.简述读写器与电子标签和计算机之间的交互过程 读写器通过天线发送一定频率的射频信号，当电子标签进入设定工作距离时，向读写器发送自身编码等信息，读写器将数据信息送到计算机进行处理，计算机向控制器发送控制指令。 12.射频接口模块中“时钟发生器”起什么作用？ 产生稳定间隔且持续不断的电压脉冲作为工作时钟，使模块中各部件随着时钟信号来同步运行。 13.简述基于低频RFID的汽车防盗系统的工作原理 硬件选择电子标签、读写电路、单片机、语音报警电路、电源监控电路、存储接口电路和汽车发动机电子点火系统。 汽车防盗系统由电子标签和读写器组成。原理是将汽车的机械钥匙与电子标签结合，即将小型电子标签直接装入到钥匙把手内，当一个具有正确识别码的钥匙插入点火开关后，汽车才能启动。 第七章 编码与调制1.CRC冗余校验 现假设选择的CRC生成多项式为G（X）= X4 + X3 + 1，要求出二进制序列10110011的CRC校验码。 （1）首先把生成多项式转换成二进制数，由G（X）= X4 + X3 + 1可以知道它一共是5位（总位数等于最高位的幂次加1，即4+1=5），二进制比特串为11001。 （2）因为生成多项式的位数为5，校验码的位数比生成多项式的位数少1。所以CRC校验码的位数为4。因为原数据帧10110011，在它后面再加4个0，得到101100110000，然后把这个数以“模2除法”方式除以生成多项式，得到的余数（即CRC码）为0100。 模2除法:相当于二进制中的逻辑异或运算 （3）把上步计算得到的CRC校验0100替换原始帧101100110000后面的四个“0”，得到新帧101100110100。再把这个新帧发送到接收端。 （4）当以上新帧到达接收端后，接收端会把这个新帧再用上面选定的除数11001以“模2除法”方式去除，验证余数是否为0，如果为0，则证明该帧数据在传输过程中没有出现差错，否则出现了差错。 2.抗干扰性能最好的调制方法是相移键控。 3.大部分射频识别系统的耦合方式是电感耦合。 4.电感耦合可以分为密耦合系统和遥耦合系统。 5.低成本射频识别系统的主流是遥耦合系统。 6.电磁反向散射这种通信方式利用的是电磁场。 7.RFID系统的耦合方式可以分为 电感耦合 和 电磁反向散射耦合 。电感耦合系统中，电阻负载调制通过对 读写器电压 调控，最终完成信息的传输。 8.电感耦合的原理是 电磁感应原理 ，电磁反射应用的是 电磁波的空间传播 规律。 9.功率放大器的功率增益指的是输出功率与输入功率之比，单位是分贝。 10.组成低通滤波器的电子元件包括：电容，电感，电阻。 11.目前国际上广泛采用的频率分布于4种波段:低频、高频、超高频 和 微波。它们的典型工作频率分别是125KHz、13.54MHz、850MHz～910MHz和2.45GHz。 12.动物识别是低频标签的典型应用，中频标签的典型应用有电子车票、电子闭锁防盗、小区物业管理 。 13.RFID在低频段（100MHz以下）工作是基于电感耦合，在高频段（400MHz以上）工作是基于电磁反向散射耦合。 14.通信系统中为什么要进行调制和解调？调制的分类方法有哪些？ 原因：调制器用于改变高频载波信号，使得载波信号的振幅、频率或相位与要发送的基带信号相关。解调器的作用则是解调获取到的信号，以重现基带信号。 15.指出下图描述分别是哪种调制方式，简述这三种调制方式的特点。 分别为ASK，FSK和PSK。 ASK: 即按载波的幅度受到数字数据的调制而取不同的值，例如对应二进制0，载波振幅为0；对应二进制1，载波振幅为1。调幅技术实现起来简单，但容易受增益变化的影响，是一种低效的调制技术。 FSK: 即按数字数据的值（0或1）调制载波的频率。例如对应二进制0的载波频率为F1，而对应二进制1的载波频率为F2。该技术抗干扰性能好，但占用带宽较大。在电话线路上，使用FSK可以实现全双工操作，通常可达到1200bps的速率。 PSK: 即按数字数据的值调制载波相位。例如用180相移表示1，用0相移表示0。这种调制技术抗干扰性能最好，且相位的变化也可以作为定时信息来同步发送机和接收机的时钟，并对传输速率起到加倍的作用。 16.什么是副载波调制，副载波调制在RFID系统中起什么作用 副载波调制是指首先把信号调制在载波1上，出于某种原因，决定对这个结果再进行一次调制，于是用这个结果去调制另外一个频率更高的载波2。副载波调制在RFID中起到通信，供电的作用。 17.为何反向不归零编码不用于实际传输？ 存在直流分量，信道一般难以传输零频附近的频率分量。 接收端判决门限与信号功率有关，使用不方便。 不能直接用来提取位同步信号，因为NRZ中不含有位同步信号频率成分。 要求传输线中有一根接地。 18.曼彻斯特码如何检测数据传输中的错误？ 当多个电子标签同时发送数据位有不同时，接收的上升边和下降边互相抵消，导致在整个位长度副载波信号是不跳变，可判断为发生碰撞。 19.给定数据为00110010，求画出修正密勒编码后的波形图。 规则：在“1”的中间时刻跳变，在连续的第二个“0”的开始时刻跳变。 20.信源编码的作用是什么？ 减少码元数目和速率，进行数据压缩 将模拟信号转数字信号 21.差分曼彻斯特码的编码规则与引进原因 编码规则：在信号位开始时不改变信号极性表示“1”。改变则表示“0” 引进原因：编码变化少，适合传输高速信息。 22.RFID电磁反向散射耦合 读写器天线辐射出的电磁波到达射频天线表面后形成反射回波，反射回波再被读写器天线所接收，从而达到传达信息的目的。 23.简述电感耦合系统下读写器向电子标签提供能量的过程 读写器线圈上的交变电流、产生交变磁场，当电子标签进入读写器产生的交变磁场时，电子标签的电感线圈上就会产生交变电流，从而获得读写器提供的能量。 24.简述电感耦合方式和电磁反向散射耦合方式的数据传输过程 电感耦合方式：读写器的电容与天线线圈并联，一起构成并联震荡回路，该回路的谐振使读写器天线线圈产生非常大的电流，谐振频率与读写器发射频率一致，最终调制后的读写器线圈电压与电子标签二进制数据波形相同 电磁反向散射耦合方式：功率P1从读写器天线发射出来，只有一部分P1到达标签天线并为其提供电压，整流后为标签芯片供电。到达功率P1的一部分被天线反射，其反射功率为P2，经自由空间后再到达读写器，被读写器天线接收。读写器接收的信号经收发耦合器电路传输至收发器，放大后经电路处理器获得有用信息。 25.RFID电磁反向散射方式的射频前端由哪些模块组成？ 数/模变换器，模/数变换器，混频器，放大器，滤波器，本地振荡器，双工器，天线 第八章 防碰撞技术1.纯Aloha算法的碰撞周期为2T。 2.在RFID中，采用曼彻斯特码、Miller码和修正Miller码作为传输码型的目的是：便于同步和检错。 3.在射频识别系统中，最常用的防碰撞算法是时分多址法TDMA。 4.在基本二进制算法中，为了从N个标签中找出唯一一个标签，需要进行多次请求，其平均次数L为log2N+1。 5.在RFID系统防碰撞算法中 二进制树搜素算法是由读写器控制驱动。 6.在RFID系统中，为保持数据的完整性和安全性，必须采用差错控制和防碰撞算法。 7.RFID系统中有两种类型的通信碰撞存在，一种是阅读器碰撞，另一种是电子标签碰撞。 8.常用在多路通信方式有：空分多路法、时分多路法、频分多路法。在RFID系统中，主要采用时分多路法。 9.TDMA算法又可以分为基于概率的ALOHA算法和确定的二进制算法两种。上述两种TDMA算法中，会出现“饿死”现象的算法是基于概率的ALOHA算法。 10.帧时隙Aloha算法是在时隙Aloha算法的基础上，把N个时隙组成一帧，每个时隙的长度够一个标签回答完，标签在每N个时隙中，可以随机发送 1 次信息。 11.为了实现二进制搜索算法，就要选用 曼彻斯特编码 ，因为这种编码可以检测出碰撞位。 12.为了实现二进制树型搜索算法，引入以下4种命令： REQUEST——请求 SELECT——选择 READ-DATA——读出数据 UNSELECT——退出选择 13.为了防止碰撞的发生，射频识别系统中需要设计相应的防碰撞技术，在通信中这种技术也称为多址技术。不是差错控制技术。 14.简述碰撞的种类 阅读器碰撞：多个阅读器同时与一个标签通信。 电子标签碰撞：多个标签同时响应阅读器的命令发送信息。 15.简述碰撞的解决方案 1）空分多址（SDMA） 2）频分多址（FDMA） 3）码分多址（CDMA） 4）时分多址（TDMA） 16.简述ALOHA算法的工作过程、实现步骤。 若读写器检测出信号存在相互干扰，读写器就会以向电子标签发出命令，令其停止向读写器传输信号；电子标签在接收到命令信号之后，就会停止发送信息，并会在接下来的一个随机时间段内进入到待命状态，只有当该时间段过去后，才会重新向读写器发送信息。各个电标签待命时间片段长度是随机的，再次向读写器发送信号的时间也不相同，这样减少碰撞的可能性。 当读写器成功识别某一个标签后，就会立即对该标签下达命令使之进入到休眠的状态。而其他标签则会一直对读写器所发出命令进行响应，并重复发送信息给读写器，当标签被识别后，就会一一进入到休眠状态，直到读写器识别出所有在其工作区内的标签后，算法过程才结束。 17.时隙Aloha算法优点是可以将冲突减少一半，将信道负载增加，冲突和性能有何变化？ 冲突会呈指数增加，信道性能降低。 假设阅读器射频工作范围内存在N个标签，理论上阅读器需要至少N个时隙才能成功识别完，如果在识别过程中，又有标签到达，那么系统吞吐量会直线下降，最坏的情况下，即使多次搜索也未能识别导致“饿死现象”。 18.二进制树型搜索算法的基本思想是什么？ 不断的将导致碰撞的电子标签进行划分，缩小下一步搜索的标签数量，直到只有一个电子标签进行回应。 19.二进制数型搜索算法为什么选用曼切斯特编码 ? 如果两个电子标签同时发送的数位有不同的值，则接收的上升沿和下降沿互相抵消。用这种方法可以按位追溯跟踪冲突的出现，可以检测出碰撞位。 第九章 RFID的安全问题1.处理RFID问题更具有挑战性的原因？ 数据容易被偷听 计算能力和可编程能力都被标签本身的成本所约束 2.RFID面临的攻击有哪些？ 1.侵入电子标签数据 2.侵入电子标签和读写器之间的通信 3.侵入读写器内数据 4.侵入主机系统 3.RFID系统安全解决方案 物理方法：杀死标签，法拉第网罩，主动干扰，阻止标签 逻辑方法：Hash锁，随机Hash锁，Hash链，匿名ID方案，重加密方案 4.简述hash锁方案原理 标签使用metaID，标签内部有一个用于存储临时metaID的内存。 在锁定状态下，标签用metaID响应查询； 在非锁定状态下，标签向读写器提供自己的信息。 第十章 物联网架构RFID标准1.RFID标准体系主要包括技术标准，数据内容标准，性能标准，应用标准。 2.动物的无线射频识别高级标签第一部分的空中接口属于应用标准。 3.第二代身份证是符合ISO/IEC 14443 TYPE B协议的射频卡。 4.GB/T20563 2006在RFID标准体系中属于应用标准。 5.ISO/IEC 18000标准系列中包含了 6 个部分，18000-7定义的超高频频段. 6.ISO/IEC 15693标准中标签到读写器的数据编码采用 曼彻斯特编码 方式。 7.ISO/IEC 15693标准中标签有四种状态，分别是 断电、准备、静默、选择 。 8.ISO/IEC 15693标准中工作频率范围为 13.56MHz±7KHz ，工作磁场范围为 0.15A/m~5A/m 。 9.编码标准 和 通信协议（通信接口）是RFID标准中争夺比较激烈的部分，两者也构成了RFID标准的核心。这两者分别属于 数据内容标准和技术标准。 10.物联网标准是 EPCglobal 所特有的。 11.ISO/IEC、EPCglobal和UID这三个标准组织制定的标准相互之间并不兼容，主要差别在 通讯方式 、 防冲突协议 和 数据格式 三个方面。 12.在ISO/IEC 14443标准协议中，规定载波频率为 13.56MHz 。 13.ISO/IEC 14443标准由 物理特性 、 射频能量和信号接口 、初始化和防碰撞 、 传输协议 四个部分组成。 14.ISO/IEC 18000-2标准的标签分为两个类型Type-A和Type-B,它们在 物理层 存在不同，但是支持相同的 协议和防碰撞机制，Type-A标签工作在 双工通信 模式下，Type-B标签工作在 半双工通信 模式下。 15.ISO/IEC 18000-6标准的Type-A采用 ALOHA 防碰撞算法，Type-B采用 二叉树 防碰撞算法，均采用 双相间隔码编码。 16.ISO/IEC 18000-4标准定义了 2.4GHz的空中接口通信协议参数，主要应用于 货品管理领域。ISO/IEC 18000-4标准定义了 433MHz的空中接口通信协议参数，应用于 单品应用管理方面 。 17.GB/T20563 2006标准是 动物射频识别代码结构 标准的简称，其规定了代码结构分为三部分：控制代码段（第1至16位），国家和地区代码段和国家动物代码段。 18.RFID技术广泛应用的前提是什么？有什么意义？ RFID技术广泛应用的前提是标准化。可以解决编码通信、空中接口和数据共享等问题，促进RFID技术发展。 19.ISO/IEC 15693标准中数据元素里的UID, AFI, DSFID分别指的是什么？ UID(Unique Identifier)唯一标识符。 AFI(Application Family Identifier)应用族标识符。 DSFID(Data Storage Format Identifier)数据存储格式标识符。 20.简述ISO/IEC 14443标准的类型中不同标准所采用的防碰撞算法 A型采用位检测防碰撞协议 B型通过一组命令来管理防碰撞过程，防碰撞方案以时隙为基础。 21.简述ISO/IEC 18000-6系列方案的特点。 Type-A方案存储容量大，防碰撞能力较弱，且数据结构复杂，指令类型多。 Type-B方案存储容量小，防碰撞能力较强，数据结构和指令简单。 Type-C方案的性能处于Type-A和Type-B二者之间，具有较高的普适性。 22.EPCglobal标准框架分为哪三个层次，并阐述其内容 EPCglobal标准框架包括数据识别、数据获取和数据交换三个层次。 数据识别层的标准包括RFID标签数据标准和协议标准，目的是确保不同企业间数据格式和说明的统一性； 数据获取层的标准包括读写器协议标准、读写器管理标准、读写器组网和初始化标准，以及中间件标准等，定义了收集和记录EPC数据的主要基础设施组件，并允许最终用户使用具有互操作性的设备建立RFID应用； 数据交换层的标准包括EPC信息服务标准（EPC Information Services，EPCIS）、核心业务词汇标准（Core Business Vocabulary，CBV）、对象名解析服务标准（Object Name Service，ONS）、发现服务标准（Discovery Services）、安全认证标准（Certificate Profile），以及谱系标准（Pedigree）等，提高广域环境下物流信息的可视性，目的是为最终用户提供可以共享的EPC数据，并实现EPC网络服务的接入。 23.从技术方面简要分析RFID标准多元化的原因。 1.RFID的工作频率和信息传输方式：RFID的工作频率分布在低频至微波的各个频段中，技术差异大。 2,作用距离：作用距离不同产生的差异主要表现在以下几个方面：应答器的工作方式分为有源工作方式和无源工作方式两种；RFID系统的工作原理不同，近距离采用电感耦合方式，远距离采用基于微波的反散射耦合方式；载波功率的差异；这些都会导致不同的标准产生； 3，应用目标的不同：RFID的应用广泛，针对不同的应用目的，其存储的数据代码，外形需求，频率选择，作用距离以及复杂度都会有很大的差异； 4，技术的发展：随着信息技术和制造业的进步，RFID标准需要不断融入这些新进展，以形成与时俱进的标准。 第十一章 物联网架构—EPC系统1.64位EPC编码中EPC-64Ⅲ型编码的厂商数量最多。 2.若EPC编码版本号前三位是000，则这个EPC编码可能是EPC-256Ⅱ型。 3.Savant系统完成的任务是： 数据校对、 数据传输 、 数据存储 、读写器协调、 任务管理。 4.ONS服务器由ONS根服务器和本地ONS服务器组成。 5.某商品信息为“一个蓝色的500ml的水杯”，其中“蓝色，500ml”是由EPC编码结构当中的 对象分类代码 决定的。 6.国际上具影响力三大RFID标准化体系组织是 EPC Global美，UID日本，ISO/IEC标准体系 。 7.96位EPC码由版本号、域名管理者、对象分类代码 和序列号构成。 8.电子标签含有物品唯一标识体系的编码，其中电子产品代码/EPC是全球产品代码的一个分支，它包含著一系列的数据和信息，如产地、日期代码和其他关键的供应信息。 9.EPC系统的信息网络系统是在全球互联网的基础上，通过 Savant管理软件系统 、 ONS对象名称解析服务 、 实体标记语言 实现全球的实物互联。 10.EPCIS在EPC网络中的主要作用是提供 存储管理EPC捕获信息 的接口。 11.ONS服务是联系EPC中间件和EPC信息服务的网络枢纽，并且ONS设计与架构都以 因特网域名解析服务（DNS）为基础，因此，可以使整个EPC网络以因特网为依托，迅速架构并顺利延伸到世界各地。 12.EPC信息服务（EPCIS）中框架分为几层，每层的作用是什么？ EPCIS框架被分成三层：信息模型层，服务层，绑定层。 信息模型层：指定了EPCIS中包含什么样的数据，这些数据的抽象结构是什么，以及这些数据代表着什么含义。 服务层：指定了EPC网络组件与EPCIS数据进行交互的实际接口。 绑定层：定义信息的传输协议，比如SOAP(简单对象访问协议)或HTTP(超文本传输协议) 13.简述对象名称解析服务的工作流程。 用户请求发到ONS根服务器上。ONS根服务器进行解析和识别，将请求转发至该本地ONS服务器。本地ONS服务器在本地数据表中解析EPCIS服务器的地址，然后将请求转发至该EPCIS服务器。最后EPCIS服务器根据请求的内容提供搜索结果，将结果返回。 第十二章 RFID应用实例1.属于RFID应用： A.物流过程中的货物追踪，信息采集 B.驯养动物，畜牧牲口，宠物等识别管理 D.ETC路桥不停车收费系统 2.在铁路机车车号识别系统中，安装在铁轨中间的是读写器天线。 3.RFID在智能交通领域的应用有 不停车电子收费系统 、智能公交系统、铁路机车车号识别系统。 4.RFID智能公交系统由 信息采集网络 （识别基站、识别卡 、显示屏）以及指挥中心组成。 近期更新，敬请期待","categories":[{"name":"复习","slug":"复习","permalink":"https://Stefancharles.xyz/categories/复习/"}],"tags":[{"name":"RFID","slug":"RFID","permalink":"https://Stefancharles.xyz/tags/RFID/"}]},{"title":"【WSN】无线传感器网络期末复习知识提纲","slug":"WSNreview","date":"2019-12-11T16:00:00.000Z","updated":"2019-12-17T03:37:24.512Z","comments":true,"path":"2019/12/12/WSNreview/","link":"","permalink":"https://Stefancharles.xyz/2019/12/12/WSNreview/","excerpt":"无线传感器复习提纲本篇文章按无线传感器网络书籍里的章节进行知识点进行梳理。","text":"无线传感器复习提纲本篇文章按无线传感器网络书籍里的章节进行知识点进行梳理。 第一章：绪论WSN定义无线传感网络是由大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络。 WSN系统组成 1.传感器节点； 2.汇聚节点； 3.管理节点 WSN的三个基本要素 1.传感器； 2.感知对象； 3.用户 WSN特点 1.自组织性； 2.以数据为中心； 3.应用相关性； 4.动态性； 5.网络规模大； 6.可靠性； 7.集成化； 8.协作方式执行任务 第三章：WSN拓扑控制与覆盖技术WSN拓扑结构类型 1.平面网络结构：平面网络结构所有节点为对等结构，具有完全一致的功能特性，也就是说每个节点均包含相同的MAC、路由、管理和安全等协议。 2.分级网络结构（层次网络结构）：网络分为上层和下层两个部分：上层为中心骨干节点互连形成的子网拓扑，下层为一般传感器节点互连形成的子网拓扑。 3.混合网络结构：网络骨干节点之间及一般传感器节点之间都采用平面网络结构，而网络骨干节点和一般传感器节点之间采用分级网络结构。 4.Mesh网络结构：Mesh网络结构是一种新型的无线传感网络结构。从结构上看，Mesh网络是规则分布的网络，网络内部节点一般都是相同的。Mesh网络结构最大的优点就是尽量使所有节点都是处于对等的地位，且具有相同的计算和通信传输功能，某个节点可被指定为簇首节点，而且可执行额外的功能。一旦簇首节点失效，另外一个节点可以立刻补充并接管原簇首那些额外执行的功能。 WSN拓扑控制定义及设计目标1.拓扑控制定义：无线传感器网络的拓扑控制问题，是在网络相关资源普遍受限的情况下，对于固定或具有移动特征的无线传感器网络通过控制传感器节点与无线通信链路组成网络的拓扑属性来减少网络能量消耗与无线干扰，并有效改善整体网络的连通性、吞吐量与传播延时等性能指标。 总结：在全网协作式地进行各个传感器节点功率控制，从而减小网络能量消耗和无线干扰。 拓扑控制（topology control）是一种协调节点间各自传输范围的技术，用以构建具有某些期望的全局特性（如，连通性）的网络拓扑结构，同时减少节点的能耗或增加网络的传输能力。 2.拓扑控制设计目标：覆盖性、连通性、网络生命期、吞吐能力、干扰和竞争、网络延迟、拓扑性质。 连通性与覆盖性是无线传感很关键的参数。 1.连通度：无线传感网络一般规模较大，传感器节点所获取的数据通常以多跳的方式传送至汇聚节点，这就要求拓扑控制必须保证网络的连通性。如果至少要去掉k个节点才能使网络不连通，就称其为k-连通。拓扑控制要保证网络至少是1-连通的。 2.覆盖度：覆盖度可以看作是对无线传感网络服务质量的度量。在覆盖问题中，最重要的因素是网络对物理世界的感知能力。生成的拓扑必须保证足够大的覆盖度，即覆盖面积足够大的监视区域。覆盖度问题可以分为区域覆盖、点覆盖和栅栏覆盖。如果目标区域中任意一个点均在k个传感器节点的传输范围内，就称网络是k-覆盖网络。 3.吞吐量：吞吐量是指网络承载数据传输的能力，尤其是在有大量数据出现时，吞吐量是影响网络通信能力的因素之一。 4.网络生命周期：网络生命周期的定义有多种，一般将网络生命周期定义为直到死亡节点的百分比低于某个阈值的持续时间，也可以通过对网络服务质量的度量来定义网络的生命期。 5.干扰和竞争：减小干扰和竞争，实际上就是延长网络生命周期。 6.网络延迟：网络负载较低时，减小了跳数，降低了延迟。 7.拓扑性质：除了覆盖性，连通性，还有对称性，平面性等。 WSN拓扑控制主要实现方式功率调节及睡眠调度机制 1.在保证网络的连通性与覆盖性的情况下，控制节点的发射距离，减少发射功耗，同时减少分组冲突的可能性，减少协议不必要的开销； 2.尽可能让多的节点进行休眠，降低功耗； 3.数据融合，减少分组的冗余。 WSN功率控制经典实现算法基于节点度的功率控制LMA：本地平均算法（Local Mean Algorithm）LMN：本地邻居平均算法（Local Mean of Neighbors Algorithm）这是两种周期性调整节点发射功率的算法。 基于方向的功率控制CBTC 基于邻近图的功率控制RNG相关邻近图（Relative Neighborhood Graph）MST最小生成树（Minimum Spanning Tree） LEACH实现机制LEACH（Low Energy Adaptive Clustering Hierarchy）是一种自适应分簇拓扑算法，它的执行是周期性的，每轮循环分为簇的建立阶段和稳定的数据通信阶段。 簇的建立阶段：相邻节点动态地形成簇，随机产生簇头 数据通信阶段：簇内节点把数据发给簇头，簇头进行数据融合并把结果发给汇聚节点。 簇头耗能大，所以需要等概率选取簇头。使整个网络的能量负载达到均衡。 LEACH拓扑图： 过程：节点产生0~1的数，如果这个数小于阈值Tn，则发布自己是簇头的消息；在每轮循环中，如果节点已经当选过簇头，则把Tn置0，这样该节点不可能再当选簇头。 p：期望的簇头在所有节点中所占的百分比r mod (1/p)：这一轮循环中当选过簇头节点的个数Gr：这一轮循环中未当选过簇头的节点集合 对于没有当选过簇头的节点，其当选簇头的概率是Tn，并随着当选过节点的数目的增加，Tn随之增大。 LEACH协议缺点：1、簇头选举随机性很强，可能会出现簇头集中在某一个区域的现象，造成簇头分布不均匀。2、信息的融合和传输都是通过簇头节点来进行，造成了簇头节点能量消耗过快的问题；3、发射机和接收机必须严格遵守时隙的要求，避免在时间上互相重叠，然而，维持时间同步又增加了一些额外的信令通信量。节点的时间表可能会需要较大的存储器。4、LEACH要求节点之间和节点与Sink点之间都能进行直接通信，网络的扩展性差，对于大规模网络而言，节点直接进行通信需要消耗大量的能量。并且采用单跳路由方式，增加了交换数据的能量。 HEED分簇：簇头选择中考虑了节点的剩余能量, 并以主从关系引入多个约束条件。实验结果表明, HeeD分簇速度更快, 能产生更加分布均匀的簇头、更合理的网络拓扑。 覆盖感知模型 布尔感知模型节点的感知范围是一个以节点为圆心，以感知距离为半径的圆形区域。 概率感知模型节点的圆形感知范围内，目标被感知的到的概率不是一个常量。 覆盖算法分类按节点部署方式分 1.确定性部署 2.随机性部署 3.混合式部署 k-覆盖：指每个节点至少被k个传感器节点覆盖 按覆盖目标分：面覆盖、点覆盖、栅栏覆盖。 第四章：WSN通信与组网技术WSN协议的分层结构从无线联网的角度来看，传感器网络结点的体系由分层的网络通信协议、网络管理平台和应用支撑平台三个部分组成。 网络通信协议类似于传统Internet网络中的TCP/IP协议体系，它由物理层、数据链路层、网络层、传输层和应用层组成。 MAC层和物理层协议采用的是国际电气电子工程师协会(IEEE)制定的IEEE 802.15.4协议。 IEEE 802.15.4是针对低速无线个域网(Low-Rate Wireless Personal Area Network，LR-WPAN)制定的标准。 该标准把低能量消耗、低速率传输、低成本作为重点目标，旨在为个人或家庭范围内不同设备之间低速互连提供统一标准。 IEEE 802.15.4的网络特征与无线传感器网络存在很多相似之处，所以许多研究机构把它作为无线传感器网络的无线通信平台。 (1)物理层。传感器网络的物理层负责信号的调制和数据的收发，所采用的传输介质主要有无线电、红外线、光波等。 (2)数据链路层。 传感器网络的数据链路层负责数据成帧、帧检测、介质访问和差错控制。介质访问协议保证可靠的点对点和点对多点通信，差错控制保证源结点发出的信息可以完整无误地到达目标结点。 (3)网络层。 传感器网络的网络层负责路由发现和维护，通常大多数结点无法直接与网络通信，需要通过中间结点以多跳路由的方式将数据传送至汇聚结点。 (4)传输层。 传感器网络的传输层负责数据流的传输控制，主要通过汇聚结点采集传感器网络内的数据，并使用卫星、移动通信网络、因特网或者其他的链路与外部网络通信，是保证通信服务质量的重要部分。 网络管理平台网络管理平台主要是对传感器结点自身的管理和用户对传感器网络的管理，包括拓扑控制、服务质量管理、能量管理、安全管理、移动管理、网络管理等。 (1)拓扑控制。一些传感器结点为了节约能量会在某些时刻进入休眠状态，这导致网络的拓扑结构不断变化，而需要通过拓扑控制技术管理各结点状态的转换，使网络保持畅通，数据能够有效传输。拓扑控制利用链路层、路由层完成拓扑生成，反过来又为它们提供基础信息支持，优化MAC协议和路由协议，降低能耗。 (2)服务质量管理。服务质量管理在各协议层设计队列管理、优先级机制或者带宽预留等机制，并对特定应用的数据给予特别处理。它是网络与用户之间以及网络上互相通信的用户之间关于信息传输与共享的质量约定。为了满足用户的要求，传感器网络必须能够为用户提供足够的资源，以用户可接受的性能指标工作。 (3)能量管理。在传感器网络中电源能量是各个结点最宝贵的资源。为了使传感器网络的使用时间尽可能长，需要合理、有效地控制结点对能量的使用。每个协议层次中都要增加能量控制代码，并提供给操作系统进行能量分配决策。 (4)安全管理。由于结点随机部署、网络拓扑的动态性和无线信道的不稳定，传统的安全机制无法在传感器网络中适用，因而需要设计新型的传感器网络安全机制，采用诸如扩频通信、接入认证/鉴权、数字水印和数据加密等技术。 (5)移动管理。在某些传感器网络的应用环境中，结点可以移动，移动管理用来监测和控制结点的移动，维护到汇聚结点的路由，还可以使传感器结点跟踪它的邻居。 (6)网络管理。网络管理是对传感器网络上的设备和传输系统进行有效监视、控制、诊断和测试所采用的技术和方法。它要求协议各层嵌入各种信息接口，并定时收集协议运行状态和流量信息，协调控制网络中各个协议组件的运行。 应用支撑平台应用支撑平台建立在网络通信协议和网络管理技术的基础之上，包括一系列基于监测任务的应用层软件，通过应用服务接口和网络管理接口来为终端用户提供各种具体应用的支持。 隐蔽终端 在无线局域网中，经常会出现隐蔽终端的问题，如上图所示。为了解决这种隐蔽终端问题，DCF可利用RTS和CTS两个控制帧来进行信道预约。 实现机制： 在发送站和接收站进行了RTS/CTS握手之后，经过一个SIFS，发送站开始传输数据帧。接收站在收到数据帧后等待一个SIFS，用ACK帧进行应答。此时传输过程已经完成，发送站及接收站覆盖范围内的节点中的NAV值指向0，各节点进入下一轮的信道争用。 名词解释 MAC（Medium Access Control，介质访问控制） CSMA/CA（Carrier Sense Multiple Access/Collision Avoidance，带有碰撞避免的载波监听多点接入） RTS/CTS(Request to Send/Clear to Send，请求发送/允许发送) AP（Access Point，接入点） ESS（Extended Service Set，扩展服务集） BSSID（Basic Service Set identifiers，基本服务集识别码） PCF/DCF（Point Coordination Function/Distributed Coordination Function，点协调功能/分布式协调功能） FDMA（Frequency Division Multiple Access，频分多址） TDMA（Time division multiple access，时分多址） 基于竞争的MAC协议WSN MAC层实现经典协议S-MAC协议及特点： S-MAC（Sensor MAC）协议是在802.11 MAC协议的基础上，针对传感器网络的节省能量需求而提出的传感器网络MAC协议。其主要机制有：周期性侦听和睡眠、流量自适应侦听机制、串音避免、消息传递。 S-MAC协议假设通常情况下传感器网络的数据传输量少，节点协作完成共同的任务，网络内部能够进行数据的处理和融合以减少数据通信量，网络能够容忍一定程度的通信延迟。它的主要设计目标是提供良好的扩展性，减少节点能量的消耗。 （1）周期性侦听和睡眠每个节点独立地调度它的工作状态,周期性地转入睡眠状态,在苏醒后侦听信道状态,判断是否需要发送或接收数据。为了便于相互通信,相邻节点之间应该尽量维持睡眠/侦听调度周期的同步。 （2）流量自适应侦听机制传感器网络往往采用多跳通信,而节点的周期性睡眠会导致通信延迟的累加。在 S-MAC 协议中,采用了流量自适应侦听机制,减少通信延迟的累加效应。 （3）串音避免为了减少碰撞和避免串音,S-MAC 协议采用与802.11 MAC 协议类似的虚拟和物理载波侦听机制,以及 RTS/CTS的通告机制。两者的区别在于当邻居节点处于通信过程中时,S-MAC协议的节点进入睡眠状态。 （4）消息传递因为传感器网络内部数据处理需要完整的消息,所以 S-MAC 协议利用 RTS/CTS机制,一次预约发送整个长消息的时间;又因为传感器网络的无线信道误码率高,S-MAC 协议将一个长消息分割成几个短消息在预约的时间内突发传送。 特点：周期性侦听/睡眠的低占空比工作方式控制节点尽可能处于睡眠状态来降低节点能量的消耗；邻居节点通过协商的一致性睡眠调度机制形成虚拟簇，减少节点的空闲侦听时间；通过流量自适应的侦听机制，减少消息在网络中的传输延迟；采用带内信令来减少重传和避免监听不必要的数据；通过消息分割和突发传递机制来减少控制消息的开销和信息的传递； 路由协议路由协议负责将数据分组从源节点通过网络转发到目的节点。 主要包括两个方面的功能： 寻找源节点和目的节点间的优化路径 将数据分组沿着优化路径正确地转发 路由协议分类： 1） 按源节点获取路径的方法：主动路由协议、按需路由协议、混合路由协议。 2） 按节点参与通信的方式：直接通信路由协议、平面路由协议、层次路由协议。 3） 按路由的发现过程：以位置信息为中心的路由协议、以数据为中心的路由协议。 4） 按路由选择是否考虑服务质量约束 平面路由协议平面路由协议：各个传感器节点的地位是平等的。优点是不存在特殊节点，路由协议的鲁棒性较好，通信流量平均地分散在网络中，缺点是缺乏可拓展性，限制了网络的规模。 1.洪泛路由协议（Flooding Protocol）:是一种最早的协议，收到消息节点以广播的形式发给邻居节点 优点是实现简单,缺点是在数据广播转发过程中产生的冗余数据包大大加重了网络负荷，导致数据内爆(implosion)问题和数据重叠(overlapping)问题。 2.闲聊法(Gossiping)：是洪泛路由的改进版。为了减小资源消耗，引入数据随机发送的方法 3.SPIN（Sensor Protocol for Information via Negotiation）协议：基于协商机制的传感器网络 在发送一个DATA数据包之前，一个传感器节点首先对外广播ADV数据包；如果某个邻居节点在收到ADV后有意愿接收该DATA数据包，那么它向该节点发送一个REQ数据包，然后节点向该邻居节点发送DATA数据包。 SPIN的优点是解决了传统的Flooding和Gossiping协议带来的信息爆炸，信息重复，资源浪费问题。 缺点是SPIN协议的缺点是没有考虑节能和多种信道条件下的数据传输问题。后来在SPIN的基础上出现了改进的路由协议。 层次路由协议LEACH协议：LEACH是一种基于聚类路由协议，在WSN路由协议占有重要地位，其他基于聚类的路由协议如TEEN、APTEEN、PEGASIS等大都由LEACH发展而来。 LEACH路由协议的核心思想及LEACH实现机制见上文。 能量感知路由能量消耗源节点能量消耗源分析，主要包括下面两个部分，正常情况，节点通信相关能量消耗远大于计算相关的。 1）通信相关的能量消耗 2）计算相关的能量消耗 能量路由能量路由是根据节点的可用能量(PA，Power Available)（即节点的当前剩余能量）或传输路径上的能量需求，选择数据转发的路径。 能量感知路由策略主要有以下几种： 最大剩余节点能量路由：从数据源节点到汇聚节点的所有路径中选取节点剩余能量之和最大的路径； 最小能耗路由：从数据源节点到汇聚节点的所有路径中选取节点能耗值和最小的路径。 最少跳数路由：从数据源节点到汇聚节点的所有路径中选取节点最少的路径。 最大最小剩余节点能量路由：每条路径上有多个节点，且节点的可用剩余能量不同，从中选取每条路径中可用能量最小的节点来表示这条路径的可用能量。 能量路由例题： 节点右侧括号内的数字表示节点的可用能量。图中的双向线表示节点之间的通信链路，链路上的数字表示在该链路上发送数据消耗的能量。在图中，从源节点到汇聚节点的可能路径有4条。 路径1：源节点—B—A—汇聚节点，路径上所有节点PA之和为4，在该路径上发送分组需要的能量之和为3；路径2：源节点—C—B—A—汇聚节点，路径上所有节点PA之和为6，在该路径上发送分组需要的能量之和为6；路径3：源节点—D—汇聚节点，路径上所有节点PA之和为3，在该路上发送分组需要的能量之和为4；路径4：源节点—F—E—汇聚节点，路径上所有节点PA之和为5，在该路径上发送分组需要的能量之和为6。 最大剩余节点能量路由：路径2：源节点—C—B—A—汇聚节点最小能耗路由：源节点—B—A—汇聚节点最少跳数路由：源节点—D—汇聚节点最大最小剩余节点能量路由：源节点—F—E—汇聚节点 能量多径路由根据路径上节点能量消耗和剩余能量，给每个路径设定一个选择概率，使得数据传输均匀地消耗能量，延长网络生存周期。 例题：描述LEACH路由协议及平面路由协议实现过程，画出网络拓扑图，比较他们优缺点。 第五章：WSN支撑技术WSN支撑技术分类 时间同步 定位描述 数据融合 能量管理 容错技术 Qos保证 安全技术 时钟同步问题对于两个节点的本地时间而言，时钟偏移量表示时钟之间的时间差。同步是指调整一个或者两个时钟，从而使它们的读数匹配。时钟率则表示一个时钟推移的频率，而时钟偏差则表示两个时钟频率之间的差别。 一个时钟的最大漂移率用偏移率用ρ表示。这个数值由振荡器的制造厂商给出。 WSN时间同步协议实现过程同步有两种，一种是外部的，一种是内部的。 外部同步是指所有节点的时钟都与一个外部时间源(或者参考时钟)同步。 内部同步是指在没有外部参考时钟支持的情况下，所有节点的时钟之间互相同步。网络中所有节点的时间都一样。 时间同步基础1.同步消息 (1)单向消息交换最简单的两两时间同步是在两个节点之间同步时只用一个消息，也就是一个节点发送一个时间戳给另一个节点。如下图左图所示。 (2)双向消息交换另一种更加准确的方式是采用两个同步消息。上图的右图。 D表示未知的传播时延。通常忽略或者设一默认值。 (3)接收端-接收端同步接收端-接收端同步准则的协议是根据同一消息到达不同节点的时差来实现同步的。 2.通信延时的不确定性通信延时的不确定性对于时间同步所能达到的精度有很大的影响。 (1)发送延时 (2)访问延时 (3)传播延时 (4)接收延时 WSN定位技术定位算法分类： 1.基于测距的定位和距离无关的定位算法 2.基于锚节点定位和无锚节点辅助的定位算法 3.集中式计算定位与分布式计算定位 4.紧密耦合定位与松散耦合定位 测距实现方法1.TOA（Time of Arrival,基于到达时间的定位机制）： 已知物理信号的传播速度v，根据信号的传播时间t来计算节点间的距离，即距离d=v×t。此方法要求进行通信的两个节点时间必须高度同步。 2.TDOA（Time Difference Of Arrival，基于到达时间差的定位机制）： 该方法使用两种不同的传播速度的信号，如一个是无线射频信号，另一个是超声波信号。两个信号向同一个方向发送。 3.到达信号强度测量法（RSSI）： 信号强度会随着其传播距离的增加而衰减,表明信号强度变化与传播距离间存在着某种函数关系。它是一种低功率、廉价的测距技术，但是信号强度很容易受到周围环境的影响，通常将其看做一种粗糙的测距技术。 基于测距的常用实现方法 1.三边定位法： 未知节点坐标(x,y)： 2.三角定位法 3.极大似然估计估计法 与距离无关的定位算法 1.质心定位法 2.DV-hop定位算法 DV-HOP（Distance Vector-HOP）定位机制包括3个不同的阶段，首先计算未知节点与每个信标节点的最小跳数，其次计算未知节点与信标节点之间的距离，最后计算未知节点的坐标。 1）第一阶段：计算未知节点与每个信标节点的最小跳数 这个阶段使用经典的距离矢量交换协议，每个节点维护一个表 ，其中xi、yi、hi分别代表信标节点的坐标和到该信标节点的跳数。每个信标节点发送一个广播分组，该分组包含自身的位置信息和跳段个数，跳段个数初始化为0。节点收到信标节点的广播分组后检验该分组跳段数是否小于本节点表内的存储值，如果是则更新该表，然后跳段数加1并广播该分组，否则丢弃该分组。最终所有的未知节点均能获得到所有信标节点的最小跳数。 锚节点A广播的数据包以近似于同心圆的方式在网络中逐次传播，图中的数字代表距离锚节点A的跳数。 （2）第二阶段：计算未知节点与信标节点的距离 每个信标节点根据自身表中记录的其他信标节点的坐标信息和跳数，按照公式计算平均每跳距离ci。然后把计算出来的平均跳段距离利用可控洪泛法进行广播，每个节点均接收第一个跳段距离，忽略后来到达的，这样确保了绝大多数节点可从最近的信标节点接收平均跳段距离。最后未知节点便可计算自己到达相应的信标节点的距离。用平均每跳距离与它接收到的最小跳数hops的乘积来近似代替它到锚节点i的距离。 （3）第三阶段：计算未知节点的坐标当未知节点收到3个或者更多信标节点的距离时，则可以根据三边定位或多边定位算法进行自身位置的计算。 DV-HOP定位算法使用平均跳段距离估算两点之间的实际距离，存在一定误差，同时在定位过程中两次洪泛，能量开销大，但是该算法对硬件要求低，实现简单。 数据融合根据处理融合信息方法： 集中式 分布式 混合式 根据融合处理的数据种类： 时间融合 空间融合 时空融合 根据信息的抽象程度： 数据级融合 特征级融合 决策级融合 电源管理传感器节点消耗能量的模块： 传感器模块 处理器模块 通信模块 前两者能耗很低。 传感器节点4个组成部分： 处理器单元 无线传输单元 传感器单元 电源管理单元 节能策略： 休眠机制 数据融合 无线收发器4种状态： 发送 接收 空闲 休眠 除休眠以外，其他三者状态耗能较高。 容错技术基本概念： 失效 故障 差错 容错能力建立在信息冗余上。 故障模型需要考虑的三个方面： 故障模型 故障检测 诊断、修复机制 传感器节点模块构成 1.数据采集模块 2.数据处理和控制模块 3.通信模块和供电模块 WSN网络安全需求有哪些 1.数据保密性 2.数据认证 3.数据完整性 4.数据实时性 5.秘钥管理 6.真实性 7.扩展性 8.可用性 9.自组织性 10.鲁棒性等方面 理解安全协议、攻击类型分类安全协议： 1.SNEP（安全网络加密协议） 是一个低通讯开销的、实现了数据机密性、通讯机密性、数据认证、完整性认证、新鲜性保护的简单高效的安全协议。SNEP本身只描述安全实施的协议过程，并不规定实际的使用算法，具体的算法在具体实现时考虑。 2.TESLA：提供广播认证 μTESLA协议是基于时间的高效的容忍丢包的流认证协议,用以实现点到多点的广播认证 该协议的主要思想是先广播一个通过密钥Kmac认证的数据包,然后公布密钥Kmac。这样就保证了在密钥Kmac公布之前,没有人能够得到认证密钥的任何信息,也就没有办法在广播包正确认证之前伪造出正确的广播数据包。这样的协议过程恰好满足流认证广播的安全条件。 攻击分类： 按照攻击者的能力来分，可以分为Mote-class攻击和Laptop-class攻击，在前一种情况下，攻击者的资源和普通的节点相当，而在后一种攻击中，攻击者拥有更强的设备和资源。也就是说，在Laptop-class攻击中，恶意节点拥有的资源，包括能量、CPU、内存和无线电发射器等，优于普通节点。Laptop-class攻击所带来的危害更大。 1.对秘密和认证的攻击2.对网路有效性的攻击 常见攻击： （1）DoS（Denial of Service）攻击 （2）Sybil攻击 （3）Sinkhole攻击 （4）Wormhole攻击 （5）Hello泛洪攻击 （6）选择转发攻击 第七章：WSN接入Internet方式 1.应用层网关 2.延迟容忍网络 3.TCP/IP覆盖传感器网络协议栈 4.传感器网络协议栈覆盖TCP/IP 5.移动代理 同构网络接入方式异构网络接入方式 近期再更新，愿每个人努力能得到自己想要的。","categories":[{"name":"复习","slug":"复习","permalink":"https://Stefancharles.xyz/categories/复习/"}],"tags":[{"name":"WSN","slug":"WSN","permalink":"https://Stefancharles.xyz/tags/WSN/"}]},{"title":"基于OMNET++仿真平台的4维超立方体网络仿真","slug":"omnettasktwo","date":"2019-12-09T16:00:00.000Z","updated":"2019-12-12T11:46:43.828Z","comments":true,"path":"2019/12/10/omnettasktwo/","link":"","permalink":"https://Stefancharles.xyz/2019/12/10/omnettasktwo/","excerpt":"实验要求编程实现一个4维的立方体网络仿真，网络节点按照如下方式运行，实验要求： 1.网络节点按照默认的顺序，如节点标识0，1，…，15从小到大的顺序依次产生一个数据包。 2.节点产生（或接收到）一个数据包后，随机选择一个相邻节点发送数据包，依此规则重复执行，直至产生数据包的节点接收到自己的数据包后，直接删除该数据包。","text":"实验要求编程实现一个4维的立方体网络仿真，网络节点按照如下方式运行，实验要求： 1.网络节点按照默认的顺序，如节点标识0，1，…，15从小到大的顺序依次产生一个数据包。 2.节点产生（或接收到）一个数据包后，随机选择一个相邻节点发送数据包，依此规则重复执行，直至产生数据包的节点接收到自己的数据包后，直接删除该数据包。 实验环境 Win10 2004 OMNeT++ 5.5.1 VSCode 打开工程首先我们需要做一些实验前的准备工作。点击这里去之前的我的一篇博客记录了OMNeT的安装以及如何开始上手一个简单的工程。这里我不再重复造轮子。 注意，我以omnetpp-5.5.1\\samples\\hypercube 作为demo，基于hypercube例程来完成这一次实验。最好直接在这个项目里进行修改，如果新建一个完全空白的项目来完成这一实验的话，可能出现很多找不到函数的问题。 最好先备份hypercube文件夹，以免改动太多导致报错而无法挽回。当然你也可以自己新建一个空白的工程从0开始或者选择其他例程上手。 大致思路首先来看下超立方的定义： 超级立方体网络指具有 d 个维度的网络具有2d个网络节点，网络节点按照0，1，2，…2d-1顺序进行编号。标识 i 的节点采用二进制方式可表示为d 位的二进制序列，网络任意两个节点二进制形式表示的d位标识符，对应位只有某一位不同时，表示节点是直接相邻接，否则，两个节点之间不存在直接相邻接。例如，对于一个3维的超级立方体网络，网络中存在8（8 = 23）个网络节点，如0(000)，1(001) ，2(010) ，3(011) ，4(100) ，5(101) ，6(110) ，7(111)。网络拓扑结构按照如下方式连接，节点 0(000)与节点1(001) ，2(010) ，4(100) 直接相临接，因节点 0(000)与节点1，2，4分别在第1位，第2位，第3位不同（从左往右数），其他节点按此规律相邻接。 简单来说，在4维的情况下，每个节点将会与4个节点相连接。但是不是随便和某个编号的节点相连接的。 假设我是一个节点，那么和我相互连接的节点的编号的二进制必须只能和我有1位不同。 更具体的假设：假设我是0号节点，我的二进制编号是0000，和我有1位不同的话，那么就是0001，0010，0100，1000咯。 对吧。再把二进制转换回来，那就是编号为1，2，4，8的节点和我连接。 和上一次的实验有所不同的是，这一次实验里每一个节点都同时扮演了三个角色，也就是HCGenerator（消息产生器），HCRouter（路由器），HCSink（汇聚点）。 上面的括号里是我随意取的名字，叫它们什么不重要。重点是它们分别的作用。 HCGenerator：产生消息出去。 HCRouter：我的邻居节点发消息给我我负责转发。 HCSink：消息汇聚到这里。 和上面名字相关的代码有 “.cc”，“.ned”，这些和之前实验的是一个意思。 总体的思路：HCGenerator里节点按顺序产生消息 –&gt; HCRouter里节点处理收到的消息 –&gt; HCSink里判断是不是到了目的节点，是的话就删除这个消息 按照要求，在HCRouter里需要随机选择一个邻居节点转发出去。 大概的流程图如下： 当然，还是那句话，思路很简单。引用屈博士的话，“说谁不会说”。纸上谈来终觉浅，绝知此事要躬行。Talk is cheap ,Show me the code. 实验知识 .cc文件是对所有模块生效的代码，不是只对特定的某一个模块或者节点生效。 删除网络中的所有消息可以结束仿真，调用endSimulation()函数也可以结束仿真。 在win10下，如果按下开始仿真任务栏有图标但是没有界面，可以尝试外接一个显示器。 在仿真界面的左上角有一个fast图标，可以快速仿真到仿真结束。 数据包和消息（Message）是一个意思。 EV相当于cout。 send(msg, “out”)函数只是把消息推送到out门，出了门后消息具体怎么走不属于它管。 NED文件描述消息出门后具体路线。 开始上手我以omnetpp-5.5.1\\samples\\hypercube 作为demo，基于hypercube例程来完成这一次实验。 修改维度官方的hypercube例程默认维度是3。而实验要求是4维空间。 在HypercubeNetwork.ned里，修改dim（维度）为4. 123456network HypercubeNetwork extends Hypercube&#123; parameters: dim = default(4);//维度 nodetype = \"HypercubeNode\";&#125; 其他位置暂时不做改动，我们直接就可以运行试试，结果如下图： 可以验证一个我上面的举例：假设我是0号节点，我的二进制编号是0000，和我有1位不同的话，那么就是0001，0010，0100，1000。再把二进制转换回来，那就是编号为1，2，4，8的节点和我连接。 HCGenerator.cc123456789101112void HCGenerator::activity()&#123; int numStations = par(\"numStations\"); int my_address = par(\"address\"); cPar&amp; iaTime = par(\"iaTime\"); // take by ref since it can be random for (int i = 0; ; i++) &#123; // select destination randomly (but not the local station) //int dest = intrand(numStations-1); int dest = my_address; //后面代码不做改动&#125; 原本的代码是随机选择一个目的节点，实验要求要回到自己，所以注释上面的再添加int dest = my_address即可。 HCRouter.cc当路由器收到消息的时候，就进去activity()函数处理消息。 下面的图是一个重点代码， if (pkt-&gt;getArrivalGateId() != fromUserGateId)用来判断是不是自己刚开始发的消息，如果不是，那么说明是从邻居节点收到的消息， 然后，if (pkt-&gt;getDestAddress() != my_address)判断这个消息节点的目的是不是我自己，如果不是，就再转发；如果是，就进入send(pkt, “toSink”)交给HCSink.cc处理。 下面的deflectionRouting就是用来处理消息走哪条路了。 123deflectionRouting(my_address, dim, rte_dest, num_rte, rte_port, usr_dest, num_usr, usr_port); 实验要求：节点产生（或接收到）一个数据包后，随机选择一个相邻节点发送数据包，依此规则重复执行，直至产生数据包的节点接收到自己的数据包后，直接删除该数据包。 好了，也就是要随机选一个，这个很简单。之前就有个intrand(int i)函数产生[0,i)的随机数。 也就是说我们要整出个随机路由选择算法。 伪代码如下： 1.产生一个0-15的随机数 2.设一个可以存放4个数字的数组 3.数组里存放本节点的二进制节点编号分别与1，2，4，8异或的结果 4.判断第一步产生的随机数在不在数组里 4.1如果在，则就把消息转发到编号是随机数的节点 4.2如果不在，则重新产生一个0-15的随机数，再去第四步，直到找到一个属于数组里的随机数 当然，上面的思路仅仅是一种方法，仅供参考。我相信还有更好的随机路由选择算法，条条大路通罗马。 换句话说，和本节点相连接的节点的编号就是本节点的二进制节点编号分别与1，2，4，8异或的结果。 为什么呢？因为要保证实验条件：对应位只有某一位不同时，表示节点是直接相邻接，否则，两个节点之间不存在直接相邻接。 4个位置只有1位不同，那么最简单的想法就是拿两个节点编号的二进制位异或的结果是1，2，4，8的其中一个就可以。 反向操作的话，注意到一个简单的特点A异或B得到C，那么A异或C就会得到B。这点有意思，方便了计算数组。 把上面的伪代码实现后，注意在HCRouter.cc里添加对sendcount（发送消息数目），recievedcount（收到消息数目）的统计。 这部分具体的实现代码就不贴了，一百个读者有一百个哈姆雷特。 HCSink.cc例程里的这部分代码基本上实现了功能，也就是节点收到了自己发出去的消息就删除这个消息。基本上不需要做什么改动。 但是为了实验结果显示的方便，我这里加入一个文件读取代码。 123456ofstream OutFile; OutFile.open(\"LogOfHyperCube.txt\",ios::out | ios::app);OutFile &lt;&lt; \"Received: \" &lt;&lt; pkt-&gt;getName() &lt;&lt; endl;OutFile &lt;&lt; \" - end-to-end delay=\" &lt;&lt; eed &lt;&lt; endl;OutFile &lt;&lt; \" - distance=\" &lt;&lt; minHops &lt;&lt; \", after hops=\" &lt;&lt; actualHops &lt;&lt; endl;OutFile.close(); 上面的代码里的ios::app是追加到文件末尾。这样讲道理到时候实验结果会看得很清楚了。 最好注意关闭文件。 一个坑上面的代码都完成后，仿真却停不下来。按照之前的，所有消息都删除了就应该仿真自动停止，但是这里停不下来。 问题就在于我在这篇文章开头说的一样: 和上一次的实验有所不同的是，这一次实验里每一个节点都同时扮演了三个角色，也就是HCGenerator（消息产生器），HCRouter（路由器），HCSink（汇聚点）。 细心看过整个工程代码的同学会发现在HCRouter.cc里有一个死循环代码： 这也说得通，因为16个节点作为路由器得负责转发消息，只能一个死循环来这么做了。 可能你会想，设置一个count计数，统计删除的消息数目，当count达到16的时候就调用endSimulation()函数不就行了？ 好像也是这么回事。但是，正如上文我说了， .cc文件是对所有模块生效的代码，不是只对特定的某一个模块或者节点生效。 你定义的count只是你一个节点的count，并不是全部节点所共有的变量。 我贫瘠的语言形容不出这种问题，当你实际做这个实验的时候，你就会明白我说的意思了。 我的解决方法是：建一个txt文件，当有一个消息被删除就向文件里写一个“1”，当产生的16个消息都各回各回家后，这个txt文件里应该有16个连起来的“1”，然后读取文件，当读出来的length是16的时候，就调用endSimulation()。 写： 123ofstream CountNode;CountNode.open(\"Count.txt\",ios::out | ios::app); CountNode &lt;&lt; \"1\"; 读： 1234567ifstream readFile;readFile.open(\"Count.txt\",ios::in);string count;readFile &gt;&gt; count;if(count.length()==16)&#123; endSimulation();&#125; 这个算是一个折中的办法了，如果有更好的办法与代码，欢迎提出。 更简单的方式经过罗老板的指出，事实上，在HCRouter.cc代码里，将activity函数修改为handleMessage函数就可以很简单的解决问题。 因为后者就仅仅在消息到来的时候才调用处理。当所有消息各回各家后也就没有消息，路由器角色也就不会无休止运行。 仿真结果实验结果如下图： Tips：如果上面的图没有正确加载出来，请刷新本界面，或者翻墙后全局代理访问本界面 可以从实验结果看到，确实有16个“1”在那个txt文件里，另外，每个节点产生的数据包一个轮回产生的跳数，每个节点发送、接收的数据包的个数从txt文件里一目了然。 致谢本次实验最难的不是思路，因为思路同样也很简单，说谁都会说，“云指挥” 谁都会。 纸上谈来终觉浅，绝知此事要躬行。 之前一段时间在写网络安全的课程设计，没想到无线传感器网络这门课的实验报告这么快要交。 大部分时间花在看hypercube的官方例程和解决无法终止仿真上了。 本次实验经过和物联网实验室的阳博主和达哥，以及罗老板的讨论，有了很多思路，在这里表示感谢。 点击这里去阳博主的csdn博客 点击这里去达哥的csdn博客 点击这里我的csdn博客 罗老板是一个高冷男神。 如果可以的话，可以关注一波。点赞素质三连？/滑稽 /狗头 另一种实现方式上文的操作是我在hypercube的工程基础上修改添加的。你也可以新建一个空白工程完成实验。思路大体一致。 这里给出一个可以供参考的彭博主的博客，彭博主的实现方式就是新建一个新的工程。 点击这里去彭博主的博客地址 需要联系我？后面有时间再更新吧。 如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。 下面的内容与本实验无关。 说在最后的话 There are moments in all of our lives when we are compelled to ask ourselves, how far are we willing to go for what we want? ————《不死法医》 我们生命中有些时刻，会让我们扪心自问，为了追寻你要的东西，你愿意付出多少？","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"omnetpp","slug":"omnetpp","permalink":"https://Stefancharles.xyz/tags/omnetpp/"},{"name":"c++","slug":"c","permalink":"https://Stefancharles.xyz/tags/c/"}]},{"title":"【Spring MVC】基于Java的安全即时通讯软件","slug":"springboot","date":"2019-12-08T16:00:00.000Z","updated":"2020-01-01T07:45:19.839Z","comments":true,"path":"2019/12/09/springboot/","link":"","permalink":"https://Stefancharles.xyz/2019/12/09/springboot/","excerpt":"简介Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了应用的开发效率。本博客用于记录开发即时通讯软件中遇到的问题和解决方案。","text":"简介Spring框架由Rod Johnson开发，2004年发布了Spring框架的第一版。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了应用的开发效率。本博客用于记录开发即时通讯软件中遇到的问题和解决方案。 环境 Win10 2004 IDEA 2019.3 Maven 3.6.3 1.Unable to find a single main class from the following candidates报错内容如下： 1Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.0.5.RELEASE:repackage (default) on project easychat_client: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:2.0.5.RELEASE:repackage failed: Unable to find a single main class from the following candidates [com.stefan.chat.App, com.stefan.chat.util.Terminal] 解决方法： 这里因为项目中有两个主函数的类，maven需要你指定一个主main类。也就是mainClass。 所以在pom.xml中添加以下设置： 1234567891011121314151617181920212223242526272829&lt;build&gt; &lt;finalName&gt;chat&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;mainClass&gt;com.stefan.chat.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;9&lt;/source&gt; &lt;target&gt;9&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 持续更新 持续更新，敬请关注。 需要联系我？如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://Stefancharles.xyz/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://Stefancharles.xyz/tags/Maven/"},{"name":"Spring","slug":"Spring","permalink":"https://Stefancharles.xyz/tags/Spring/"}]},{"title":"【ZigBee】获取网络的拓扑结构","slug":"zigbeetasknine","date":"2019-12-08T16:00:00.000Z","updated":"2019-12-10T09:40:41.069Z","comments":true,"path":"2019/12/09/zigbeetasknine/","link":"","permalink":"https://Stefancharles.xyz/2019/12/09/zigbeetasknine/","excerpt":"实验简介任务9： 组一个包括协调器路由器终端节点的zigbee网络，通过串口能获取它们的拓扑结构。","text":"实验简介任务9： 组一个包括协调器路由器终端节点的zigbee网络，通过串口能获取它们的拓扑结构。 实验环境 Win10 2004 IAR 10.30 Z-Stack VScode 实验准备1.下载基本工程文件首先下载最基本的工程文件，我们在这个的基础上进行代码修改。 下载地址:https://www.lanzous.com/i7j1gtc 密码:1024 2.打开工程文件解压你第一步下载的基本工程的压缩包，路径是“…\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\Samples\\GenericApp\\CC2530DB”文件夹下的GenericApp.eww。 双击使用最新版IAR打开它。刚打开的时候IAR会多次提示你版本不兼容信息，不必理会，直接一路点击Ok就行。 3.尝试编译上一步完成后，先不改动任何地方。直接点击rebuild图标或者按下F7。也就是下图的箭头指向的图标。 先看是否报错。如果报错，先参考这里【IAR-10.30.1】最新版本IAR常见编译问题总结。 按照这篇博客的方法解决问题即可。 路由器和终端节点要想获取网络的拓扑结构，可以设置网络中的路由器和终端节点组网成功后就向协调器发送自己的网络地址以及父节点网络地址。这样便可以知道谁是谁的父节点，网络拓扑也就可以得到。 首先为了方便我们对NWK地址方便操作，我们在Coordinator.h中定义一个结构体如下： 1234567//This is for task 9typedef struct RFTXBUF&#123; uint8 type[3]; uint8 NWK[4]; uint8 parentNWK[4];&#125;RFTX; type是对节点类型的描述，也就是路由器和终端节点。NWK是本设备的网络地址，parentNWK是父节点的网络地址。 接下来在Enddevice.c里宏定义一个事件代码： 1#define SEND_DATA_EVENT 0x01 然后在事件处理函数如下： 123456789101112131415161718192021222324252627282930313233343536373839UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )&#123; afIncomingMSGPacket_t *MSGpkt; if ( events &amp; SYS_EVENT_MSG ) &#123; MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); while ( MSGpkt ) &#123; switch ( MSGpkt-&gt;hdr.event ) &#123; case AF_INCOMING_MSG_CMD: break; case ZDO_STATE_CHANGE: //建网后 GenericApp_NwkState=(devStates_t)(MSGpkt-&gt;hdr.status); if((GenericApp_NwkState == DEV_END_DEVICE)||(GenericApp_NwkState == DEV_ROUTER))&#123; osal_set_event(GenericApp_TaskID,SEND_DATA_EVENT); &#125; break; default: break; &#125; // Release the memory osal_msg_deallocate( (uint8 *)MSGpkt ); // Next MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); &#125; // return unprocessed events return (events ^ SYS_EVENT_MSG); &#125; if(events&amp;SEND_DATA_EVENT) &#123; HalLedBlink(HAL_LED_2,0,50,1000); SendMsgToCood(); return (events^SEND_DATA_EVENT); &#125; return 0;&#125; 这里很简单，就是在组网后准备把自己的网络信息发给协调器，调用的是SendMsgToCood()函数。其函数参考代码可以如下： 123456789101112131415161718192021222324252627282930313233//建网后发消息给协调器void SendMsgToCood(void)&#123; RFTX rftx; uint16 nwk; if(GenericApp_NwkState == DEV_END_DEVICE) //判断是否是终端节点 &#123; osal_memcpy(rftx.type,\"END\",3); &#125; if(GenericApp_NwkState == DEV_ROUTER) //判断是否是路由器 &#123; osal_memcpy(rftx.type,\"ROU\",3); &#125; nwk = NLME_GetShortAddr(); To_string(rftx.NWK,(uint8 *)&amp;nwk,2); nwk = NLME_GetCoordShortAddr(); To_string(rftx.parentNWK,(uint8 *)&amp;nwk,2); afAddrType_t GenericApp_DstAddr; GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit; GenericApp_DstAddr.endPoint =GENERICAPP_ENDPOINT; GenericApp_DstAddr.addr.shortAddr = 0x0000; AF_DataRequest( &amp;GenericApp_DstAddr, &amp;GenericApp_epDesc, GENERICAPP_CLUSTERID, 11, (uint8 *)&amp;rftx, &amp;GenericApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS );&#125; 这里用到了之前定义的结构体了。当然也需要进制转换的函数，函数如下： 1234567891011121314void To_string(uint8 *dest,char* src,uint8 length)//二进制转十六进制&#123; uint8* xad; uint8 i=0; uint8 ch; xad=src+length-1; for(i=0;i&lt;length;i++,xad--) &#123; ch=(*xad&gt;&gt;4)&amp;0x0F; //除以十六 dest[i&lt;&lt;1]=ch+((ch&lt;10)?'0':'7'); ch=*xad&amp;0x0F; dest[(i&lt;&lt;1)+1]=ch+((ch&lt;10)?'0':'7'); &#125;&#125; 协调器协调器主要是负责处理路由器和终端节点发来的信息，整理后打印到电脑的串口上。 在Coordinator.c中的的事件处理函数如下： 12345678910111213141516171819202122232425262728293031UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )&#123; afIncomingMSGPacket_t *MSGpkt; if ( events &amp; SYS_EVENT_MSG ) &#123; MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); while ( MSGpkt ) &#123; switch ( MSGpkt-&gt;hdr.event ) &#123; case AF_INCOMING_MSG_CMD: HalLedBlink(HAL_LED_2,0,50,500); //LED2 闪烁 GenericApp_MessageMSGCB( MSGpkt ); break; default: break; &#125; // Release the memory osal_msg_deallocate( (uint8 *)MSGpkt ); // Next MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); &#125; // return unprocessed events return (events ^ SYS_EVENT_MSG); &#125; return 0;&#125; 当收到消息的时候，进入AF_INCOMING_MSG_CMD的case里，调用的消息处理函数GenericApp_MessageMSGCB()如下： 123456789101112131415RFTX nodeinfo[3];uint8 nodenum = 0;void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pckt )&#123; switch ( pckt-&gt;clusterId ) &#123; case GENERICAPP_CLUSTERID: osal_memcpy(&amp;nodeinfo[nodenum++],pckt-&gt;cmd.Data,11); break; default: break; &#125;&#125; 对应存储在结构体中，方面我们打印。然后我们可以使用串口回调函数打印信息，当然也可以设置一个定时的事件向串口打印信息。这里就展示前者的代码。 首先在Coordinator.c中开串口： 12345uartConfig.configured =TRUE;uartConfig.baudRate =HAL_UART_BR_115200;uartConfig.flowControl =FALSE;uartConfig.callBackFunc =rxCB;HalUARTOpen(0,&amp;uartConfig); 然后实现回调函数： 12345678910111213141516171819202122static void rxCB(uint8 port,uint8 event)&#123; uint8 buf[8]; uint8 i = 0; unsigned char enter[2] = &#123;0x0A,0x0D&#125;; HalUARTRead(0,buf,8); if(osal_memcmp(buf,\"showinfo\",8)) &#123; for(i=0;i&lt;2;i++) &#123; HalUARTWrite(0,nodeinfo[i].type,3); // 设备类型 HalUARTWrite(0,\" NWK: \",6); HalUARTWrite(0,nodeinfo[i].NWK,4); //网络地址 HalUARTWrite(0,\" parentNWK: \",13); HalUARTWrite(0,nodeinfo[i].parentNWK,4); //父节点网络地址 HalUARTWrite(0,enter,2); &#125; &#125;&#125; 也就是说，当我们向串口输入showinfo时，串口会回应我们相关网络拓扑结构。接下里烧录代码进行测试。 烧录代码出现的问题及解决问题出现Error[e27]切换角色至路由器，烧录路由器代码的时候可能出现下面的问题： 1Error[e27]: Entry &quot;GenericApp_Init::?relay&quot; in module Coordinator ( C:\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\Samples\\GenericApp\\ CC2530DB\\CoordinatorEB\\Obj\\Coordinator.r51 ) redefined in module Enddevice ( C:\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\Samples\\ GenericApp\\CC2530DB\\CoordinatorEB\\Obj\\Enddevice.r51 从报错内容可以大概知道：因为我们的工程中包含其中两个不同的.C文件都定义了同一个函数，编译时系统同时编译这两个文件，导致这两个函数重定义了。 解决方法1.右击协调器的c文件。选择options。 2.勾选左上角的勾，然后确定即可。 3.重新编译协调器的代码文件变灰色说明可以了。 实验结果三者上电后，最好全部按下复位。 结果如下图。 写在最后的话 The problem with living for 200 years isn’t the loneliness or the pain or the loss. Okay, sure, it is those things. But what really gets you is when life ceases to surprise you. ——《不死法医》 活了200年的麻烦，并不是孤单或痛苦或失去。其实就是这些，但真正让你痛不欲生的是当生活不再惊喜。 需要联系我？如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"基于OMNET++仿真平台的正方形网络仿真","slug":"omnettaskone","date":"2019-11-29T16:00:00.000Z","updated":"2019-12-01T09:09:53.649Z","comments":true,"path":"2019/11/30/omnettaskone/","link":"","permalink":"https://Stefancharles.xyz/2019/11/30/omnettaskone/","excerpt":"实验要求以讲解的tictoc网络模型为例，建立一个TicToc正方形网络模型，如下图所示，网络节点是正方形的四个节点，均为Tic模块的实例，节点周期性的产生数据包，数据包通过输出门发送到相连的邻接点，当节点产生的数据包又回到发送节点时，删除该数据包。当某个节点产生的数据包个数等于100时，结束网络仿真过程，统计各节点产生、发送、接受的数据包个数。","text":"实验要求以讲解的tictoc网络模型为例，建立一个TicToc正方形网络模型，如下图所示，网络节点是正方形的四个节点，均为Tic模块的实例，节点周期性的产生数据包，数据包通过输出门发送到相连的邻接点，当节点产生的数据包又回到发送节点时，删除该数据包。当某个节点产生的数据包个数等于100时，结束网络仿真过程，统计各节点产生、发送、接受的数据包个数。 实验环境 Win10 1909 OMNeT++ 5.5.1 VSCode 建立工程首先我们需要做一些实验前的准备工作。点击这里去之前的我的一篇博客记录了OMNeT的安装以及如何开始上手一个简单的工程。这里我不再重复造轮子。 大致思路首先我们需要一个我们模块的类，这个类public继承自cSimpleModule。根据实验的要求，我们需要设计三个整型变量来分别对各节点产生、发送、接受的数据包个数进行统计。三个函数分别用作初始化（initialize），转发消息（forwardMessage），处理收到的消息（handleMessage）。在initialize()函数里我们对四个节点进行定时发送，按照周期性的要求，也可以初始化的时候同时发送数据包（消息）。当一个节点收到消息的时候，就进到处理消息函数里，在handleMessage()函数里我们判断一个收到的消息是不是自己发的消息，如果是，那么就销毁刚刚收到的这个消息，并且又开启新一轮的发送消息。四个节点都是如此，循环直到节点的createcount达到100就停止。 一个很随意的流程图如下： 当然，思路很简单。引用屈博士的话，“说谁不会说”。俗话说，纸上谈来终觉浅，绝知此事要躬行。Talk is cheap ,Show me the code. 实验准备 .cc文件是对所有模块生效的代码，不是只对特定的某一个模块或者节点生效。 删除网络中的所有消息可以结束仿真，调用endSimulation()函数也可以结束仿真。 在win10下，如果按下开始仿真任务栏有图标但是没有界面，可以尝试外接一个显示器。 提示access denied是因为已经存在一个仿真界面，需要关闭原有的才能新建一个。 在仿真界面的左上角有一个fast图标，可以快速仿真到仿真结束。 对变量传参到WATCH()函数，可以在仿真时较为直观观察变量的值。 数据包和消息（Message）是一个意思。 EV相当于cout。 send(msg, “out”)函数只是把消息推送到out门，出了门后消息具体怎么走不属于它管。 NED文件描述消息出门后具体路线。 参考代码我们以Txc13作为demo，来完成这一次实验。 类定义部分参考代码如下： 123456789101112class Txc13 : public cSimpleModule&#123;private: int createcount; int sendcount; int receivecount; protected: virtual TicTocMsg13 *generateMessage(); virtual void forwardMessage(TicTocMsg13 *msg); virtual void initialize() override; virtual void handleMessage(cMessage *msg) override;&#125;; createcount,sendcount,receivecount分别对应各节点产生、发送、接受的数据包个数。 generateMessage()函数是用来产生消息，返回一个TicTocMsg13类型的消息对象。 TicTocMsg13定义如下： 12345678910111213141516171819202122232425262728293031class TicTocMsg13 : public ::omnetpp::cMessage&#123; protected: int source = 0; int destination = 0; int hopCount = 0; private: void copy(const TicTocMsg13&amp; other); protected: // protected and unimplemented operator==(), to prevent accidental usage bool operator==(const TicTocMsg13&amp;); public: TicTocMsg13(const char *name=nullptr, short kind=0); TicTocMsg13(const TicTocMsg13&amp; other); virtual ~TicTocMsg13(); TicTocMsg13&amp; operator=(const TicTocMsg13&amp; other); virtual TicTocMsg13 *dup() const override &#123;return new TicTocMsg13(*this);&#125; virtual void parsimPack(omnetpp::cCommBuffer *b) const override; virtual void parsimUnpack(omnetpp::cCommBuffer *b) override; // field getter/setter methods virtual int getSource() const; virtual void setSource(int source); virtual int getDestination() const; virtual void setDestination(int destination); virtual int getHopCount() const; virtual void setHopCount(int hopCount);&#125;; 在这里我们可以调用函数设置或者获取跳数，目的节点等信息。后面会用到里面的部分函数。 注册模块这一步很简单但是很重要。 1Define_Module(Txc13); initialize()这里我让第一个节点在0时刻产生和发送消息，第二、三、四个节点分别在0.5，1.0，1.5时刻发送消息。也可以全部设置为同时发。部分参考代码如下： 123456789101112131415161718192021222324void Txc13::initialize()&#123; createcount = 0; sendcount = 0; receivecount = 0; // Boot the process scheduling the initial message as a self-message. if(getId()==2)&#123; TicTocMsg13 *msg = generateMessage(); scheduleAt(0.0, msg); &#125; if(getId()==3)&#123; TicTocMsg13 *msg = generateMessage(); scheduleAt(0.5, msg); &#125; if(getId()==4)&#123; TicTocMsg13 *msg = generateMessage(); scheduleAt(1.0, msg); &#125; if(getId()==5)&#123; TicTocMsg13 *msg = generateMessage(); scheduleAt(1.5, msg); &#125;&#125; getId()函数作用如下注释描述。 1234567/** * Returns the component's ID in the simulation object (cSimulation). * Component IDs are guaranteed to be unique during a simulation run * (that is, IDs of deleted components are not reused for new components.) * * @see cSimulation::getComponent(), cSimulation::getModule(), cSimulation::getChannel() */ 第一个模块的ID是2，后面的模块依次加1. generateMessage()在产生消息的函数里使createcount计数器加1，每调用一次这个函数那么就会使createcount加1。同时设置源点和终点，虽然都是自己吧。部分参考代码如下： 12345678910111213TicTocMsg13 *Txc13::generateMessage()&#123; // Produce source and destination addresses. createcount++; int src = getId(); int dest =src; char msgname[20]; sprintf(msgname, \"tic-%d-to-%d\", src, dest); TicTocMsg13 *msg = new TicTocMsg13(msgname); msg-&gt;setSource(src); msg-&gt;setDestination(dest); return msg;&#125; forwardMessage()在这里我们把消息推送到out门。出了门后怎么走就不管，也管不了。现在再回头看一看实验要求： 当节点产生的数据包又回到发送节点时，删除该数据包。当某个节点产生的数据包个数等于100时，结束网络仿真过程，统计各节点产生、发送、接受的数据包个数。 注意我加粗的文字部分。当有一个节点产生第100个消息的时候，它已经产生了，但是不能发出去。所以关键就在forwardMessage()对createcount做验证。部分参考代码如下： 12345678910111213141516171819202122void Txc13::forwardMessage(TicTocMsg13 *msg)&#123; if(createcount &gt;= 100) &#123; EV &lt;&lt;getName () &lt;&lt; \" 's count reached zero,deleting message\\n\"; EV &lt;&lt; \"createcount: \" &lt;&lt; createcount &lt;&lt; \"\\n\"; EV &lt;&lt; \"sendcount: \" &lt;&lt; sendcount &lt;&lt; \"\\n\"; EV &lt;&lt; \"receivecount: \" &lt;&lt; receivecount &lt;&lt; \"\\n\"; delete msg; endSimulation(); &#125; else &#123; EV &lt;&lt; getName() &lt;&lt;\" 's createcount is\" &lt;&lt; createcount &lt;&lt;\",sending message\\n\"; // Increment hop count. msg-&gt;setHopCount(msg-&gt;getHopCount()+1); sendcount++; send(msg, \"out\"); // send out the message &#125;&#125; 同时需要注意，其他节点发给本节点的消息也要帮别人转发出去，所以要使sendcount加1。 handleMessage()当有消息来到节点时，节点自动调用handleMessage(cMessage *msg)函数。部分参考代码如下： 1234567891011121314151617181920void Txc13::handleMessage(cMessage *msg)&#123; receivecount++; if (msg-&gt;getDestination() == getId()) &#123; // Message arrived. EV &lt;&lt; \"Message \" &lt;&lt; msg &lt;&lt; \" arrived after \" &lt;&lt; msg-&gt;getHopCount() &lt;&lt; \" hops.\\n\"; bubble(\"ARRIVED, starting new one!\"); delete msg; // Generate another one. EV &lt;&lt; \"Generating another message: \"; TicTocMsg13 *newmsg = generateMessage(); EV &lt;&lt; newmsg &lt;&lt; endl; forwardMessage(newmsg); &#125; else &#123; // We need to forward the message. forwardMessage(ttmsg); &#125;&#125; 严格来说这里代码是存在问题的，实验要求节点周期性产生消息发送出去，而我们这里是等节点收到上一个我们发的消息后再重新Generate一个消息出去。由于正好是一个正方形网络，所以导致这样也算是周期性。然而，如果不是正方形网络，而是一个随机的网络里，那么就很大可能上一个消息还没到，这一个节点就已经到了周期定时的时间而不得不再Generate一个消息出去。 这样的话，需要在initialize()函数里进行改动，会复杂一些。有时间可以去尝试。 上文还有一些小细节上的代码没有贴出。整体的代码就是如此。当然代码实现的方式还有很多，比如说调用getModuleId()也可能可以。 仿真结果按照一开始我们对消息产生的时间的设定，讲道理第一个节点的createcount应该先到100. 实验结果如下图： 可以看到第一个节点createcount先到100。符合我们的理论推断。 致谢本次实验最难的不是思路，因为思路很简单，说谁都会说，“云指挥” 谁都会。 纸上谈来终觉浅，绝知此事要躬行。 主要的问题在于具体代码的实现，因为对很多函数不了解，很多api可以方便的用，然而我们却不知道它们的存在。 一开始我用了很多没有必要的代码来实现，用零零散散的时间写了四个晚上的代码。然而还是有一些问题。 后来经过物联网实验室的阳博主的指导，醍醐灌顶。在这里表示感谢。 点击这里去阳博主的csdn博客 可以关注一波阳博主。 需要联系我？后面有时间就更新基于OMNET++仿真平台的4维超立方体网络仿真实验。 如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。 下面的内容与本实验无关。 说在最后的话 Some memories are precious … and we need to hang on to them. But Emily Dickinson wrote, “Forever is composed of nows”. And she is right. If we root ourselves too deeply in the past , we will miss what is right in front of us. 不太准确的翻译： 有些记忆很珍贵。我们需要考它们取暖。但是Emily Dickinson写道：“永恒由现在组成”。她说得对，如果我们对过去扎根太深，就会错过现在。 这句话出自于一部美剧《不死法医》。高中的时候我把这一句规规整整的写在读书笔记本上，然而现在再拿起来看的时候，又读到了不同于当时的感受。高二的压力很大让我很怀念高一的生活，压抑在那个时候的我期望着高中时光的结束，期待高中老师描述的那种大学生活。 然而站在现在的时间节点来看，过去那段的高中时间却是温暖我现在前行的记忆。我知道没有人可以真的回到过去，但是很多时候我把现在与记忆对比，这让我深深扎根于过去。 自己在实验室写代码，或者写东西很久后，恍惚间有种很深的失落感，一想到自己需要做的很多事情还没有做，很多想要做的事情又没能有机会去做。曾经做过很多让自己后悔的事情又不能够重新做，对不起过很多人，也让很多人失望过… 生活不是仿真，不能重新再来，也不能快进快退。我们都明白这一点，很多时候还是会失落，失落过后最重要的还是需要重新on your feet，尽力做好眼前事，cherish right now. 希望不负自己。","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"omnetpp","slug":"omnetpp","permalink":"https://Stefancharles.xyz/tags/omnetpp/"}]},{"title":"【ZigBee】协调器广播&终端节点单播","slug":"zigbeetasksix","date":"2019-11-24T16:00:00.000Z","updated":"2019-11-29T13:53:37.917Z","comments":true,"path":"2019/11/25/zigbeetasksix/","link":"","permalink":"https://Stefancharles.xyz/2019/11/25/zigbeetasksix/","excerpt":"实验简介任务6： 协调器周期性以广播的形式向终端节点发送数据（每隔5s广播一次），终端节点接收数据后，使开发板上的LED灯状态翻转，同时向协调器发送字符串“EndDevice1 received!”(按组网节点数编号）,协调器收到终端节点发回的数据后，通过串口输出到PC机，用户可以通过串口调试助手查看该信息。","text":"实验简介任务6： 协调器周期性以广播的形式向终端节点发送数据（每隔5s广播一次），终端节点接收数据后，使开发板上的LED灯状态翻转，同时向协调器发送字符串“EndDevice1 received!”(按组网节点数编号）,协调器收到终端节点发回的数据后，通过串口输出到PC机，用户可以通过串口调试助手查看该信息。 实验环境 Win10 1909 IAR 10.30 Z-Stack VScode 实验准备1.下载基本工程文件首先下载最基本的工程文件，我们在这个的基础上进行代码修改。 下载地址:https://www.lanzous.com/i7j1gtc 密码:1024 2.打开工程文件解压你第一步下载的基本工程的压缩包，路径是“…\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\Samples\\GenericApp\\CC2530DB”文件夹下的GenericApp.eww。 双击使用最新版IAR打开它。刚打开的时候IAR会多次提示你版本不兼容信息，不必理会，直接一路点击Ok就行。 3.尝试编译上一步完成后，先不改动任何地方。直接点击rebuild图标或者按下F7。也就是下图的箭头指向的图标。 先看是否报错。如果报错，先参考这里【IAR-10.30.1】最新版本IAR常见编译问题总结。 按照这篇博客的方法解决问题即可。 协调器协调器要做的事情只有三个，一个是广播消息，另一个是如果收到终端节点的消息就把消息打印到串口，第三就是同时翻转LED状态。 我们来理清一下思路：当协调器组件网络后就开始发送广播消息。那么我们就在GenericApp_ProcessEvent() 函数里添加ZDO_STATE_CHANGE的case即可。在那个case里我们需要闪烁一个LED，同时设置一个5秒的定时把SEND_TO_ALL_EVENT事件写到任务列表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )&#123; afIncomingMSGPacket_t *MSGpkt; //MSGpkt用于指向接收消息结构体的指针 if ( events &amp; SYS_EVENT_MSG ) &#123; //osal_msg_receive（）从消息队列上接收消息 MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); while ( MSGpkt ) &#123; switch ( MSGpkt-&gt;hdr.event ) &#123; case AF_INCOMING_MSG_CMD: HalLedSet(HAL_LED_2,HAL_LED_MODE_OFF); HalLedBlink(HAL_LED_1,0,50,500); GenericApp_MessageMSGCB( MSGpkt ); break; case ZDO_STATE_CHANGE: //建网后 GenericApp_NwkState=(devStates_t)(MSGpkt-&gt;hdr.status); if(GenericApp_NwkState==DEV_ZB_COORD) &#123; HalLedBlink(HAL_LED_2,0,50,500); //LED2 闪烁 osal_start_timerEx(GenericApp_TaskID,SEND_TO_ALL_EVENT,5000); &#125; break; default: break; &#125; // Release the memory osal_msg_deallocate( (uint8 *)MSGpkt );//接收到的消息处理完后，释放消息所占的存储空间 // Next MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); &#125; // return unprocessed events return (events ^ SYS_EVENT_MSG); &#125; if(events&amp;SEND_TO_ALL_EVENT)//数据发送事件 &#123; GenericApp_SendTheMessage();//每隔5s 向终端节点发送数据函数 osal_start_timerEx(GenericApp_TaskID,SEND_TO_ALL_EVENT,5000); return (events^SEND_TO_ALL_EVENT); &#125; // Discard unknown events return 0;&#125; tips: SEND_TO_ALL_EVENT需要你自己定义一个数值即可。假定协调器发来消息，那么就去了AF_INCOMING_MSG_CMD这个case里，在那里我们需要把LED状态翻转，并通过串口输出到PC，我们可以通过串口调试助手查看该信息。 1234567891011121314//向终端节点发送数据函数void GenericApp_SendTheMessage(void)&#123; unsigned char* theMessageData =\"Coordinator send!\"; afAddrType_t my_DstAddr; my_DstAddr.addrMode=(afAddrMode_t)AddrBroadcast; my_DstAddr.endPoint=GENERICAPP_ENDPOINT; my_DstAddr.addr.shortAddr=0xFFFF; AF_DataRequest(&amp;my_DstAddr,&amp;GenericApp_epDesc, GENERICAPP_CLUSTERID, osal_strlen(theMessageData)+1, theMessageData, &amp;GenericApp_TransID,AF_DISCV_ROUTE,AF_DEFAULT_RADIUS); &#125; 1234567891011//协调器接受到终端节点发送来的数据时void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )&#123; char buf[20]; switch(pkt-&gt;clusterId) &#123; case GENERICAPP_CLUSTERID: osal_memcpy(buf,pkt-&gt;cmd.Data,20); HalUARTWrite(0,buf,20); &#125; &#125; 终端节点终端节点要做的事情也只有三个，一个是接收广播消息，另一个是如果收到协调器的消息就发送“EndDevice1 received!”，第三就是同时翻转LED状态。 我手边目前就一个协调器，一个终端节点。那么就编号为EndDevice1，如果你有很多个终端节点的话，分别编号为EndDevice2，EndDevice3就行了。 思路大概差不多，在GenericApp_ProcessEvent里如果收到消息，就进入AF_INCOMING_MSG_CMD这个case里，在那里我们翻转LED，同时去GenericApp_MessageMSGCB函数发消息给协调器。 参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )&#123; afIncomingMSGPacket_t *MSGpkt; if ( events &amp; SYS_EVENT_MSG ) &#123; MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); while ( MSGpkt ) &#123; switch ( MSGpkt-&gt;hdr.event ) &#123; case AF_INCOMING_MSG_CMD: HalLedSet(HAL_LED_1,HAL_LED_MODE_OFF); GenericApp_MessageMSGCB(MSGpkt); break; case ZDO_STATE_CHANGE: //建网后 GenericApp_NwkState=(devStates_t)(MSGpkt-&gt;hdr.status); HalLedBlink(HAL_LED_1,0,50,500); break; default: break; &#125; // Release the memory osal_msg_deallocate( (uint8 *)MSGpkt ); // Next MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); &#125; // return unprocessed events return (events ^ SYS_EVENT_MSG); &#125; return 0;&#125; 终端节点接收数据进入下面的代码里。这里比对一下消息是不是协调器发来的”Coordinator send!。如果是，那么LED2闪烁，同时去发消息。 12345678910111213141516void GenericApp_MessageMSGCB(afIncomingMSGPacket_t *pkt)&#123; char* recvbuf; switch(pkt-&gt;clusterId) &#123; case GENERICAPP_CLUSTERID: osal_memcpy(recvbuf,pkt-&gt;cmd.Data,osal_strlen(\"Coordinator send!\")+1); if(osal_memcmp(recvbuf,\"Coordinator send!\",osal_strlen(\"Coordinator send!\")+1)) &#123; HalLedBlink(HAL_LED_2,0,50,500); //LED2 闪烁 GenericApp_SendTheMessage(); &#125; break; &#125;&#125; GenericApp_SendTheMessage函数如下： 123456789101112131415void GenericApp_SendTheMessage( void )&#123; unsigned char *theMessageData=\"EndDevice received!\"; afAddrType_t my_DstAddr; my_DstAddr.addrMode=(afAddrMode_t)Addr16Bit;//Addr16Bit表单播 my_DstAddr.endPoint=GENERICAPP_ENDPOINT; //初始化端口 my_DstAddr.addr.shortAddr=0x0000; //协调器地址 AF_DataRequest(&amp;my_DstAddr,&amp;GenericApp_epDesc, GENERICAPP_CLUSTERID, osal_strlen(theMessageData)+1, theMessageData,&amp;GenericApp_TransID, AF_DISCV_ROUTE,AF_DEFAULT_RADIUS); &#125; 烧录代码分别烧录代码，把PC串口线接协调器，然后就可以看到每隔5秒打印的EndDevice1 received! 本次实验在上次实验的基础上稍微修改即可，主要还是思路要清晰。 写在最后的话今天看到一段话，想到我也有过那么几次感同身受。突然有点触动。在这里分享一下。与君共勉。 有时候，我就觉得，人生很奇妙，未来真的没法规划。我特别喜欢深夜，戴着耳机，一个人敲代码，感觉每个代码都是那么优雅，似乎整个世界都是我的。写程序的那段时光，教会了我踏实、谨慎、做事缜密、持续不断的学习劲头，这些特质让我受益终身。 Sometimes, I feel that life is wonderful, and the future is really impossible to plan. I especially like the middle of the night, wearing headphones, coding, and I feel that every code is so elegant, it seems that the whole world is mine. The time when I wrote programs taught me to be practical, cautious, meticulous, and continually learning. I have benefited from these qualities for my life. 需要联系我？如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"【模式识别与人工智能课设】基于CNN的人脸&猫狗分类","slug":"facecnn","date":"2019-11-23T16:00:00.000Z","updated":"2019-11-27T11:57:11.059Z","comments":true,"path":"2019/11/24/facecnn/","link":"","permalink":"https://Stefancharles.xyz/2019/11/24/facecnn/","excerpt":"简介传统方法依赖于人工设计的特征（比如边和纹理描述量）与机器学习技术（比如主成分分析、线性判别分析或支持向量机）的组合。人工设计在无约束环境中对不同变化情况稳健的特征是很困难的，这使得过去的研究者侧重研究针对每种变化类型的专用方法，比如能应对不同年龄的方法不能应对不同姿势的方法，或者不能应对不同光照条件的方法等。深度学习方法的主要优势是它们可用非常大型的数据集进行训练，从而学习到表征这些数据的最佳特征。基于CNN 的人脸识别方法能够学到人脸图像中稳健的特征，从而能够应对在训练过程中使用的人脸图像所呈现出的真实世界变化情况。 虽然说python已经存在很多的cnn框架和api可以调用，这大大简化了我们上手的难度，但是配置环境是令人头疼的问题之一。 下面我做一个简单的入门 python&amp;pycharm 教程。","text":"简介传统方法依赖于人工设计的特征（比如边和纹理描述量）与机器学习技术（比如主成分分析、线性判别分析或支持向量机）的组合。人工设计在无约束环境中对不同变化情况稳健的特征是很困难的，这使得过去的研究者侧重研究针对每种变化类型的专用方法，比如能应对不同年龄的方法不能应对不同姿势的方法，或者不能应对不同光照条件的方法等。深度学习方法的主要优势是它们可用非常大型的数据集进行训练，从而学习到表征这些数据的最佳特征。基于CNN 的人脸识别方法能够学到人脸图像中稳健的特征，从而能够应对在训练过程中使用的人脸图像所呈现出的真实世界变化情况。 虽然说python已经存在很多的cnn框架和api可以调用，这大大简化了我们上手的难度，但是配置环境是令人头疼的问题之一。 下面我做一个简单的入门 python&amp;pycharm 教程。 安装工具1.Pycharm首先我们需要去下载一个ToolBox,它是JB公司官方的软件全家桶管理软件。就是一个下载器。用来下载Pycharm等其他软件非常方便。 点击这里去翻墙下载 如果你打不开上面的网址，那么可以点击下面的链接下载我已经下载好的： 下载:https://www.lanzous.com/i7k3m4b 密码:1024 下载之后，安装。这里不多说。 安装好之后打开。 如上图所示，找到Pycharm Community（社区版，也就是免费版），点击Install。由于上图我已经安装了，所以就没有install显示了。 当然，你也可以选择安装专业版，不过需要收费激活。事实上我们个人进行开发社区版就足够。 2.Python 3.7最新的版本是3.8。但是我实际使用的时候有很多不稳定的地方。所以这里安装3.7比较合适。 点击这里去下载python 网页上可以找到3.7.请选择64位版本。 我这里已经下载了3.7的Windows版本。点击下面的链接就可以下载。如果你的操作系统是其他的话，需要去官网下载。 下载:https://www.lanzous.com/i7k439i 密码:1024 下载后双击安装。 注意：安装的时候请勾选”Add to PATH”！这可以避免你后面自己配置环境变量。 新建一个工程打开安装好的Pycharm。在做左上角点击File。 需要注意的是，每个工程项目都可以选择不同的Interpreter。 按下Ctrl+Alt+s快捷组合键打开Interpreter配置界面。 我选择的都是第一个。这个看个人喜好。如果你用Anaconda的话，也是在这里选择。 导包在界面左上角，File==&gt;New，选择第5个，新建一个python File. 例如我们输入如下代码： 1import numpy as np 这里就需要导入numpy，否则后面就无法使用np.array 等函数。 按下Ctrl+Alt+s快捷组合键打开设置，然后选择Project:XXXX==&gt;Project Interpreter配置界面。 点击+号。 因为默认的源是python官方的网址源，实际下载的时候速度可能不理想。所以最好加入国内的清华源或者阿里源。 点击manage repository。修改源。 点击右边的+号，分别添加下面的链接。只添加其中一个也可以，也可以都添加。 12http://mirrors.aliyun.com/pypi/simple/https://pypi.tuna.tsinghua.edu.cn/simple/ 还有一种导包的方式的就是在代码界面，鼠标移动到pycharm划红线提示的地方，会有提示你install这个package，点击那里也可以安装，但是那个是使用默认的python源，即使你上一步换了源也没用。 多数情况下，在Interpreter里就可以安装你所需要的包了。 语法python很多语法都比C/C++，java等简单很多。具体语法我这里也写不完。个人认为在你入手代码前，去了解一下python的列表和元组。 更多官方教程点击这里 另外，一行python语句结尾不要求分号结尾，换行就行。这很方便，但也导致python对缩进要求较为严格，如果后面你自己对着参考代码写着，结果你的编辑器提示报错，请检查你的代码缩进有没有错误。 基于CNN的人脸分类下面就开始上手，实际上网络上已经有很多实现CNN人脸识别的代码，代码都不是唯一的，实现方式有很多，下面的代码也仅供参考。更多的是思路。 读取图片想要对人脸进行分类，首先得读取人脸图片。 将你要分类的人脸图片放置在你的新建的项目的文件夹下。 123456789101112131415161718192021222324def read_file(path): img_list = [] label_list = [] dir_counter = 0 IMG_SIZE = 100 # 对路径下的所有子文件夹中的所有jpg文件进行读取并存入到一个list中 for child_dir in os.listdir(path): child_path = os.path.join(path, child_dir) for dir_image in os.listdir(child_path): if endwith(dir_image, 'jpg'): img = cv2.imread(os.path.join(child_path, dir_image)) resized_img = cv2.resize(img, (IMG_SIZE, IMG_SIZE)) recolored_img = cv2.cvtColor(resized_img, cv2.COLOR_BGR2GRAY) img_list.append(recolored_img) label_list.append(dir_counter) dir_counter += 1 # 返回的img_list转成了 np.array的格式 img_list = np.array(img_list) return img_list, label_list, dir_counter 这里相当于C++里的函数。函数内容很好理解。输入一个文件路径，对其下的每个文件夹下的图片读取，并对每个文件夹给一个不同的Label。返回一个img的list,返回一个对应label的list,返回一下有几种label。 这里我用到了cv和os的函数，所以需要导入相关的包。 123import osimport cv2import numpy as np 没有正确导包的话，就没法使用os.listdir等函数。 其中endwith是另外的函数。作用是输入一个字符串一个标签，对这个字符串的后续和标签进行匹配 123456def endwith(s, *endstring): resultArray = map(s.endswith, endstring) if True in resultArray: return True else: return False 好了，现在来验证一下能不能正确的读取图片。 123456if __name__ == '__main__': img_list, label_lsit, counter = read_file('D:\\\\py\\\\DeepLeaning\\\\train_imgs') print(counter) print(img_list[1]) print(label_lsit[1]) 当然，python可以不需要一个main函数，可以按照顺序执行。如果写了if name == ‘main‘，那么就从这里开始执行。 路径请输入你的图片的文件夹的绝对路径。 接下来运行。 点击main函数的左边的播放图标。或者鼠标右击任意空白区域。或者快捷键。 输出结果： 12345678910D:\\py\\DeepLeaning\\venv\\Scripts\\python.exe D:/py/DeepLeaning/read_data.py3[[ 70 66 61 ... 122 122 122] [ 71 66 60 ... 122 122 122] [ 69 64 59 ... 122 122 122] ... [ 24 30 34 ... 169 169 169] [ 24 30 34 ... 170 170 170] [ 24 30 34 ... 171 171 171]]0 差不多的话就是上面这样，没有报错说明成功了第一步。 然后下一步处理一下数据集。 123456789101112131415161718def process_data(self, path): # 根据指定路径读取出图片、标签和类别数 imgs, labels, counter = read_file(path) # 随机分组 X_train, X_test, y_train, y_test = train_test_split(imgs, labels, test_size=0.2, random_state=random.randint(0, 100)) # 归一化处理 X_train = X_train.reshape(X_train.shape[0], 1, self.img_size, self.img_size) / 255.0 X_test = X_test.reshape(X_test.shape[0], 1, self.img_size, self.img_size) / 255.0 X_train = X_train.astype('float32') X_test = X_test.astype('float32') # 转化labels Y_train = np_utils.to_categorical(y_train, num_classes=counter) Y_test = np_utils.to_categorical(y_test, num_classes=counter) 建立模型为了方便后面操作。我们把上面处理数据集的process_data函数写到一个DataSet类里。在这个类初始化的过程中读取path下的训练数据。那么我们下次实例化这个类的时候就已经完成了数据读取的工作。 12345678910111213141516171819202122232425262728293031323334class DataSet(object): def __init__(self, path): self.num_classes = None self.X_train = None self.X_test = None self.Y_train = None self.Y_test = None self.img_size = 100 self.process_data(path) def process_data(self, path): # 根据指定路径读取出图片、标签和类别数 imgs, labels, counter = read_file(path) # 随机分组 X_train, X_test, y_train, y_test = train_test_split(imgs, labels, test_size=0.2, random_state=random.randint(0, 100)) X_train = X_train.reshape(X_train.shape[0], 1, self.img_size, self.img_size) / 255.0 X_test = X_test.reshape(X_test.shape[0], 1, self.img_size, self.img_size) / 255.0 X_train = X_train.astype('float32') X_test = X_test.astype('float32') Y_train = np_utils.to_categorical(y_train, num_classes=counter) Y_test = np_utils.to_categorical(y_test, num_classes=counter) self.X_train = X_train self.X_test = X_test self.Y_train = Y_train self.Y_test = Y_test self.num_classes = counter 同样的，我们可以写一个FaceModel类，在类里建立模型，主函数里实例化后使用.来访问成员函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class FaceModel(object): FILE_PATH = \"D:\\py\\DeepLeaning\\modelcat.h5\" IMAGE_SIZE = 100 # 模型接受的人脸图片 def __init__(self): self.model = None # 读取实例化后的DataSet类作为进行训练的数据源 def read_trainData(self, dataset): self.dataset = dataset # 建立CNN模型 def build_model(self): self.model = Sequential() self.model.add( Convolution2D( filters=64, kernel_size=(5, 5), padding='same', dim_ordering='th', input_shape=self.dataset.X_train.shape[1:] ) ) self.model.add(Activation('relu')) self.model.add( MaxPooling2D( pool_size=(2, 2), strides=(2, 2), padding='same' ) ) self.model.add(Convolution2D(filters=128, kernel_size=(5, 5), padding='same')) self.model.add(Activation('relu')) self.model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2), padding='same')) self.model.add(Flatten()) self.model.add(Dense(512)) self.model.add(Activation('relu')) self.model.add(Dense(self.dataset.num_classes)) self.model.add(Activation('sigmoid')) # or softmax self.model.summary() ok,这里就已经完成了模型的建立，上面很多参数可以根据实际情况进行调整。多调整几次，试一试最后哪一种最合适。 开始训练123456def train_model(self): self.model.compile( optimizer='RMSprop', loss='categorical_crossentropy', metrics=['accuracy']) self.model.fit(self.dataset.X_train, self.dataset.Y_train, epochs=15, batch_size=50) optimizer还有RMSprop, Adagrad等可以选择，loss也可以调整。epochs为训练多少轮、batch_size为每次训练多少个样本。这里也不是说一定epochs越大越好，有可能过拟合，数据样本太小的情况下，会有出现后面100%的测试准确率，那就没什么意义。 评估模型123456def evaluate_model(self): print('\\nEvaluate model...') loss, accuracy = self.model.evaluate(self.dataset.X_test, self.dataset.Y_test) print('Evaluate loss;', loss) print('Evaluate accuracy:', accuracy) 保存和读取模型123def save(self, file_path=FILE_PATH): print('Saving...') self.model.save(file_path) 1234def load(self, file_path=FILE_PATH): print('Loading...') self.model = load_model(file_path) 测试模型1result = self.model.predict_proba(img) 这里返回的是img属于某个label的概率。在这里写一个for循环遍历测试集的图片即可。最后可以用正确预测的数目除以总的测试集数量得出准确率。 主函数首先实例化dataset。 12if __name__ == '__main__': datasets = DataSet('D:\\\\py\\\\DeepLeaning\\\\data\\\\train') 此时已经根据绝对路径读取了img和label列表。 然后实例化FaceModel类。 12model = FaceModel()model.read_trainData(datasets) 这里读取实例化后的DataSet类datasets作为进行训练的数据来源。 然后分别调用上面写好的函数即可。 123model.build_model()model.train_model()model.evaluate_model() 人脸分类结果 猫狗分类结果 有时间将不定期更新本文 需要联系我？请发邮件 我的邮箱：stefancharles@vip.qq.com","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"https://Stefancharles.xyz/tags/CNN/"}]},{"title":"【Zigbee】终端节点采集温度与协调器通信实验","slug":"UarttoPC","date":"2019-11-22T16:00:00.000Z","updated":"2019-11-23T14:46:38.994Z","comments":true,"path":"2019/11/23/UarttoPC/","link":"","permalink":"https://Stefancharles.xyz/2019/11/23/UarttoPC/","excerpt":"实验简介两个节点的通信，A为协调器，B为终端节点，终端节点采集到温度信息，发送给协调器，我们通过串口助手可以观察到协调器接收到终端节点的温度信息。","text":"实验简介两个节点的通信，A为协调器，B为终端节点，终端节点采集到温度信息，发送给协调器，我们通过串口助手可以观察到协调器接收到终端节点的温度信息。 实验环境 IAR v10.30.1 Win10 1909 串口调试助手 v4.13.3 实验准备1.下载基本工程文件首先下载最基本的工程文件，我们在这个的基础上进行代码修改。 下载地址:https://www.lanzous.com/i7j1gtc 密码:1024 2.下载最新版IAR点击这里去官网下载最新版。找到“Downlaod”字样进行下载。 3.打开工程文件解压你第一步下载的基本工程的压缩包，路径是“…\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\Samples\\GenericApp\\CC2530DB”文件夹下的GenericApp.eww。 双击使用最新版IAR打开它。刚打开的时候IAR会多次提示你版本不兼容信息，不必理会，直接一路点击Ok就行。 4.尝试编译上一步完成后，先不改动任何地方。直接点击rebuild图标或者按下F7。也就是下图的箭头指向的图标。 先看是否报错。如果报错，先参考这里【IAR-10.30.1】最新版本IAR常见编译问题总结。 按照上一篇博客的方法解决问题即可。 终端节点终端节点就做两件事。一个是采集温度，一个是发送消息给协调器。 1.采集温度采集温度有两种方式，一种是使用片内温度，另一种是使用DHT11，前者误差较大，但是很方便；后者数据精确，但是代码部分较麻烦。 片内温度在IAR中打开Enddevice.c。我们在这里加入一个获取片内温度的函数供我们后面调用。 参考代码 12345678910111213141516171819//获取片内温度unsigned int getTemperature(void)&#123; char i; unsigned int AdcValue; int value; for(i=0;i&lt;4;i++) &#123; ADCCON3|=0x3E; ADCCON1|=0x40;//使用1.25V内部电压 while (!(ADCCON1&amp;0x80)); value=ADCL&gt;&gt;2; value|=((unsigned int )ADCH&lt;&lt;6); AdcValue+=value; &#125; value=AdcValue&gt;&gt;2; return (unsigned int )(value*0.0629-303.3);&#125; 最好先在最开头声明这个函数，然后随意在一个地方实现它就行。 然后看我们应该在Enddevice.c哪里调用上面的函数。 仔细阅读代码不难发现，在UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )函数里都是处理事件发生的函数。 注意到有下面代码： 12345678910if ( events &amp; SEND_DATA_EVENT ) &#123; // Send \"the\" message GenericApp_SendTheMessage(); // Setup to send message again osal_start_timerEx( GenericApp_TaskID,SEND_DATA_EVENT,1000 ); return( events &amp; SEND_DATA_EVENT ); &#125; DHT11采集温度上面使用片内采集温度。如果你不要求精度的话，这里DHT11可以跳过。 众所周知，DHT11采集温度对时序有着严格的要求。之前的一篇博客简略描述了一下DHT11工作时序。 代码实现有很多方式，这里给出一个参考代码。 代码下载地址:https://www.lanzous.com/i7j45pa 密码:1024 把上面的参考代码加入到工程文件。思路很简单，其中，extern uchar humidity_H,humidity_L,temp_H,temp_L分别是湿度和温度发个位和十位，调用DHT11()函数，然后对应存到char数组里再发送即可。 问题看似解决了，但是，正如我一开始所说的，众所周知，DHT11采集温度对时序有着严格的要求。 OSAL实现了类似系统一样的调度管理，基于轮询事件驱动的OS。在任意一个确定的时刻，OS都只是单线程的，只能执行一个运算，只是时间片轮转，让OS看起来好像是多线程了。 除此之外，还有单片机的中断。这些都能打断精确的计时任务，也就是说，这种情况下，满足不了DHT11精确的时序，也就获取不到温度了。 解决方案目前有两种，一种是在采集温度前关闭所有中断。另一种是在整个协议栈运行起来之前获取温度。 由于多个课程设计等时间原因我还没具体做上面的方案。有时间再更新这部分。 有其他方案的欢迎留言讨论。 2.发送消息获取温度后，这里调用了 GenericApp_SendTheMessage()函数来发送消息。那么我们在发送消息前，获取温度，把获取到的温度当作消息发送出去即可。 1234567891011121314151617void GenericApp_SendTheMessage( void )&#123; char strtemp[3]; osal_memset(strtemp, 0, 3); AvgTemp = getTemperature(); strtemp[0]=AvgTemp/10+0x30; strtemp[1]=AvgTemp%10+0x30; strtemp[2]='\\0'; AF_DataRequest( &amp;GenericApp_DstAddr, &amp;GenericApp_epDesc, GENERICAPP_CLUSTERID, (byte)osal_strlen( strtemp ) + 1, (byte *)&amp;strtemp, &amp;GenericApp_TransID, AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) ; &#125; 在这里调用AF_DataRequest()函数发送消息给协调器。 协调器协调器要做的事情也只有两个，一个是接收消息，另一个是把消息打印到串口。 1.接收消息在IAR中打开Coordinator.c。找到void GenericApp_Init( byte task_id )函数里面的： 12//uartConfig.callBackFunc =rxCB;uartConfig.callBackFunc=NULL; 因为我不需要串口的回调函数，所以注释，并指向空。 同样的，我们只需要在UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )函数里，把消息到来的时候的事件处理函数写完整即可。 12345678910111213141516171819202122232425262728293031UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )&#123; afIncomingMSGPacket_t *MSGpkt; if ( events &amp; SYS_EVENT_MSG ) &#123; MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); while ( MSGpkt ) &#123; switch ( MSGpkt-&gt;hdr.event ) &#123; case AF_INCOMING_MSG_CMD: HalLedBlink(HAL_LED_1,6,50,1000); GenericApp_MessageMSGCB( MSGpkt ); break; default: break; &#125; // Release the memory osal_msg_deallocate( (uint8 *)MSGpkt ); // Next MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID ); &#125; // return unprocessed events return (events ^ SYS_EVENT_MSG); &#125; // Discard unknown events return 0;&#125; 2.向串口发送当有消息过来的时候，进入AF_INCOMING_MSG_CMD的case里，这这里调用GenericApp_MessageMSGCB( MSGpkt )即消息处理函数。 123456789101112131415161718//参考代码void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )&#123;unsigned char buffer[4]=\" \";unsigned char *temp;sprintf(temp,\"Temperature:\");HalUARTWrite(0,temp,13); switch ( pkt-&gt;clusterId )&#123; case GENERICAPP_CLUSTERID: osal_memcpy(buffer,pkt-&gt;cmd.Data, 3); HalUARTWrite(0,buffer,4); osal_memset(buffer,0,4); break; default: break;&#125;&#125; osal_memcpy(buffer,pkt-&gt;cmd.Data, 3)是把消息中的数据复制到buffer里。这里HalUARTWrite()函数是协议栈已经存在的函数，作用是向串口发送信息。 烧录代码出现Get Alternative File 点击“Skip”就行。 说在最后的话好了，完成上面的后，编译，烧录代码。连接串口，打开PC串口助手，应该可以在串口助手里看到协调器发来的消息。不过极有可能接收到是乱的，或者看起来不科学的温度数据。 这也很正常，毕竟这个很不准确。 我相信，正在看这篇文章的你应该可以想到改进的方法。我抛砖引玉的工作就到这里暂时结束，还有诸多课程设计等待我去完成，有缘下期见。 需要联系我？请发邮件 我的邮箱：stefancharles@vip.qq.com","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"【IAR-10.30.1】最新版本IAR常见编译问题总结","slug":"IARproblem","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-23T14:44:58.661Z","comments":true,"path":"2019/11/21/IARproblem/","link":"","permalink":"https://Stefancharles.xyz/2019/11/21/IARproblem/","excerpt":"简介近期，老师经常使用旧版本协议栈布置作业，但是我使用的是最新版本的IAR，导致打开工程的时候，编译的时候总有莫名奇妙的版本兼容问题。 所以本篇博客总结一些IAR编译旧版本工程报错以及解决方案。 有不对的地方还请指正，感激不尽。","text":"简介近期，老师经常使用旧版本协议栈布置作业，但是我使用的是最新版本的IAR，导致打开工程的时候，编译的时候总有莫名奇妙的版本兼容问题。 所以本篇博客总结一些IAR编译旧版本工程报错以及解决方案。 有不对的地方还请指正，感激不尽。 系统环境 Win10 1909 IAR 10.30.1 Z-Stack VScode 1.Error[e16]: Segment RAM_CODE_FLASH12Error[e16]: Segment RAM_CODE_FLASH (size: 0x27 align: 0) is too long for segment definition. At least 0x4 more bytes needed. The problem occurred while processing the segment placement command &quot;-Z(CODE)RAM_CODE_FLASH=_RAM_CODE_FLASH_START-_RAM_CODE_FLASH_END&quot;, where at the moment of placement the available memory ranges were &quot;CODE:39edd-39eff&quot; 根据报错，RAM_CODE_FLASH需要再扩大至少4个字节。 所以打开Tool里面的f8w2530.xcl文件，将RAM_CODE_FLASH_END的值再增大至少0x04. 在f8w2530.xcl的第226行左右 123456-D_RAM_CODE_XDATA_START=0x01EDD-D_RAM_CODE_XDATA_END=(_RAM_CODE_XDATA_START+0x22)-Z(XDATA)RAM_CODE_XDATA=_RAM_CODE_XDATA_START-_RAM_CODE_XDATA_END//-D_RAM_CODE_FLASH_START=0x39EDD-D_RAM_CODE_FLASH_END=(_RAM_CODE_FLASH_START+0x26)//这里原本是+0x22 修改之后，点击rebuild。应该不会再有这个错误。但是一般来说，可能还会遇到下面的错误。 2.Error[e46]: Undefined external “?V1” referred in AF这个问题可以参考 这个连接 。里面解决了这个问题。 不过，还是简单翻译一下： 需要添加一个workaround.s51 文件加到工程里。注意，这个文件的后缀名就是.s51,不是.c或者其他。请务必保存为正确的后缀名。 我是加到了E:\\StudyMaterial2019\\URAT\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\ZMain\\TI2530DB目录下，注意要在工程里该目录右击“add file … ”，添加你新建的这个文件进去。 然后再次rebuild后，原来的问题没有了， workaround.s51文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208;----------------------------------------------------------------;; Virtual registers ;; ================= ;; Below is some segment needed for the IAR ICC C/EC++ compiler ;; ;; BREG : A segment for 8 bit registers for use by the compiler. ;; ?B0 is the first register. ;; VREG : Segment that holds up to 32 virtual registers for ;; use by the compiler. ?V0 is the first register. ;; PSP : Segment containing the PDATA stack pointer (?PSP) ;; XSP : Segment containing the XDATA stack pointer (?XSP) ;; ;;----------------------------------------------------------------;;----------------------------------------------------------------; PROGRAM VIRTUAL_REGISTERS PUBLIC ?B0 PUBLIC ?V0 PUBLIC ?V1 PUBLIC ?V2 PUBLIC ?V3 PUBLIC ?V4 PUBLIC ?V5 PUBLIC ?V6 PUBLIC ?V7 PUBLIC ?V8 PUBLIC ?V9 PUBLIC ?V10 PUBLIC ?V11 PUBLIC ?V12 PUBLIC ?V13 PUBLIC ?V14 PUBLIC ?V15 PUBLIC ?V16 PUBLIC ?V17 PUBLIC ?V18 PUBLIC ?V19 PUBLIC ?V20 PUBLIC ?V21 PUBLIC ?V22 PUBLIC ?V23 PUBLIC ?V24 PUBLIC ?V25 PUBLIC ?V26 PUBLIC ?V27 PUBLIC ?V28 PUBLIC ?V29 PUBLIC ?V30 PUBLIC ?V31 PUBLIC ?PSP PUBLIC ?XSP RSEG BREG:BIT:NOROOT?B0: DS 8 RSEG VREG:DATA:NOROOT?V0: DS 1?V1: DS 1?V2: DS 1?V3: DS 1?V4: DS 1?V5: DS 1?V6: DS 1?V7: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V7?V8: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V8?V9: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V9?V10: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V10?V11: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V11?V12: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V12?V13: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V13?V14: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V14?V15: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V15?V16: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V16?V17: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V17?V18: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V18?V19: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V19?V20: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V20?V21: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V21?V22: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V22?V23: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V23?V24: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V24?V25: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V25?V26: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V26?V27: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V27?V28: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V28?V29: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V29?V30: DS 1 RSEG VREG:DATA:NOROOT REQUIRE ?V30?V31: DS 1 RSEG PSP:DATA:NOROOT EXTERN ?RESET_PSP REQUIRE ?RESET_PSP?PSP: DS 1 RSEG XSP:DATA:NOROOT EXTERN ?RESET_XSP REQUIRE ?RESET_XSP?XSP: DS 2 ENDMOD ; VIRTUAL_REGISTERS END 3.Error[e16]: Segment ISTACK (size: 0xc0 align: 0) is too long for segment definition.1Error[e16]: Segment ISTACK (size: 0xc0 align: 0) is too long for segment definition. At least 0xe more bytes needed. The problem occurred while processing the segment placement command 还是打开Tool里面的f8w2530.xcl文件。找到“-Z(DATA)VREG+_NR_OF_VIRTUAL_REGISTERS=08-7F”，修改成“-Z(DATA)VREG=08-7F” 即可。 4.function “XXXX” has no prototype …\\Texas Instruments\\ZStack-CC2530-2.3.0-1.4.0\\Projects\\zstack\\Samples\\GenericApp\\CC2530DB\\XXX.c解决方法：点击顶部菜单栏的Project,找到options。或者按ALT＋F7，打开选项菜单。 把C/C++ Compiler 里面的Require prototypes取消即可。 好了，今天就到这里，后面我遇到问题再更新本博客内容吧。有缘再见。 需要联系我？如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。","categories":[{"name":"教程","slug":"教程","permalink":"https://Stefancharles.xyz/categories/教程/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"},{"name":"IAR","slug":"IAR","permalink":"https://Stefancharles.xyz/tags/IAR/"}]},{"title":"HyperLPR字符分割","slug":"hyperlpr","date":"2019-11-19T16:00:00.000Z","updated":"2019-11-20T13:38:10.987Z","comments":true,"path":"2019/11/20/hyperlpr/","link":"","permalink":"https://Stefancharles.xyz/2019/11/20/hyperlpr/","excerpt":"HyperLPR字符分割内容主要介绍 字符分割 HyperLPR中的字符分割方法 字符分割模型的训练 转换到Caffemodel模型[待续]","text":"HyperLPR字符分割内容主要介绍 字符分割 HyperLPR中的字符分割方法 字符分割模型的训练 转换到Caffemodel模型[待续] 字符分割字符分割是OCR中非常重要的部分。在讲字符分割之前，简要介绍一下传统OCR所采用的Pipline(当然现在目前大多数据商用的文档OCR解决方案也基本都是基于这种方法)。 文档分析(提取文档区域，包括了文档的校正等操作) 行分割 字符分割 字符识别 重新排版 上列的每一条pipline几乎都决定了OCR系统最后的输出质量。其中字符切割也是OCR中非常重要的组成部分，也是决定OCR系统好坏的比较重要决定因素。 下面介绍几种字符分割方法: 1.基于联通域 基于联通域的分割方法较为简单，影响其效果的主要在在于二值化算法上。本文不再做过多概述，但这种方法在处理非联通字符的过程中往往不能达到良好的效果，所以在应用的过程中往往要结合分类器,概率链等手段来提高效果。 2.基于投影直方图 投影直方图是一种很重要的方法，他的思想是去找投影直方图上的极小值点作为分割点，都是在复杂场景的OCR过程中例如手写字符中不是特别理想。 3.基于滑动窗口 这里介绍一篇较为经典的论文(End-to-end text recognition with convolutional neural networks)在Cousera上Andrew Ng的Machine Learning课程中也提到了这种方法。在OpenCV的text模块中也有对应的实现。 它的主要思想是利用一个训练好的正负样本分类器来进行在图像上滑动然后产生概率response图，然后对raw response进行nms(非极大值抑制)。在确定字符bdbox,数目之后使用类似于viterbi算法来获取最佳分割路径。 4.基于过分割 很多商业的OCR系统中采用此方法来进行字符分割，其主要的思想类似于object detection中的 region proposal. 先通过投影直方图等方法产生一系列候选的分割点，然后字符使用分类器对车型候选的分割点的不同组合进行分类，产生分割图。最后使用beamsearch,动态规划等方法找到图中的最佳分割路径。在Tesseract中也使用了这种方法来分割字符。 HyperLPR中的字符分割方法HyperLPR中使用的字符分割方法很简单.同样也是基于滑动窗口的分割方法。首先我们训练一个分类器输出三种概率分别为正样本、负样本、中文字符。 接着我们对车牌做滑动输出每个位置的三种字符概率（这个滑动的窗口的stride可以设高一点使得速度更快）接着我们对这三种利用车牌的模板进行匹配。使得第一个字符的中文概率+后6个字符的正样本概率最大。这个最大的位置即为最佳分割位置。 字符分割模型的训练训练只需提供三种样本 在config.txt定义三种样本的目录 123../character_judgement_samples/T #正样本 正样本指样本图片的中心有文字../character_judgement_samples/F #负样本 负样本指样本图片的中心无文字,左右两侧有也没有关系../character_judgement_samples/CH #中文样本 正样本指样本图片的中心有中文文字 下面提供了三种样本的图例负样本 中文样本 正样本 开始训练1python training_segmentation.py 转载自原文地址：https://github.com/zeusees/HyperLPR-Training","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"HyperLPR","slug":"HyperLPR","permalink":"https://Stefancharles.xyz/tags/HyperLPR/"}]},{"title":"【ZigBee】数据传输实验及协议栈的启动过程具体实现","slug":"zigbeedatasend","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-19T12:10:11.997Z","comments":true,"path":"2019/11/19/zigbeedatasend/","link":"","permalink":"https://Stefancharles.xyz/2019/11/19/zigbeedatasend/","excerpt":"实验简介感性认识数据传输实验，观察老师提供的代码的实验现象，在此基础上，在实验报告中阐述清楚协议栈的启动过程及数据收发的具体实现。","text":"实验简介感性认识数据传输实验，观察老师提供的代码的实验现象，在此基础上，在实验报告中阐述清楚协议栈的启动过程及数据收发的具体实现。 实验环境 Win10 1909 IAR 10.30 Z-Stack VScode 准备工作一开始我打算使用最新版本的3.0.2协议栈中的SampleLight工程，这里面有协调器按键控制终端节点的LED灯的亮灭，按下Lighting设备的按键，则能对本地的Led进行亮灭控制。 但是，我看了很久后，发现了一些东西导致我暂时放弃了魔改3.0.2这个版本的想法。 Zigbee3.0 较先前的版本对设备的行为做了更多的规范，增加了很多功能。代码中通过使用一个3级目录菜单UI来实现对各个功能的。 菜单 功能描述 A级菜单 功能菜单 B级菜单 commissioning、网络等参数配置菜单 C级菜单 installCode配置菜单 这需要5个按键完成操作： 按键 功能描述 左/右按键 菜单切换方向键 上/下按键 编辑按键 中间按键 确认键，即【OK】 虽然这很方便，但是一个比较现实的问题是我目前手里的开发板没有LCD屏以及较多的按键。 如果有上图这样的设备就可以完美进行这个实验了。 但是限于实验设备，所以如果要使用3.0.2的协议栈的这个工程的话，需要进行一些魔改。 后面如果有时间再魔改这个吧。下面就使用老师给的旧版本的进行本次实验。 实验过程首先打开老师给的代码的工程文件，由于IAR版本较新，一开始会弹出很多不兼容的提示，没有关系，一直点OK下去就行。 然后尝试编译一下，显然是不行的。提示链接出错。 如上图，点击option，重新配置一下。 需要配置设备和linker里的内容。配置过程和你第一次新建一个工程是一样的，这里不再赘述。 配置好后，再编译，就没有错误了。 接下来的操作就按照老师的注释进行操作即可。 1234567第一步： 找到下面内容，把appLight(); 注释掉，下载到发射模块。 appSwitch(); //节点为按键S1 P1_2 // appLight(); //节点为指示灯LED1 P1_0第二步：找到相同位置，这次把appSwitch();注释掉，下载到接收模块。 //appSwitch(); //节点为按键S1 P0_4 appLight(); //节点为指示灯LED1 P1_0 加入串口稍微不同的是，我加了之前串口的代码。这样连接电脑的串口助手，讲道理是可以查看收到的数据。首先是之前我们写过的串口实验代码： 1234567891011121314151617181920212223242526272829void initUART0()&#123; CLKCONCMD &amp;= ~0x40;//设置系统时钟源32MHz晶振 while(CLKCONSTA&amp;0x40);//等待晶振稳定 CLKCONCMD&amp;=~0x47;//设置系统主时钟频率32MHz PERCFG= 0x00;//位置1P0口 P0SEL=0x3C;//P0口是串口 P2DIR&amp;=~0xC0;//P0优先作为UART0 U0CSR|=0x80;//串口设置为UART方式 U0GCR|=9; U0BAUD|=59;//波特率19200 UTX0IF=1;//UART0 TX中断标志初始为1 U0CSR|=0x40;//允许接受 IEN0|=0x84;//开总中断，接受中断&#125;void Send_String(unsigned char *Data, int len)&#123; unsigned int j; for(j=0;j&lt;len;j++) &#123; U0DBUF=*Data++; while (UTX0IF==0); UTX0IF=0; &#125;&#125; 在appLight函数里添加： 123456789if(basicRfReceive(pRxData, APP_PAYLOAD_LENGTH, NULL)&gt;0)&#123; if(pRxData[0] == LIGHT_TOGGLE_CMD) &#123; Send_String(\"Change LED\",10); //Send_String(pRxData,1); halLedToggle(1); &#125;&#125; 好了，接下来分别烧录，连接串口助手，按下Switch的开发板按键，串口线接appLight开发板： 注意：这里想打印出pRxData里的内容的话，需要转换一下类型才可以。 实验现象视频： 点击这里去看实验现象视频 zigbee协议栈Zigbee协议栈简介协议是一系列的通信标准，通信双方需要按照这一标准进行正常的数据发射和接收。协议栈是协议的具体实现形式，协议栈就是协议和用户之间的一个接口，开发人员通过使用协议栈来使用这个协议，实现无线数据收发。Zigbee协议分为两部分，IEEE 802.15.4定义了PHY（物理层）和MAC（介质访问层）技术规范；Zigbee联盟定义了NWK（网络层）、APS（应用程序支持层）、APL（应用层）技术规范。Zigbee协议栈就是将各个层定义的协议都集合在一起，以函数的形式实现，并给用户提供API（应用层），用户可以直接调用。 Zigbee协议栈启动过程下面我以3.0.2的协议栈为示例，描述协议栈启动过程： 协议栈由ZMain里的ZMain.c中的main函数开始执行。main函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int main( void )&#123; // Turn off interrupts osal_int_disable( INTS_ALL ); // Initialization for board related stuff such as LEDs HAL_BOARD_INIT(); // Make sure supply voltage is high enough to run zmain_vdd_check(); // Initialize board I/O InitBoard( OB_COLD ); // Initialze HAL drivers HalDriverInit(); // Initialize NV System osal_nv_init( NULL ); // Initialize the MAC ZMacInit(); // Determine the extended address zmain_ext_addr();#if defined ZCL_KEY_ESTABLISH // Initialize the Certicom certificate information. zmain_cert_init();#endif // Initialize basic NV items zgInit();#ifndef NONWK // Since the AF isn't a task, call it's initialization routine afInit();#endif // Initialize the operating system osal_init_system(); // Allow interrupts osal_int_enable( INTS_ALL ); // Final board initialization InitBoard( OB_READY ); // Display information about this device zmain_dev_info(); /* Display the device info on the LCD */#ifdef LCD_SUPPORTED zmain_lcd_init();#endif#ifdef WDT_IN_PM1 /* If WDT is used, this is a good place to enable it. */ WatchDogEnable( WDTIMX );#endif osal_start_system(); // No Return from here return 0; // Shouldn't get here.&#125; // main() main函数共做了两件事： 1.系统初始化 执行 osal_start_system()，进行轮询式操作系统。 在osal_start_system函数之前的那些函数都是对板载硬件以及协议栈进行的初始化。调用“osal_start_system();”函数之后，整个协议栈系统就算是真正运行起来了。这个函数是TI封装的OSAL操作系统抽象层。OSAL(Operating System Abstraction Layer)，译为“操作系统抽象层”，OSAL就是以实现多任务为核心的系统资源管理机制。但OSAL与标准的操作系统还是有很大的区别。这个并不是并不是真正意义上的操作系统。 对OSAL有兴趣的同学可以点击这里访问TI的OSAL介绍。 首先，协议栈对任务进行初始化，在上面代码中的osal_init_system()函数里，有osalInitTasks()函数，再进入这个函数，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/********************************************************************* * @fn osalInitTasks * * @brief This function invokes the initialization function for each task. * * @param void * * @return none */void osalInitTasks( void )&#123; uint8 taskID = 0; tasksEvents = (uint16 *)osal_mem_alloc( sizeof( uint16 ) * tasksCnt); osal_memset( tasksEvents, 0, (sizeof( uint16 ) * tasksCnt)); macTaskInit( taskID++ ); nwk_init( taskID++ );#if !defined (DISABLE_GREENPOWER_BASIC_PROXY) &amp;&amp; (ZG_BUILD_RTR_TYPE) gp_Init( taskID++ );#endif Hal_Init( taskID++ );#if defined( MT_TASK ) MT_TaskInit( taskID++ );#endif APS_Init( taskID++ );#if defined ( ZIGBEE_FRAGMENTATION ) APSF_Init( taskID++ );#endif ZDApp_Init( taskID++ );#if defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT ) ZDNwkMgr_Init( taskID++ );#endif // Added to include TouchLink functionality #if defined ( INTER_PAN ) StubAPS_Init( taskID++ ); #endif // Added to include TouchLink initiator functionality #if defined( BDB_TL_INITIATOR ) touchLinkInitiator_Init( taskID++ ); #endif // Added to include TouchLink target functionality #if defined ( BDB_TL_TARGET ) touchLinkTarget_Init( taskID++ ); #endif zcl_Init( taskID++ ); bdb_Init( taskID++ ); zclSampleLight_Init( taskID );&#125; 看英文注释：“ This function invokes the initialization function for each task.” 意思就是说，在任务初始化为每一层分配一个任务ID号，这个ID和事件处理函数是对应的，成映射。每增加一个任务ID++，ID越小表示该任务优先级越高。 回到osal_start_system函数中： 1234567891011121314151617181920212223242526272829303132333435363738/********************************************************************* * @fn osal_start_system * * @brief * * This function is the main loop function of the task system (if * ZBIT and UBIT are not defined). This Function doesn't return. * * @param void * * @return none */void osal_start_system( void )&#123;#ifdef USE_ICALL /* Kick off timer service in order to allocate resources upfront. * The first timeout is required to schedule next OSAL timer event * as well. */ ICall_Errno errno = ICall_setTimer(1, osal_msec_timer_cback, (void *) osal_msec_timer_seq, &amp;osal_timerid_msec_timer); if (errno != ICALL_ERRNO_SUCCESS) &#123; ICall_abort(); &#125;#endif /* USE_ICALL */#if !defined ( ZBIT ) &amp;&amp; !defined ( UBIT ) for(;;) // Forever Loop#endif &#123; osal_run_system();#ifdef USE_ICALL ICall_wait(ICALL_TIMEOUT_FOREVER);#endif /* USE_ICALL */ &#125;&#125; 在检查没有错误后，会进入一个Forever Loop，不断调用osal_run_system()函数。 下面是osal_run_system()函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/********************************************************************* * @fn osal_run_system * * @brief * * This function will make one pass through the OSAL taskEvents table * and call the task_event_processor() function for the first task that * is found with at least one event pending. If there are no pending * events (all tasks), this function puts the processor into Sleep. * * @param void * * @return none */void osal_run_system( void )&#123; uint8 idx = 0;#ifdef USE_ICALL uint32 next_timeout_prior = osal_next_timeout();#else /* USE_ICALL */#ifndef HAL_BOARD_CC2538 osalTimeUpdate();#endif Hal_ProcessPoll();#endif /* USE_ICALL */#ifdef USE_ICALL &#123; /* Update osal timers to the latest before running any OSAL processes * regardless of wakeup callback from ICall because OSAL timers are added * relative to the current time. */ unsigned long newtimestamp = ICall_getTicks(); uint32 milliseconds; if (osal_tickperiod == 1000) &#123; milliseconds = newtimestamp - osal_last_timestamp; osal_last_timestamp = newtimestamp; &#125; else &#123; unsigned long long delta = (unsigned long long) ((newtimestamp - osal_last_timestamp) &amp; 0xfffffffful); delta *= osal_tickperiod; delta /= 1000; milliseconds = (uint32) delta; osal_last_timestamp += (uint32) (delta * 1000 / osal_tickperiod); &#125; osalAdjustTimer(milliseconds); /* Set a value that will never match osal_next_timeout() * return value so that the next time can be scheduled. */ next_timeout_prior = 0xfffffffful; &#125; if (osal_eventloop_hook) &#123; osal_eventloop_hook(); &#125; for (;;) &#123; void *msg; ICall_EntityID src, dst; osal_msg_hdr_t *hdr; uint8 dest_id; if (ICall_fetchMsg(&amp;src, &amp;dst, &amp;msg) != ICALL_ERRNO_SUCCESS) &#123; break; &#125; hdr = (osal_msg_hdr_t *) msg - 1; dest_id = osal_dispatch2id(dst); if (dest_id == TASK_NO_TASK) &#123; /* Something wrong */ ICall_abort(); &#125; else &#123; /* Message towards one of the tasks */ /* Create a proxy task ID if necessary and * queue the message to the OSAL internal queue. */ uint8 proxyid = osal_alien2proxy(hdr-&gt;srcentity); if (hdr-&gt;format == ICALL_MSG_FORMAT_1ST_CHAR_TASK_ID) &#123; uint8 *bytes = msg; *bytes = proxyid; &#125; else if (hdr-&gt;format == ICALL_MSG_FORMAT_3RD_CHAR_TASK_ID) &#123; uint8 *bytes = msg; bytes[2] = proxyid; &#125; /* now queue the message to the OSAL queue */ osal_msg_send(dest_id, msg); &#125; &#125;#endif /* USE_ICALL */ do &#123; if (tasksEvents[idx]) // Task is highest priority that is ready. &#123; break; &#125; &#125; while (++idx &lt; tasksCnt); if (idx &lt; tasksCnt) &#123; uint16 events; halIntState_t intState; HAL_ENTER_CRITICAL_SECTION(intState); events = tasksEvents[idx]; tasksEvents[idx] = 0; // Clear the Events for this task. HAL_EXIT_CRITICAL_SECTION(intState); activeTaskID = idx; events = (tasksArr[idx])( idx, events ); activeTaskID = TASK_NO_TASK; HAL_ENTER_CRITICAL_SECTION(intState); tasksEvents[idx] |= events; // Add back unprocessed events to the current task. HAL_EXIT_CRITICAL_SECTION(intState); &#125;#if defined( POWER_SAVING ) &amp;&amp; !defined(USE_ICALL) else // Complete pass through all task events with no activity? &#123; osal_pwrmgr_powerconserve(); // Put the processor/system into sleep &#125;#endif /* Yield in case cooperative scheduling is being used. */#if defined (configUSE_PREEMPTION) &amp;&amp; (configUSE_PREEMPTION == 0) &#123; osal_task_yield(); &#125;#endif#if defined USE_ICALL /* Note that scheduling wakeup at this point instead of * scheduling it upon ever OSAL start timer request, * would only work if OSAL start timer call is made * from OSAL tasks, but not from either ISR or * non-OSAL application thread. * In case, OSAL start timer is called from non-OSAL * task, the scheduling should be part of OSAL_Timers * module. * Such a change to OSAL_Timers module was not made * in order not to diverge the OSAL implementations * too drastically between pure OSAL solution vs. * OSAL upon service dispatcher (RTOS). * TODO: reconsider the above statement. */ &#123; halIntState_t intState; uint32 next_timeout_post = osal_next_timeout(); if (next_timeout_post != next_timeout_prior) &#123; /* Next wakeup time has to be scheduled */ if (next_timeout_post == 0) &#123; /* No timer. Set time to the max */ next_timeout_post = OSAL_TIMERS_MAX_TIMEOUT; &#125; if (next_timeout_post &gt; osal_max_msecs) &#123; next_timeout_post = osal_max_msecs; &#125; /* Restart timer */ HAL_ENTER_CRITICAL_SECTION(intState); ICall_stopTimer(osal_timerid_msec_timer); ICall_setTimerMSecs(next_timeout_post, osal_msec_timer_cback, (void *) (++osal_msec_timer_seq), &amp;osal_timerid_msec_timer); HAL_EXIT_CRITICAL_SECTION(intState); &#125; &#125;#endif /* USE_ICALL */&#125; 函数前面的注释大致内容是：这个函数的功能是查询事件表，如果有事件发生，就查找函数表，找到相应的事件处理函数进行处理；如果没有事件发生，系统将进入休眠模式，降低功耗，要进入休眠模式，还需要打开相应的宏开关进而开启低功耗功能。 触发事件主要有三种情况： 外部中断 定时器 对设备轮询 前两个不需要干涉，如下图： 所以在循环中调用 Hal_ProcessPoll()对串口进行轮询。如果这些设备需要处理，就去tasksEvents[]里找对应的事件处理函数的指针来调用。 事件和任务的事件处理函数式如何联系起来其实这里设计得很巧妙。 建立一个事件表，保存各个任务对应的事件，建立一个函数表，保存各个任务事件处理函数的地址，建立一个映射关系，有某个事件发生就去调用事件处理函数去处理， 这个的关键在于tasksArr[] 数组中每个元素的类型是函数指针。执行完事件处理函数之后，再将未处理的事件返回，事件处理函数的返回值保存了未处理的事件，将未处理的事件再次存放到事件表中，下次进行处理。 执行OSAL的函数就是个大循环，不断取出当前优先级最高的待处理事件进行处理，处理的核心思想在osal_run_task函数内：通过调用一个函数指针来远程调用一个事件处理函数。 数据收发的具体实现当子设备(终端节点或路由器)加入协调器的网络后，它们之间便可以相互通信了。Zigbee设备通信的实质是Zigbee设备端口与另一个Zigbee设备端口之间的通信。只要知道目标设备的网络地址和端口号就可以调用数据发送函数AF_DataRequest() 发送数据给目标设备的端口，再由该端口绑定的任务来处理该数据。 一般步骤为： 组网：调用协议栈组网函数、加入网络函数，实现网络的建立和节点的加入 发送：发送节点调用协议栈的发送函数，实现数据无线发送 接收：接收节点调用协议栈的无线接收函数，实现无线数据接收 组网这里主要是对网络参数进行设置。 协议栈规范设置对于协议栈规范，在同一个网络中必须符合同一个协议栈规范。ZigBee协议栈2007定义了两个规范：ZigBee和ZigBee PRO。在默认情况下，Z-Stack的STACK_PROFILE_ID为ZIGBEEPRO_PROFILE,因为ZigBee PRO有较好的通信性能和稳定性，所以默认为此。 拓扑结构Nwk_globals.h中三个宏定义对应ZigBee网络的三种网络拓扑，选择默认即可。 逻辑设备类型在Zigbee无线传感器网络中有三种设备类型：协调器、路由器和终端节点。在星状网络拓扑结构中，没有路由器这种逻辑设备类型。 PANID和信道的选择PANID:16位的网络ID用来标识唯一一个ZigBee网络，主要用于区分同一地区同一信道的网络，使得同一地区可以存在多个ZigBee网络。信道选择在Tools目录下的f8wConfig.cfg中。 发送在TI官网有给出API文档，关于数据发送有AF_DataRequest()函数，只需要调用这个函数就可以完成数据的发送。每个参数代表什么意思在文档里描述得很详细。参照文档调用即可。 在代码的位置如下图： 但是在无线点灯的具体实现中，数据的发送是创建一个buffer，把payload放进去，调用basicRfSendPacket()发送，并查看其返回值。 作用是向目的地址发送指定长度的数据，成功时返回SUCCESS，失败时返回FAILED 接收接收这边复杂一点。在示例中，上层通过basicRfPacketIsReady()检测是否收到一个新数据包，如果准备好新数据包时返回TRUE调用basicRfReceive()把收到的数据复制到缓冲区中。 uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)：函数的作用是接收来自Basic RF层的数据包，并为数据和RSSI分配缓冲区。具体如下： 12345678910111213141516171819202122232425262728293031323334/*********************************************************************************** @fn basicRfReceive** @brief Copies the payload of the last incoming packet into a buffer** @param pRxData - pointer to data buffer to fill. This buffer must be* allocated by higher layer.* len - Number of bytes to read in to buffer* rxi - file scope variable holding the information of the last* incoming packet** @return uint8 - number of bytes actually copied into buffer*/uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)&#123; // Accessing shared variables -&gt; this is a critical region // Critical region start halIntOff(); memcpy(pRxData, rxi.pPayload, min(rxi.length, len)); if(pRssi != NULL) &#123; if(rxi.rssi &lt; 128)&#123; *pRssi = rxi.rssi - halRfGetRssiOffset(); &#125; else&#123; *pRssi = (rxi.rssi - 256) - halRfGetRssiOffset(); &#125; &#125; rxi.isReady = FALSE; halIntOn(); // Critical region end return min(rxi.length, len);&#125; 总体来看：basic_rf.c中打开了RF接收中断，所以接收端可以接收到射频信号后接收数据 halRfRxInterruptConfig(basicRfRxFrmDoneIsr); basicRfRxFrmDoneIsr是接收到RF数据时的中断服务程序 halRfInit中有使能RF接收中断： halRfEnableRxInterrupt(); 在main中调用了halRfInit()： if(halRfInit()==FAILED) { HAL_ASSERT(FALSE); } 如果对开发板进行抓板应该是可以抓到数据的，下次有时间再更新这部分内容。 好了，今天就到这里，后面有时间再更新本博客内容吧。有缘再见。 需要联系我？如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"keras卷积神经网络对MNIST数据集进行操作","slug":"mnistinkeras","date":"2019-11-17T16:00:00.000Z","updated":"2019-11-18T04:03:37.842Z","comments":true,"path":"2019/11/18/mnistinkeras/","link":"","permalink":"https://Stefancharles.xyz/2019/11/18/mnistinkeras/","excerpt":"简介在上一章中介绍了【TensorFlow】利用MNIST数字识别数据集识别,本篇将介绍keras卷积神经网络对MNIST数据集进行操作。","text":"简介在上一章中介绍了【TensorFlow】利用MNIST数字识别数据集识别,本篇将介绍keras卷积神经网络对MNIST数据集进行操作。 实验环境 Pycharm 2019.3 BETA Win10 1909 Python 3.7.0 Chrome Dev 80.3964.0 使用Colab编辑和运行Python代码按照谷歌官方的介绍： Colaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您可以编写和执行代码、保存和共享分析结果，以及利用强大的计算资源，所有这些都可通过浏览器免费使用。 也就是说可以在线运行python代码，不需要进行麻烦的配置。 点击这里去CoLab 今天我发现官方介绍的强大的计算资源真不是盖的。看来昨天是我冤枉它了。 经过几步简单的设置，就可以使用GPU和TPU进行加速。 我在我自己电脑上跑一个周期需要20秒，在Colab上使用GPU一个周期仅仅需要2秒。 当我用我自己电脑跑时，电脑CPU已经100%负载，此时我做不了其他事情，只能等程序跑完。而在colab上，代码是在google云上跑，自己的电脑只是显示结果，CPU与平时一样，还能做其他工作。 读取MNIST数据1234567891011(x_Train, y_Train), (x_Test, y_Test) = mnist.load_data()# 将features（数字图像特征值）转换成6000 28 28 * 1的4纬矩阵x_Train4D = x_Train.reshape(x_Train.shape[0], 28, 28, 1).astype('float32')x_Test4D = x_Test.reshape(x_Test.shape[0], 28, 28, 1).astype('float32')# 标准化特征值，提高模型精准度x_Train4D_normalize = x_Train4D / 255x_Test4D_normalize = x_Test4D / 255# label数字真实值转换，使用One-Hot Encoding进行转换y_TrainOneHot = np_utils.to_categorical(y_Train)y_TestOneHot = np_utils.to_categorical(y_Test) 这一步在自己电脑上跑时，下载数据集需要翻墙，不翻墙的情况下，下到一会就下载失败。不过在google的colab上跑时，这一步简直飞快。基本上看不到进度条。当你下载过一次后，后面的运行就不会再次下载了。 建立模型建立Sequential模型。序贯模型是函数式模型的简略版，为最简单的线性、从头到尾的结构顺序，不分叉。Sequential模型的基本组件一般需要： 1、model.add，添加层； 2、model.compile,模型训练的BP模式设置； 3、model.fit，模型训练参数设置 + 训练； 4、模型评估 5、模型预测建立卷积层1123456789model = Sequential()model.add(Conv2D(filters=16, kernel_size=(5, 5), padding='same', input_shape=(28, 28, 1), activation='relu'))# 建立16分5*5的滤镜# 输入图像大小为28*28，第一次卷积计算会产生16个图像，卷积层不会改变图像大小，还是28*28 建立池化层112model.add(MaxPooling2D(pool_size=(2, 2)))# 池化层会将图像缩减采样，利用参数pool_size(2,2)将16分28*28的图像缩小为16个14*14的图像 建立卷积层21234model.add(Conv2D(filters=36, kernel_size=(5, 5), padding='same', activation='relu')) 建立池化层212345model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.25))# 第二次采样将14*14的图像缩小为36份7*7的图像# Dropout(0.25)在每次迭代时会随机在神经网络中放弃25%的神经元，避免过度拟合 建立平坦层123456model.add(Flatten())# 将之前建立的池化层2中36个7*7的图像转为一纬的向量，长度为36*7*7=1764个Float数，对应1764个神经元# 建立隐藏层并且把Dropout层加入模型中model.add(Dense(128, activation='relu'))model.add(Dropout(0.5))# 共有128个神经元，每次训练迭代会随机放弃50%的神经元 建立输出层123model.add(Dense(10, activation='softmax'))# 使用softmax激活函数 查看模型摘要1print(model.summary()) 开始训练123456# 使用compile方法进行训练model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])train_history = model.fit(x=x_Train4D_normalize, y=y_TrainOneHot, validation_split=0.2, epochs=10, batch_size=300, verbose=2) 绘制1234567891011121314def show_train_history(train_history, train, validation): plt.plot(train_history.history[train]) plt.plot(train_history.history[validation]) plt.title('Train histoty') plt.ylabel(train) plt.xlabel('Epoch') plt.legend(['train', 'validation', ], loc='upper left') plt.show()# 绘制准确率图show_train_history(train_history, 'acc', 'val_acc')# 绘制误差率图show_train_history(train_history, 'loss', 'val_loss') 本地电脑： colab： 可以看出，colab比我本地快很多 评估模型准确率123# 使用test数据集来进行测试scores = model.evaluate(x_Test4D_normalize, y_TestOneHot)print('The Test sets accuracy is :', scores[1]) 进行预测1predicition = model.predict_classes(x_Test4D_normalize) 说在最后的话总的来说，keras已经写好了读数据，训练，测试等api，我们只需要学会调用就行。 深层的原理还需要仔细研究，后面有时间我研究后单独开几篇博客。 当然这些花里胡哨的东西最终要用于实际，我打算对车牌识别使用这个进行改进。 致谢本次实验参考了很多资料，在此表示感谢。如果有侵权的地方，请联系我：stefancharles@qq.com，我会立刻删除侵权内容。 如果你认为我哪里写得不对，也可以联系我一起讨论。 以下是参考来源。 1.MNIST 数据地址 2.CoLAB CoLab 3.Keras中文官网","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Mnist","slug":"Mnist","permalink":"https://Stefancharles.xyz/tags/Mnist/"},{"name":"Keras","slug":"Keras","permalink":"https://Stefancharles.xyz/tags/Keras/"}]},{"title":"【TensorFlow】MNIST数字识别数据集识别","slug":"mnistinpython","date":"2019-11-16T16:00:00.000Z","updated":"2019-11-18T03:33:45.564Z","comments":true,"path":"2019/11/17/mnistinpython/","link":"","permalink":"https://Stefancharles.xyz/2019/11/17/mnistinpython/","excerpt":"简介在上一章中介绍了基于OpenCV的MNIST手写体SVM分类,本篇将介绍一些使用Python对MNIST数据集进行操作。","text":"简介在上一章中介绍了基于OpenCV的MNIST手写体SVM分类,本篇将介绍一些使用Python对MNIST数据集进行操作。 实验环境 Pycharm 2019.3 BETA Win10 1909 Python 3.7.0 Chrome Dev 80.3964.0 使用Colab编辑和运行Python代码按照谷歌官方的介绍： Colaboratory 是一个免费的 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。借助 Colaboratory，您可以编写和执行代码、保存和共享分析结果，以及利用强大的计算资源，所有这些都可通过浏览器免费使用。 也就是说可以在线运行python代码，不需要进行麻烦的配置。 点击这里去CoLab 今天我发现官方介绍的强大的计算资源真不是盖的。看来昨天是我冤枉它了。 经过几步简单的设置，就可以使用GPU和TPU进行加速。 我在我自己电脑上跑一个周期需要20秒，在Colab上使用GPU一个周期仅仅需要2秒。 当我用我自己电脑跑时，电脑CPU已经100%负载，此时我做不了其他事情，只能等程序跑完。而在colab上，代码是在google云上跑，自己的电脑只是显示结果，CPU与平时一样，还能做其他工作。 下载数据建立TensorFlow程序下载并读取MNIST数据。 12345678mnist = input_data.read_data_sets(\"MNIST_data/\", one_hot=True)print('train', mnist.train.num_examples, ',validation', mnist.validation.num_examples, ',test', mnist.test.num_examples)print('train_images : ', mnist.train.images.shape, ' - labels : ', mnist.train.labels.shape) 运行后，会在你的项目下新建一个MNIST_data文件夹，等待一会后，这个文件夹里会自动多出四个GZ压缩文件。控制台输出： 12train 55000 ,validation 5000 ,test 10000train_images : (55000, 784) - labels : (55000, 10) 查看多项数据images与labels为了后面方便的显示图像与标签，我们这里def一个显示的函数： 12345678910111213141516171819def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 14) if num &gt; 25: num = 25 for i in range(0, num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(np.reshape(images[idx], (28, 28)), cmap='binary') title = \"label=\" + str(np.argmax(labels[idx])) if len(prediction) &gt; 0: title += \",predict=\" + str(prediction[idx]) ax.set_title(title, fontsize=10) ax.set_xticks([]); ax.set_yticks([]) idx += 1 plt.show() 上面默认打印10个。 按批次读取数据12batch_images_xs, batch_labels_ys = mnist.train.next_batch(batch_size=100)print(len(batch_images_xs), len(batch_labels_ys)) 可以调用上面的显示函数进行显示： 12# 显示批次数据plot_images_labels_prediction(batch_images_xs,batch_labels_ys,[],0) 建立多层感知器123456789101112131415161718192021222324252627282930# 定义layer函数，建立2层网络# 以正态分布的随机数建立并初始化W（权重）# 以正态分布的随机数建立b(偏差)def layer(output_dim,input_dim,inputs, activation=None): W = tf.Variable(tf.random_normal([input_dim, output_dim])) b = tf.Variable(tf.random_normal([1, output_dim])) XWb = tf.matmul(inputs, W) + b if activation is None: outputs = XWb else: outputs = activation(XWb) return outputs# 建立输入层，使用placeholder方法建立输入层# 输入数据类型为Float，即浮点数# 第一维设置None，因为后续训练传入图像项数不确定# 第二维维784，输入数字图像是784像素X = tf.placeholder(\"float\",[None,784])# 建立隐藏层# 隐藏层神经元个数为226# 输入层的神经元个数，也就是X=784# 输入层 = X 连接输入层# 定义激活函数为ReLUh1 = layer(output_dim=256,input_dim=784,inputs=X,activation=tf.nn.relu)# 建立输出层# 建立输出层神经元个数为10# 输入神经元个数为隐藏层的个数 h1 = 256# 连接隐藏层# 没有激活函数y_predict = layer(output_dim=10,input_dim=256,inputs=h1,activation=None) 定义训练方法TensorFlow的定义训练方式必须自己定义损失函数的公式、优化器和设置参数，并定义评估模型准确率的公式。 1234567891011# 建立训练数据label真实值的placeholder# 第二位设置为10，因为输入数字真实值已经是使用one-hot转换的值,0~9y_label = tf.placeholder(\"float\",[None,10])# 定义损失函数# 使用cross_entropy()交叉熵训练loss_function = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits=y_predict,labels=y_label))# 定义优化器# 调用tf.train模块，定义optimizer(优化器)# 使用AdaOptimizer并设置learning_rate = 0.001# 优化器使用loss_function计算误差，并且按照误差更新模型权重与偏差，使误差最小化optimizer = tf.train.AdamOptimizer(learning_rate=0.001).minimize(loss_function) 定义评估模型准确率的方法12345678# 首先计算每一项数据是否预测正确# 将运算结果存储在correct_prdiction中# tf.equal判断真实值与测试值是否相等# argmax将one-hot encoding转成数字0~9correct_prdiction = tf.equal(tf.argmax(y_label,1), tf.argmax(y_predict,1))# 计算预测正确结果的平均值# 将tf.cast转换成float，再使用reduce_mean转成所有数平均值accuracy = tf.reduce_mean(tf.cast(correct_prdiction,\"float\")) 进行训练训练数据共55000项，分为每一批次100项，要将所有数据训练完毕后需要执行550批次（55000/100=550），当所有数据训练完毕，成为完成一个训练周期。我们将执行15个训练周期，降低误差，提高准确率。 12345678910111213141516171819202122232425262728293031323334# 定义训练参数# 执行15个训练周期# 每一批次项数为100# loss、epoch、accuracy三个列表分别记录误差、训练周期、准确率# time导入时间模块trainEpochs = 15batchSize = 100totalBatchs = int(mnist.train.num_examples / batchSize)loss_list = []epoch_list = []accuracy_list = []startTime = time()sess = tf.Session()sess.run(tf.global_variables_initializer())# 进行迭代训练for epoch in range(trainEpochs): for i in range(totalBatchs): batch_x, batch_y = mnist.train.next_batch(batchSize) sess.run(optimizer, feed_dict=&#123;X: batch_x, y_label: batch_y&#125;) loss, acc = sess.run([loss_function, accuracy], feed_dict=&#123;X: mnist.validation.images, y_label: mnist.validation.labels&#125;) epoch_list.append(epoch); loss_list.append(loss) accuracy_list.append(acc) print(\"Train Epoch:\", '%02d' % (epoch + 1), \"Loss=\", \"&#123;:.9f&#125;\".format(loss), \" Accuracy=\", acc)duration = time() - startTimeprint(\"Train Finished takes:\", duration) 输出： 12345678910111213141516Train Epoch: 01 Loss= 6.145112991 Accuracy= 0.8448Train Epoch: 02 Loss= 3.810992956 Accuracy= 0.8902Train Epoch: 03 Loss= 2.916266680 Accuracy= 0.908Train Epoch: 04 Loss= 2.435287952 Accuracy= 0.916Train Epoch: 05 Loss= 2.132323503 Accuracy= 0.9244Train Epoch: 06 Loss= 1.904199958 Accuracy= 0.9306Train Epoch: 07 Loss= 1.830164433 Accuracy= 0.9342Train Epoch: 08 Loss= 1.654303908 Accuracy= 0.9386Train Epoch: 09 Loss= 1.512639999 Accuracy= 0.9408Train Epoch: 10 Loss= 1.484358191 Accuracy= 0.94Train Epoch: 11 Loss= 1.389361858 Accuracy= 0.9434Train Epoch: 12 Loss= 1.329701424 Accuracy= 0.9438Train Epoch: 13 Loss= 1.301885366 Accuracy= 0.9444Train Epoch: 14 Loss= 1.228815317 Accuracy= 0.947Train Epoch: 15 Loss= 1.276753068 Accuracy= 0.943Train Finished takes: 10.961797952651978 绘图Loss1234567fig = plt.gcf()fig.set_size_inches(6, 3)plt.plot(epoch_list, loss_list, label='loss')plt.ylabel('loss')plt.xlabel('epoch')plt.legend()plt.show() Accuracy12345678plt.plot(epoch_list, accuracy_list, label=\"accuracy\")fig = plt.gcf()fig.set_size_inches(6, 3)plt.ylim(0.8, 1)plt.ylabel('accuracy')plt.xlabel('epoch')plt.legend()plt.show() 模型准确率评估1print(\"Accuracy:\", sess.run(accuracy, feed_dict=&#123;X: mnist.test.images, y_label: mnist.test.labels&#125;)) 输出： 1Accuracy: 0.9412 进行预测123456789101112131415161718192021222324252627prediction_result = sess.run(tf.argmax(y_predict, 1), feed_dict=&#123;X: mnist.test.images&#125;)# 显示预测结果，前10项prediction_result[:10]def plot_images_labels_prediction(images, labels, prediction, idx, num=10): fig = plt.gcf() fig.set_size_inches(12, 12) if num &gt; 25: num = 25 for i in range(0, num): ax = plt.subplot(5, 5, 1 + i) ax.imshow(np.reshape(images[idx], (28, 28)), cmap='binary') title = \"label=\" + str(np.argmax(labels[idx])) if len(prediction) &gt; 0: title += \",predict=\" + str(prediction[idx]) ax.set_title(title, fontsize=10) ax.set_xticks([]); ax.set_yticks([]) idx += 1 plt.show()plot_images_labels_prediction(mnist.test.images, mnist.test.labels, prediction_result, 0) 从输出的图片可以看出，大部分的预测是正确的，还是有错误的情况，例如说5判断为6. 输出前500个错误的判断12345for i in range(500): if prediction_result[i] != np.argmax(mnist.test.labels[i]): print(\"i=\" + str(i) + \" label=\", np.argmax(mnist.test.labels[i]), \"predict=\", prediction_result[i]) 输出： 1234567891011121314151617181920212223242526272829303132333435363738394041i=8 label= 5 predict= 6i=24 label= 4 predict= 7i=33 label= 4 predict= 0i=61 label= 8 predict= 2i=62 label= 9 predict= 8i=78 label= 9 predict= 7i=96 label= 1 predict= 5i=118 label= 9 predict= 8i=124 label= 7 predict= 4i=125 label= 9 predict= 4i=133 label= 7 predict= 2i=149 label= 2 predict= 6i=151 label= 9 predict= 2i=159 label= 4 predict= 1i=195 label= 3 predict= 1i=211 label= 5 predict= 8i=244 label= 2 predict= 8i=245 label= 3 predict= 5i=247 label= 4 predict= 2i=306 label= 2 predict= 1i=318 label= 2 predict= 3i=320 label= 9 predict= 7i=321 label= 2 predict= 7i=324 label= 0 predict= 3i=340 label= 5 predict= 3i=359 label= 9 predict= 4i=381 label= 3 predict= 7i=389 label= 9 predict= 4i=399 label= 4 predict= 2i=404 label= 2 predict= 7i=412 label= 5 predict= 3i=445 label= 6 predict= 0i=448 label= 9 predict= 8i=449 label= 3 predict= 5i=450 label= 3 predict= 5i=457 label= 6 predict= 5i=468 label= 7 predict= 3i=478 label= 5 predict= 3i=479 label= 9 predict= 5i=486 label= 8 predict= 7i=495 label= 8 predict= 3 改进方案这里的正确率还是不太理想。改进的方法有很多，例如我们将之前隐藏层原本的256个神经元改成1000个，或者使用两层隐藏层。或者使用卷积神经网络等等来提高正确率。这里我暂时没有深入再去研究。后面如果有时间和精力再研究。有兴趣的同学可以暂时参考林博主的关于MNIST手写数字识别的几种实现方式。 致谢本次实验参考了很多资料，在此表示感谢。如果有侵权的地方，请联系我：stefancharles@qq.com，我会立刻删除侵权内容。 如果你认为我哪里写得不对，也可以联系我一起讨论。 以下是参考来源。 1.MNIST 数据地址 2.CoLAB CoLab 3.交叉熵（Cross-Entropy） 4.林博主 - 关于MNIST手写数字识别的几种实现方式","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Mnist","slug":"Mnist","permalink":"https://Stefancharles.xyz/tags/Mnist/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://Stefancharles.xyz/tags/TensorFlow/"}]},{"title":"基于OpenCV的MNIST手写体SVM分类","slug":"mnist","date":"2019-11-11T16:00:00.000Z","updated":"2019-11-25T03:32:36.912Z","comments":true,"path":"2019/11/12/mnist/","link":"","permalink":"https://Stefancharles.xyz/2019/11/12/mnist/","excerpt":"简介MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST).训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.它的训练集有6万项数据，而测试集有1万项数据（其中前5000个来自最初NIST项目的训练集，后5000个来自最初NIST项目的测试集）。在官方网站上，这些数据以4个gz压缩包的方式提供下载：","text":"简介MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST).训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据.它的训练集有6万项数据，而测试集有1万项数据（其中前5000个来自最初NIST项目的训练集，后5000个来自最初NIST项目的测试集）。在官方网站上，这些数据以4个gz压缩包的方式提供下载： 实验要求采用SVM实现实现MNIST手写体分类，数据下载链接在官方网站上；上传源码和实现结果，语言不限 实验环境 Pycharm 2019.3 BETA Win10 1909 Python 3.7.0 OpenCV 4.1.1 VS 2019 OpenCV的配置本次实验我选择使用C++的OpenCV实现。所以需要先配置OpenCV环境。 在windows下配置OpenCV是一个技术活，这里引用一下本专业最强的达哥博客，他的博客把windows下配置OpenCV讲解的很详细。 点击这里去配置OpenCV OpenCV的全称是Open Source Computer Vision Library，是一个跨平台的计算机视觉库。 python传送门 【TensorFlow】利用MNIST数字识别数据集识别 keras卷积神经网络对MNIST数据集进行操作 总体概览 train-images-idx3-ubyte.gz: training set images (9912422 bytes) train-labels-idx1-ubyte.gz: training set labels (28881 bytes) t10k-images-idx3-ubyte.gz: test set images (1648877 bytes) t10k-labels-idx1-ubyte.gz: test set labels (4542 bytes) The data is stored in a very simple file format designed for storing vectors and multidimensional matrices. General info on this format is given at the end of this page, but you don’t need to read that to use the data files.All the integers in the files are stored in the MSB first (high endian) format used by most non-Intel processors. Users of Intel processors and other low-endian machines must flip the bytes of the header. 如上图，这些数据的格式还是比较简单的，上面文件中的所有的数字都是按照MSB（大端）的方式存储的。值得注意的的是，intel处理器是little-endian的。所以在intel处理器上或者其它的little-endian处理器上，必须要进行相应的翻转处理。也就是大端转小端。 那么什么是大小端？ 最标准的解释可以是Wiki百科自己学习一下。点击这里去Wiki。可能需要翻墙访问，或者你可以自行百度&amp;谷歌。 但是我还是“断章取义”一下：例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。 MNIST网站上对数据集TRAINING SET LABEL FILE (train-labels-idx1-ubyte)的介绍如下： 12345678[offset] [type] [value] [description]0000 32 bit integer 0x00000801(2049) magic number (MSB first)0004 32 bit integer 60000 number of items0008 unsigned byte ?? label0009 unsigned byte ?? label........xxxx unsigned byte ?? labelThe labels values are 0 to 9. 其实MNIST网站上对上面很多的东西解释的很清楚了。大家最好自行研读一下英文文档。 我这里还是稍微讲一下。或者说翻译一下。 这四个文件采用了IDX的文件格式，一种平铺直叙的方式： 12345678910111213magic numbersize in dimension 0size in dimension 1size in dimension 2.....size in dimension Ndata 其中magic number为4字节，前2字节永远是0，第3字节代表数据的格式：0x08: unsigned byte0x09: signed byte0x0B: short (2 bytes)0x0C: int (4 bytes)0x0D: float (4 bytes)0x0E: double (8 bytes) 第4字节的含义表示维度的数量（dimensions）: 1 表示一维（比如vectors）, 2 表示二维（ 比如matrices），3表示三维（比如numpy表示的图像，高，宽，通道数）。 训练集和测试集的标签文件的格式(train-labels-idx1-ubyte和t10k-labels-idx1-ubyte)格式： 1.前4个字节（第0～3个字节）是magic number2049（int型，0x00000801, 大端）; 2.再往后4个字节（第4～7个字节）是标签的个数：60000或10000； 3.再往后每1个字节是一个无符号型的数，值为0～9。 训练集和测试集的图像文件的格式(train-images-idx3-ubyte和t10k-images-idx3-ubyte)格式比label复杂些： 1.前4个字节（第0～3个字节）是magic number2051（int型，0x00000803, 大端）; 2.再往后4个字节（第4～7个字节）是图像的个数：60000或10000（第1个维度）； 3.再往后4个字节（第8～11个字节）是图像在高度上由多少个像素组成（第2个维度，高28个像素）； 4.再往后4个字节（第12～15个字节）是图像在宽度上由多少个像素组成（第3个维度，宽28个像素）； 5.再往后是一个三维数组，表示10000个或60000个分辨率28x28的灰度图像，一句话来说就是10000x28x28个像素，每个像素的值为0～255（0是背景，为白色；255是黑色）。 在python中绘制先来直观看一下数据集是什么样的吧。 新建一个Pycharm工程，输入以下源码： 123456789101112131415161718192021222324252627282930313233343536373839# coded by Stefan# 2019.11.12import structimport numpy as npimport matplotlib.pyplot as plt# 博客地址 https://stefancharles.xyz/def load_mnist(): labels_path = 'D:\\\\py\\\\mnist\\\\data\\\\train-labels.idx1-ubyte' images_path = 'D:\\\\py\\\\mnist\\\\data\\\\train-images.idx3-ubyte' with open(labels_path, 'rb') as lbpath: magic, n = struct.unpack('&gt;II', lbpath.read(8)) labels = np.fromfile(lbpath, dtype=np.uint8) with open(images_path, 'rb') as imgpath: magic, num, rows, cols = struct.unpack('&gt;IIII', imgpath.read(16)) images = np.fromfile(imgpath, dtype=np.uint8).reshape(len(labels), 784) return images, labelsfig, ax = plt.subplots( nrows=2, ncols=5, sharex=True, sharey=True, )X_train,y_train = load_mnist()ax = ax.flatten()for i in range(10): img = X_train[y_train == i][0].reshape(28, 28) ax[i].imshow(img, cmap='Greys', interpolation='nearest')ax[0].set_xticks([])ax[0].set_yticks([])plt.tight_layout()plt.show() 怎么导包，导包失败的这些问题我就不再说了，相信你已经轻车熟路了。 需要把上面的代码的绝对路径换成你下载MNIST数据集的解压后的路径。 运行上面的代码，我们现在应该可以看到一个 2*5 的图片, 里面分别是 0-9 单个数字的图片. 当然还能显示很多数据集中的图片，这里不再赘述。有兴趣的同学可以自己研究。 开始上手OpenCV我主要需要写三个函数，一个训练函数，一个用测试集的测试函数，一个随机的测试函数。 所以我的主函数如下： 注意：以下所有实现代码有很多方式写，仅供参考。 1234567891011121314151617181920212223242526int main(int argc, char* argv[])&#123; cout &lt;&lt; \"Input function you want to run:\" &lt;&lt; endl; int type = 1; cin &gt;&gt; type; switch (type) &#123; case 1: cout &lt;&lt; \"Start running MnistTrain...\" &lt;&lt; endl; mnistTrain(); break; case 2: cout &lt;&lt; \"Start running MnistAccuracyTest...\" &lt;&lt; endl; mnistAccuracyTest(); break; case 3: cout &lt;&lt; \"Start running RandomImageTest...\" &lt;&lt; endl; randomImageTest(); break; default: break; &#125; //coded BY Stefan on 2019.11.12 //博客地址 https://stefancharles.xyz/ waitKey(0); return 0;&#125; 我设置的头文件如下 123456789101112131415#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/ml.hpp&gt;#include &lt;opencv2/ml/ml.hpp&gt;#include &lt;fstream&gt;using namespace cv;using namespace std;//coded BY Stefan on 2019.11.12//博客地址 https://stefancharles.xyz/void mnistAccuracyTest();void randomImageTest();int reverseInt(int i);void mnistTrain(); svm训练数据集首先需要读取数据集。值得注意的是由于SVM需要的测试数据格式是CV_32FC1，所以需要进行转换。 12345678910111213//读取测试图像int imgVectorLen = nrows * ncols;Mat testFeatures = Mat::zeros(testImgsNum, imgVectorLen, CV_32FC1);Mat temp = Mat::zeros(nrows, ncols, CV_8UC1);for (int i = 0; i &lt; testImgsNum; i++)&#123; if_testImags.read((char*)temp.data, imgVectorLen); Mat tempFloat; //coded BY Stefan on 2019.11.12 //博客地址 https://stefancharles.xyz/ temp.convertTo(tempFloat, CV_32FC1); memcpy(testFeatures.data + i * imgVectorLen * sizeof(float), tempFloat.data, imgVectorLen * sizeof(float));&#125; 然后再归一化testFeatures。下面读取测试图像对应的分类标签。由于SVM需要输入的标签类型是CV_32SC1，所以也在这里进行转换 123456789101112131415int magic_num_2, testLblsNum; //读取magic number if_testLabels.read((char*)&amp;magic_num_2, sizeof(magic_num_2)); magic_num_2 = reverseInt(magic_num_2); cout &lt;&lt; \"测试图像标签数据库t10k-labels-idx1-ubyte的magic number为：\" &lt;&lt; magic_num_2 &lt;&lt; endl; //读取测试图像的分类标签的数量 if_testLabels.read((char*)&amp;testLblsNum, sizeof(testLblsNum)); testLblsNum = reverseInt(testLblsNum); cout &lt;&lt; \"测试图像标签数据库t10k-labels-idx1-ubyte的标签总数为：\" &lt;&lt; testLblsNum &lt;&lt; endl; //coded BY Stefan on 2019.11.12 //博客地址 https://stefancharles.xyz/ Mat testLabels = Mat::zeros(testLblsNum, 1, CV_32SC1); Mat readLabels = Mat::zeros(testLblsNum, 1, CV_8UC1); if_testLabels.read((char*)readLabels.data, testLblsNum * sizeof(char)); readLabels.convertTo(testLabels, CV_32SC1); 就如我前面提到的大小端转换问题，这里reverseInt()函数就是为了转换。这里是一个关键点。其函数具体如下： 123456789101112//大端转小端int reverseInt(int i)&#123; unsigned char c1, c2, c3, c4; c1 = i &amp; 255; c2 = (i &gt;&gt; 8) &amp; 255; c3 = (i &gt;&gt; 16) &amp; 255; c4 = (i &gt;&gt; 24) &amp; 255; return ((int)c1 &lt;&lt; 24) + ((int)c2 &lt;&lt; 16) + ((int)c3 &lt;&lt; 8) + c4;&#125; 图像和标签准备好了之后，接下来需要设置svm的参数 设置svm的参数这里算是整个工程的核心部分，参数的设置直接关系到后面测试集测试的准确率。 123456789101112131415cv::Ptr&lt;cv::ml::SVM&gt; svm = cv::ml::SVM::create();svm-&gt;setType(cv::ml::SVM::Types::C_SVC);svm-&gt;setKernel(cv::ml::SVM::KernelTypes::RBF);svm-&gt;setDegree(10.0);svm-&gt;setGamma(0.01);svm-&gt;setCoef0(1.0);svm-&gt;setC(10.0);svm-&gt;setNu(0.5);svm-&gt;setP(0.1);svm-&gt;setTermCriteria(cv::TermCriteria(cv::TermCriteria::EPS, 100, FLT_EPSILON));svm-&gt;train(trainFeatures, cv::ml::SampleTypes::ROW_SAMPLE, trainLabels);//coded BY Stefan on 2019.11.12 //博客地址 https://stefancharles.xyz/cout &lt;&lt; \"训练结束，正写入xml:\" &lt;&lt; endl;svm-&gt;save(\"mnist.xml\"); 上面的参数怎么设置，可以去查看OpenCV的官方文档。 后面如果有时间的话，我会再仔细讲解这里的调参。 有一篇关于svm参数的csdn博客还可以吧。点击这里访问 这里完成后，就可以跑一下程序了。 注意把DEBUG模式调到X64 训练需要一些时间。 上面的图里就是训练结束后的我的截图。回到工程目录下，应该能看到一个mnist.xml文件了。可以使用VScode打开。 加载训练好的SVM模型首先也需要和上面一样读取图像集和标签集，代码很类似，改动几个小地方就行。这里我就不赘述了。相信认真看完上面代码的你一定懂得怎么修改。 然后就是加载训练好的SVM模型。 代码如下： 12cv::Ptr&lt;cv::ml::SVM&gt; svm = cv::ml::SVM::create();svm = Algorithm::load&lt;ml::SVM&gt;(\"mnist.xml\"); 对每一个测试图像进行SVM分类预测123456789101112131415for (int i = 0; i &lt; testLblsNum; i++) &#123; Mat predict_mat = Mat::zeros(1, imgVectorLen, CV_32SC1); memcpy(predict_mat.data, testFeatures.data + i * imgVectorLen * sizeof(float), imgVectorLen * sizeof(float)); int predict_label = svm-&gt;predict(predict_mat); int truth_label = testLabels.at&lt;int&gt;(i); if ((int)predict_label == (int)truth_label) &#123; sum++; &#125; &#125;//coded BY Stefan on 2019.11.13//博客地址 https://stefancharles.xyz/ cout &lt;&lt; \"预测准确率为：\" &lt;&lt; (double)sum / (double)testLblsNum &lt;&lt; endl; 上面的代码很容易读懂的。 大概就是把预测的样本结果和真实的样本标签进行比较，一致的话就让sum加1，循环如此，直到测试集结束。然后就除以总的测试样本数据，就是正确率了。 这里我进行的测试结果是98.33%. 如下图所示： 也就是错误率在0.0167‬左右了。在MNIST的官方网址上最低的错误率是2012年的0.23。 不过现在是2019了，应该有人比我上面得出的正确率还要高了。 随机测试随机选取一张图片进行测试。代码和上面类似，就不具体贴出来了。就贴一下运行结果。 可以看出，实际的图片1，程序预测出即为1. 希望你看完这篇文章对你有所启发，文章有错误的地方，还请指出。感谢观看。下期再见。 致谢本次实验参考了很多资料和著名博主的博客内容，在此表示感谢。如果有侵权的地方，请联系我：stefancharles@qq.com，我会立刻删除侵权内容。 如果你认为我哪里写得不对，也可以联系我一起讨论。 以下是参考来源。 1.本专业最强的陈博主，达哥，点击这里去他的博客 2.MNIST 数据地址 3.svm参数的csdn博客。点击这里访问 4.查看OpenCV的官方文档","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Mnist","slug":"Mnist","permalink":"https://Stefancharles.xyz/tags/Mnist/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://Stefancharles.xyz/tags/OpenCV/"},{"name":"SVM","slug":"SVM","permalink":"https://Stefancharles.xyz/tags/SVM/"}]},{"title":"OMNET++入门教程","slug":"omnetpp","date":"2019-11-07T16:00:00.000Z","updated":"2019-11-13T09:31:38.109Z","comments":true,"path":"2019/11/08/omnetpp/","link":"","permalink":"https://Stefancharles.xyz/2019/11/08/omnetpp/","excerpt":"OMNETPP简介OMNeT++ (Objective Modular Network Testbed in C++) is a modular, component-based C++ simulation library and framework, primarily for building network simulators.OMNeT++是一个免费的、开源的多协议网络仿真软件，在网络仿真领域中占有十分重要的地位。OMNeT++英文全称是Objective Modular Network Testbed in C++，是近年来在科学和工业领域里逐渐流行的一种基于组件的模块化的开放的网络仿真平台。OMNeT++作为离散事件仿真器，具备强大完善的图形界面接口。","text":"OMNETPP简介OMNeT++ (Objective Modular Network Testbed in C++) is a modular, component-based C++ simulation library and framework, primarily for building network simulators.OMNeT++是一个免费的、开源的多协议网络仿真软件，在网络仿真领域中占有十分重要的地位。OMNeT++英文全称是Objective Modular Network Testbed in C++，是近年来在科学和工业领域里逐渐流行的一种基于组件的模块化的开放的网络仿真平台。OMNeT++作为离散事件仿真器，具备强大完善的图形界面接口。 好了，上面的介绍我也不知道具体说的什么意思。先来动手安装。 首先我想说一下，omnetpp官网给出了安装教程，不过是英文版的教程。点击这里访问官方教程 请先尝试看英文原版，原版讲解比我详细多了。但是如果你看英文有理解困难，可以参考以下我的安装过程。 Win10环境下安装后面有机会我再介绍在Ubuntu环境下安装。先来在win10下安装。 我安装的版本是5.5.1。是目前时间里最新的稳定版。当然有技术喜欢探究的同学可以安装最版的Preview 6.0版本。 先点击这里下载对应版本的zip。这里别下载错了。linux版本只有200多MB，但是win的版本有600多MB。 由于它这里使用的外国服务器amazonaws，速度可能有些慢。可以考虑翻墙下载。 或者你可以联系我，我私发安装文件给你。 下载后是一个zip文件。请解压到一个不带空格的名字的文件夹下，最好也不要有中文。 特别注意：整个路径也不能含有空格或者中文。建议直接在磁盘的根目录下直接新建一个名作OMNETPP的文件夹。然后在这下面解压。如果这一步你没做，下面的安装你可能会失败。 解压后大致如下图所示： Configuring and Building OMNeT++双击打开mingwenv.cmd。 如上图，出现类似命令提示行的界面。任意按一个键等待解压MinGW的toolchain就行。例如你按下回车即可。 这里需要注意，如果你的电脑之前安装过带有MinGW的软件时，例如codeblocks，请检查你的环境变量是不是有MinGW，如果有，请务必先删除其对应Path。因为后面的操作是基于上面解压的MinGW，如果你不删除你环境变量里的，那么默认就会使用你环境变量里指向的MinGW。从而可能导致后面make失败。 稍微熟悉一点linux命令的同学对下面的操作应该很了解。 如果你不熟悉linux命令，那也没有关系，按照下面的操作按部就班即可成功安装。不要看到黑漆漆的框框就有畏难心理。 等待解压完成后。然后输入下面的一行命令并回车： 1./configure 等待它自动完成后，再输入命令并回车： 1make 接下来就需要等待一段较长的时间。 Verifying the Installation上一步完成后，需要验证一下安装是否正确。 输入下面的一行命令并回车： 1cd samples/aloha 上面的命令就是切换了一下目录。 然后再输入下面的一行命令并回车： 1./aloha 默认情况下，就应该可以看到GUI窗口和对话框。 Starting the IDE然后输入下面的一行命令并回车： 1omnetpp 就可以启动IDE了。 当然，你可以把快捷方式发送到桌面。如下图所示。点击exe的效果和命令行一样。但是命令行看起来更帅很多。 Environment Variables如果你想直接在win的cmd下启动 OMNeT++ 的 simulations ，你需要配置一下环境变量。 不过这里可有可无。有兴趣的同学可以按照官方教程配置即可。这里我就不赘述了。 关于Preview版本在win10环境下，6.0版本在make时会报错，需要你自行修复一下。有兴趣的同学可以参照github上的issue自己解决。 点击这里访问 OMNeT++的使用Getting StartedSetting up the project首先从最简单的步骤开始，我们新建一个工程文件。 就如上图所展示的这样。 Adding the NED file接下来新建一个NED文件。 OMNeT ++使用NED文件来定义组件并将它们组装成更大的单元，例如网络。 我们开始通过添加NED文件来实现我们的模型。 要将文件添加到项目中， 在左侧的项目资源管理器中右键单击项目目录，然后从菜单中选择新建-&gt;Network Description File（网络描述文件）（NED）。 当提示输入文件名时，例如输入tictoc1.ned。 如上图所示。 看下图的左下角，这里有两种模式，一个是设计模式，一个是源码模式。点击切换到源码模式，输入下面的代码进去。 12345678910111213141516171819202122simple Txc1&#123; gates: input in; output out;&#125;//// Two instances (tic and toc) of Txc1 connected both ways.// Tic and toc will pass messages to one another.//network Tictoc1&#123; submodules: tic: Txc1 &#123; @display(\"p=57,132\"); &#125; toc: Txc1; connections: tic.out --&gt; &#123; delay = 100ms; &#125; --&gt; toc.in; tic.in &lt;-- &#123; delay = 100ms; &#125; &lt;-- toc.out;&#125; 你应该大概猜得出上面代码做了什么。我再这里还是稍微解释一下：代码中的第一个块将Txc1声明为简单模块类型。 简单模块在NED级别上是最基本的。 它们也是活动组件，其行为是用C ++实现的。以及Txc1有一个名为in的输入门和一个名为out的输出门。 第二个块将Tictoc1声明为网络。 Tictoc1由两个子模块tic和toc组装而成，两个子模块均为Txc1模块类型。 tic的输出门连接到toc的输入门，反之亦然。 两种方式都有100ms的传播延迟。 这里补充一下，其实你可以找到你设定的wrokspace，找到tictoc1.ned文件，直接使用你喜欢的文本编辑器打开即可。例如我喜欢VScode进行编辑。如下面两张图。 然后再点击Design，回到设计模式。如下图。 Adding the C++ files和上面一样添加NED文件时差不多，只不过这一次选择Source File。 然后输入以下代码并保存。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;string.h&gt;#include &lt;omnetpp.h&gt;using namespace omnetpp;/** * Derive the Txc1 class from cSimpleModule. In the Tictoc1 network, * both the `tic' and `toc' modules are Txc1 objects, created by OMNeT++ * at the beginning of the simulation. */class Txc1 : public cSimpleModule&#123; protected: // The following redefined virtual function holds the algorithm. virtual void initialize() override; virtual void handleMessage(cMessage *msg) override;&#125;;// The module class needs to be registered with OMNeT++Define_Module(Txc1);void Txc1::initialize()&#123; // Initialize is called at the beginning of the simulation. // To bootstrap the tic-toc-tic-toc process, one of the modules needs // to send the first message. Let this be `tic'. // Am I Tic or Toc? if (strcmp(\"tic\", getName()) == 0) &#123; // create and send first message on gate \"out\". \"tictocMsg\" is an // arbitrary string which will be the name of the message object. cMessage *msg = new cMessage(\"tictocMsg\"); send(msg, \"out\"); &#125;&#125;void Txc1::handleMessage(cMessage *msg)&#123; // The handleMessage() method is called whenever a message arrives // at the module. Here, we just send it to the other module, through // gate `out'. Because both `tic' and `toc' does the same, the message // will bounce between the two. send(msg, \"out\"); // send out the message&#125; 还是简单说下上面的代码吧，Txc1简单模块类型由C ++类Txc1表示。 Txc1类需要从OMNeT ++的cSimpleModule类继承而来，并且需要使用Define_Module（）宏在OMNeT ++中进行注册。 1Define_Module(Txc1); 这一句如果没加就定会报错，因为这一句就是注册（register）。 从cSimpleModule重新定义了两个方法：initialize（）和handleMessage（）。从英文注释里可以知道，它们是从仿真内核调用的，第一个仅调用一次，第二条在消息到达模块时调用。 在initialize（）中，我们创建一个消息对象（cMessage），在gate out 中将其发送出去。 由于此门连接到另一个模块的输入门，因此在分配给NED文件中的链接的传播延迟为100ms之后，仿真内核将在handleMessage（）的参数中将此消息传递给另一个模块。 另一个模块只是将其发送回去（100毫秒延迟）。 消息（数据包，帧，作业等）和事件（计时器，超时）都是由OMNeT ++中的cMessage对象或它的子类表示。在发送或安排它们之后，它们将由仿真内核保存在“scheduled events”或“future events”列表中，等到时间到了，就通过handleMessage（）将它们传递到模块中。就好像一个定时器引起中断事件。 Adding omnetpp.ini为了能够运行模拟，需要创建一个omnetpp.ini文件。omnetpp.ini告诉模拟程序要模拟哪个网络（因为NED文件可能包含多个网络）。 和上面添加文件差不多，File -&gt; New -&gt; Initialization file (INI) 。 到Source模式，输入以下代码： 12[General]network = Tictoc1 做好之后，在你的工作文件夹下应该多出上图三个文件。下面就可以开始进行模拟了。 Launching the simulation program 如上图，右击omnetpp.ini，选择run as ，即图里箭头那里。 然后出现下图： 点击箭头指向的播放图标，开始模拟。 如你所见。 补充一点，操作上面模拟的时候，它可能提示你要不要切换到release模式。你选择yes就行。 在release模式下运行速度会比debug模式下快很多。 因为release下编译器没有做多余的内存越界等等检查。 在Eroneko（罗大佬）的发现下，在OpenCV项目下，如果使用release也会快很多。道理一样。 入门教程我就讲到这里，下面的就靠你们自己了。相信看这篇博客的你可以做得比我好很多。 好了，今天就到这里，后面有时间再更新本博客内容吧。有缘再见。 需要联系我？如果有疑问或者建议，可以发邮件至stefancharles@qq.com与我交流讨论。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Omnetpp","slug":"Omnetpp","permalink":"https://Stefancharles.xyz/tags/Omnetpp/"}]},{"title":"Fisher线性判决函数","slug":"fisher","date":"2019-11-02T16:00:00.000Z","updated":"2019-11-18T03:52:25.483Z","comments":true,"path":"2019/11/03/fisher/","link":"","permalink":"https://Stefancharles.xyz/2019/11/03/fisher/","excerpt":"简介Iris Data Set（鸢尾属植物数据集）是历史较为久远的数据集，它首次出现在著名的英国统计学家和生物学家Ronald Fisher 1936年的论文《The use of multiple measurements in taxonomic problems》中，被用来介绍线性判别式分析。在这个数据集中，包括了三类不同的鸢尾属植物：Iris Setosa，Iris Versicolour，Iris Virginica。每类收集了50个样本，因此这个数据集一共包含了150个样本。","text":"简介Iris Data Set（鸢尾属植物数据集）是历史较为久远的数据集，它首次出现在著名的英国统计学家和生物学家Ronald Fisher 1936年的论文《The use of multiple measurements in taxonomic problems》中，被用来介绍线性判别式分析。在这个数据集中，包括了三类不同的鸢尾属植物：Iris Setosa，Iris Versicolour，Iris Virginica。每类收集了50个样本，因此这个数据集一共包含了150个样本。 实验要求编写fisher线性判别函数，实现Iris Data Set（鸢尾属植物数据集,数据下载地址 ）的数据分类，上传源码和实现结果，语言不限。 基本原理Fisher线性判别分析的基本思想：通过寻找一个投影方向（线性变换，线性组合），将高维问题降低到一维问题来解决，并且要求变换后的一维数据具有性质：同类样本尽可能聚集在一起，不同类样本尽可能地远。 Fisher线性判别分析，是通过给定的训练数据，确定投影方向w和阈值y0，即确定线性判别函数，然后根据这个线性判别函数，对测试数据进行测试，得到测试数据的类别。 所以这里把每一组50个数据分成40个训练集和10个测试集。 实验环境 Pycharm 2019.3 EAP Win10 1909 Python 3.7.0 环境搭建中遇到的问题及解决方案1.安装时报Non-zero exit code (1)解决方法：因为pip版本太低。cmd下执行下面命令： 1python -m pip install --upgrade pip 这里下载较慢，推荐翻墙进行操作。 2.package的安装 1.这里可以使用pycharm来安装和管理package。推荐换国内源。 2.也可以使用cmd安装。 实验过程导入首先下载数据集。一个方法是按照Iris Data Set（鸢尾属植物数据集,数据下载地址 ）。这个下载地址下载数据。另一个比较方便的方式是，直接利用Python中的机器学习包scikit-learn直接导入该数据集，可参考Iris Plants Database，具体代码如下： 12345678from sklearn.datasets import load_irisimport pandas as pddata = load_iris()print(dir(data))print(data.DESCR) pd.DataFrame(data=data.data, columns=data.feature_names) 现在来运行一下，如下图： 特征从上面输出的信息可以知道，该数据集测量了所有150个样本的4个特征，分别是： sepal length（花萼长度） sepal width（花萼宽度） petal length（花瓣长度） petal width（花瓣宽度）以上四个特征的单位都是厘米（cm）。 整体印象将数据用图像的形式展示出来，可以对该数据集有一个直观的整体印象。下面分别利用该数据集4个特征中的前、后两个，来描绘所有的样本点。 展示前两个特征的参考代码如下： 1234567891011121314151617data = load_iris()pd.DataFrame(data=data.data, columns=data.feature_names)X = data.data y = data.target features = data.feature_names targets = data.target_names plt.figure(figsize=(10, 4))plt.plot(X[:, 1][y == 0], X[:, 2][y == 0], 'bs', label=targets[0])plt.plot(X[:, 1][y == 1], X[:, 2][y == 1], 'kx', label=targets[1])plt.plot(X[:, 1][y == 2], X[:, 2][y == 2], 'ro', label=targets[2])plt.xlabel(features[1])plt.ylabel(features[2])plt.title('Iris Data Set')plt.legend()plt.show() 结果如下图： 输出后两个特征的代码就不再赘述了。基本和上面一样，改动几个参数即可。 结果如下图： 背景Iris Setosa Iris Virginica Iris Versicolor 思路步骤 下面按照上面图里的思路一步一步来。注意：代码片段仅供参考，实现的方法有很多,请勿直接照搬。 输入特征数据集，类标签，类别个数 计算每类数据的均值 用于计算散度矩阵 1234567891011121314def class_mean(avg1,avg2,iris,class_kind): # 40个训练集,10个测试集 for i in range(4): mean_1 = 0 mean_2 = 0 for j in range(class_kind[0]*50,class_kind[0]*50+40): mean_1 = mean_1 + iris.data[j][i] for j in range(class_kind[1]*50,class_kind[1]*50+40): mean_2 = mean_2 + iris.data[j][i] avg1.append(mean_1/40) avg2.append(mean_2/40) print(\"avg_1 is \" + str(avg1)) print(\"avg_2 is \" + str(avg2)) 计算类内散度，散度矩阵式m∗m的对称矩阵，m是特征（属性）的个数 由上面计算的类内均值 对每一类中的每条数据减去均值进行矩阵乘法（列向量乘以行向量，所得的矩阵秩为1 ） 再相加是类内散度矩阵S_W 1234567891011121314 # 计算类内散度def within_class_SW(data,label,clusters): m = data.shape[1] S_W = np.zeros((m,m)) avg1 = class_mean(data,label,clusters) for cl ,mv in zip(range(1,clusters+1),avg1): class_sc_mat = np.zeros((m,m)) # 对每个样本数据进行矩阵乘法 for row in data[label == cl]: row ,mv =row.reshape(4,1),mv.reshape(4,1) class_sc_mat += (row-mv).dot((row-mv).T) S_W += class_sc_mat #print S_W return S_W 下面用于计算类间散度矩阵S_B，这里某一类的特征用改类的均值向量体现。 C个秩为1的矩阵的和，数据集中心是整体数据的中心，S_B是秩为C-1。 12345678910111213 # 计算类间散度def between_class_SB(data,label,clusters): m = data.shape[1] all_mean =np.mean(data,axis = 0) S_B = np.zeros((m,m)) avg1 = class_mean(data,label,clusters) for cl ,mean_vec in enumerate(avg1): n = data[label==cl+1,:].shape[0] mean_vec = mean_vec.reshape(4,1) all_mean = all_mean.reshape(4,1) S_B += n * (mean_vec - all_mean).dot((mean_vec - all_mean).T) #print S_B return S_B 求解S_W的逆矩阵，再根据逆矩阵求解u值。 再按照步骤7，8来计算m，和y_t。 最后对那10个数据进行测试。 这里以第一类和第二类进行测试为例子： 更多深度学习博客传送门： 1.基于OpenCV的MNIST手写体SVM分类 2.【TensorFlow】利用MNIST数字识别数据集识别 3.keras卷积神经网络对MNIST数据集进行操作 参考博客本次实验参考了很多资料和著名博主的博客内容，在此表示感谢。如果有侵权的地方，请联系我：stefancharles@qq.com，我会立刻删除侵权内容。以下是参考来源。 1.本专业最强的林博主，点击这里去他的博客，点击这里访问林博主csdn博客 2.CSDN某博主，博客地址 3.IRIS 数据地址","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Fisher","slug":"Fisher","permalink":"https://Stefancharles.xyz/tags/Fisher/"}]},{"title":"关于时间","slug":"AboutTime","date":"2019-10-31T16:00:00.000Z","updated":"2019-11-01T13:49:05.532Z","comments":true,"path":"2019/11/01/AboutTime/","link":"","permalink":"https://Stefancharles.xyz/2019/11/01/AboutTime/","excerpt":"前几天看到一个大神在他的一篇博客中写道： 距离去年的高考已经一年了，而去年的这时候，就像我在开头提及的一样，正在为高中的一些很 naïve 的事情而苦恼。才不过一年，当时所谓心中很重要的人，就已经说再见了。毕竟最后我们仍然不是一个世界的人，仍然没有机会走到一起。有时候有点想嘲笑过去的自己。 看到他写的这句话，我突然一怔，突然意识到两年过去了，突然意识到这两年来我做错了很多，失去了很多，错过了很多……","text":"前几天看到一个大神在他的一篇博客中写道： 距离去年的高考已经一年了，而去年的这时候，就像我在开头提及的一样，正在为高中的一些很 naïve 的事情而苦恼。才不过一年，当时所谓心中很重要的人，就已经说再见了。毕竟最后我们仍然不是一个世界的人，仍然没有机会走到一起。有时候有点想嘲笑过去的自己。 看到他写的这句话，我突然一怔，突然意识到两年过去了，突然意识到这两年来我做错了很多，失去了很多，错过了很多…… 现在这几天去实验室的路上，总是能看到19级的新生在军训。突然意识到自己这个学期也已经是要大三的人了，粗略想想，距离2017年高考结束也已经过去两年多了。慢了一拍的我似乎还没意识到时间过去这么快。每天几乎重复的生活很能麻痹一个人的神经，闲下来的时间不敢去思考未来何去何从，也不敢让自己沉溺在过去的记忆中。所以只好找事情做，让自己忙起来，Too busy to think about now. 白天去实验室学东西，有时候去值班，晚上9点回寝室玩玩游戏看看视频放松一下。 前几天看到的一篇博客有很大感触，就想着什么时候为过去做个关于时间的总结吧。因为随着时间的推移，我明白了很多事情如果不及时记录下来，这些记忆自己会渐渐模糊，甚至将会有一天我们自己都记不清那些我们自己作为主角的故事了。 两年前时间倒回到两年前，刚刚步入大学的我，有期待，有遗憾，有失落，有后悔。 期待的是大学生活，高中老师对于大学的美好描绘，是我们那个天天被题目淹没的时候我们不断努力的动力之一。高中老师以前向我们描绘着“远处杨梅”，我们听了以后，个个对着远方的杨梅垂涎欲滴，短暂的做梦后手里的笔又握的更紧，字写得更快，心中暗暗想着，熬过这段时间就好了。 站在我现在这个时间节点，如果说我非得评论一下当初想象的杨梅甜不甜美，我的答案将会是“不是那么甜美，甚至还有苦味”。要我说，这个答案到底如何还是看个人吧。大学生活精不精彩，除了外界因素，自己也是一个重要的主导方面。 遗憾失落的事情无非就是高考的那一次没有考出我平时的状态和水平吧。摆在那个时候的我的面前有两个选择，一个是重新再读一年高三，再考一次高考；另一个选择是接受当前的现实。几番权衡之后，我选择了后者，而和我一样遭遇滑铁卢的朋友，甚至差不多可以说和我面对差不多处境选择的朋友，他选择了前者。不同的选择将会有不同的结果，或者说也会有一些事情并不受这些选择的影响。那个时候的我们，谁也不知道未来会发生什么，只能做好当前的选择，等待结果的到来。如果有机会的话，我后面再详细写写关于他的故事。 后悔的事情大致就是高二和高三被很多事情分神。 两年前的我，还不知道未来将会有什么等着我，我也希望能是好的事情即将发生，然而不幸的是，后来很多一连串的事情就如暴风雨一般接二连三地敲打着巨浪之中的破旧船只。 两年前也就是我大一，估计是我高考成绩太差，本来填的计算机专业结果被调剂到了土木工程学院，差点我又想着回去再读一年了。后来想到过一个学期可以转专业，我就打消了那个念头。 而我也没想到这只是错位的开始。 在土木道桥待了一个学期后，差不多到期末了我准备去申请转专业，这过去的一个学期里没有挂过科，成绩都还算靠前，应该符合转专业的规定吧。然而令我始料不及的是，土木学院规定所有人大一上学期都不准转出去，我就觉得这有点离谱。无奈我只是一个17新生，也没什么其他特殊手段，只得服从安排。 这也就意味着，我只有大二才有机会转出去。 后面有时间再更…. 2019/10/19 更2019/10/12，距离上次去长沙已经过去十个多月，因为参加比赛，又一次来到这座熟悉又陌生的城市，心中其实感慨很多。本想着13号回来的那天写下心中的所想，谁想到回来的路上感冒了，到今天感觉好很多，所以闲下来写点东西。 12号下午我们一行人提着参赛设备来到火车站广场，这里和我记忆里的没有多大变化，广场有的行人匆匆，有的人坐在花坛旁，有的人在出站口，似乎着急等待着某个人。进站口有一些小贩幺和着卖东西。进站口的两段楼梯，楼梯尽头的玻璃门像一根刺刺进我心里。 十个月零十九天前的这个时候，刺骨的雨雪肆虐着广场的每一个行人，我只带了一把伞，背了一个包，包里放着这几年来我往返两地的火车票，做成纪念册，却没有机会填满整本纪念册，也没有机会在最重要的那天送给重要的人。去车站的路上我们十分有默契地一句话也没说，到了车站，我撑开雨伞，走过两段楼梯，到了尽头的玻璃门前，我们不约而同准备开口准备说话， 她说：你先说。 我从背包里慢慢小心地拿出纪念册，递给了她，想说点什么却又不知道怎么开始。 她也从包里拿出一本线圈的本子。一直没说话的她，这个时候欲言又止。 我低着头，没敢直视她，只听到她似乎抽泣了一下，只说了一句声音很低的话，“抱一下吧”，听到这句话，我强忍着眼泪。在我们最后利落干脆的拥抱中，她对我说了一句“好好照顾自己”，我似乎还在挣扎，对她说了一句“回来好不好”。她没有回答，拿着东西回头走进玻璃门里面。透过玻璃门，看着她的背影进入候车厅越走越远，我异常冷静，直到我看不见了，我的视线渐渐模糊，我一转身，撑开伞，想起随手翻翻手中的线圈本，才发现一些页面有字，“最近天气变冷了，记得多加衣服。”，再也掩饰不了，眼眶模糊到再也看不清楚字迹… 我回来神来，轻声叹息，提着设备大步向楼梯走去。 两地的车站承载了我太多的记忆，有过很多期待，有过很多不舍，现在最多的却是遗憾。我曾在刺骨寒夜中跨越人山人海，只为见到期待的人，一起去进行我计划中期待的旅行，我曾一人孤独在烈日下踏上归途，无人问津。我曾有一个理由跋山涉水，跨越险阻，现在这些都是过去，都是记忆。十个月，差不多一年，感觉久远，但又十分清晰，恍如昨日。 2019/10/12晚饭后，我一个人先去了楼上房间，准备打开电脑再复习一遍项目代码。 房间正好面对着马路，窗外的车鸣声、人声混杂在一起。这座城市还是一样的繁华。看着窗外车来车往我有些莫名失落。 我打开地图，看了我现在的位置，我在湘江的东边。想来今天是星期六，此时她应该在宿舍吧，那就是正好在湘江的西边。一个荒诞的假设跳进了我的脑中：假如我们还没有分开的话，她会来我现在这里吗？比赛完后还可以在林业大学–一个我们都不熟悉的大学转转。 我笑了笑自己的愚蠢。 一想到13号就要正式比赛了，其实心里很紧张。可能是因为为了这次比赛我们准备了暑假一大段时间吧。大概是我不想辜负老师，同学以及自己吧。 此时的时间似乎过得很快，很快就晚上十一、十二点了。躺下后还是久久不能入睡。时间似乎又变得很慢。 终于熬到第二天早上，我们七点就下楼，随意吃点早餐后准备出发去比赛的场地了。来的时候没想到会这么冷，只是穿了一件衣服的我有些后悔没有带件外套来。 这次比赛出乎意外的简单。出了比赛场地后，一个悬着的心终于放下。心情也轻松了很多。 13号下午，我们一行人准备回学校了。不幸的是，路上出了汗后吹了冷风，我不出意外地感冒了。 在回去的路上，途经海立方海洋公园。 那时八月烈阳当空，赶在开学前的几天去的那里。 微冷的风迎着面吹来，把我拉回了现实。曾去过眼前的风景，过去与现实交织在一起，有那么一瞬间我忘记了所有。 回学校后感冒了几天。 2019/11/1 更今天下午，支付宝突然来了一个通知。点开后，只是过去。 Memories are hunting me in some differents ways. 后会有期 ，本文随缘更新","categories":[{"name":"随笔","slug":"随笔","permalink":"https://Stefancharles.xyz/categories/随笔/"}],"tags":[]},{"title":"【Zigbee】温湿度采集实验","slug":"getTemperature","date":"2019-10-26T16:00:00.000Z","updated":"2019-10-30T02:51:01.110Z","comments":true,"path":"2019/10/27/getTemperature/","link":"","permalink":"https://Stefancharles.xyz/2019/10/27/getTemperature/","excerpt":"简介最近学习通上老师布置温湿度采集实验作业的实验。实验过程中，在不同的开发板上烧录同一份代码最后结果不一样，有的甚至通过串口助手返回的是乱码。所以建立本博客，记录问题。","text":"简介最近学习通上老师布置温湿度采集实验作业的实验。实验过程中，在不同的开发板上烧录同一份代码最后结果不一样，有的甚至通过串口助手返回的是乱码。所以建立本博客，记录问题。 实验要求 温湿度采集实验（可以采集芯片内温感器也可以是芯片外的DHT11的温湿度传感器的数据，然后通过串口送出来，通过串口助手可以看到采集到数据） 实验环境 IAR v10.30.1 Win10 1903 串口调试助手 v4.13.3 ADC温度代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;ioCC2530.h&gt;#include &lt;string.h&gt;void initUART0(void);void Send_String(unsigned char *Data, int len);unsigned int getTemperature(void);unsigned char str1[40]=\"Please wait for a moment\";unsigned int AvgTemp;/********************************************************************* 函数名 :initUART0(void)* 函数功能:初始化串口0函数* 输入 : void* 输出 : 无********************************************************************/void initUART0(void)&#123; CLKCONCMD &amp;= ~0x40;//设置系统时钟源32MHz晶振 while(CLKCONSTA&amp;0x40);//等待晶振稳定 CLKCONCMD&amp;=~0x47;//设置系统主时钟频率32MHz PERCFG= 0x00;//位置1P0口 P0SEL=0x3C;//P0口是串口 P2DIR&amp;=~0xC0;//P0优先作为UART0 U0CSR|=0x80;//串口设置为UART方式 U0GCR|=9; U0BAUD|=59;//波特率19200 UTX0IF=1;//UART0 TX中断标志初始为1 U0CSR|=0x40;//允许接受 IEN0|=0x84;//开总中断，接受中断&#125;/********************************************************************* 函数名 : getTemperature(void)* 函数功能:获取片内温度* 输入 : void* 输出 : unsigned int ********************************************************************/unsigned int getTemperature(void)&#123; char i; unsigned int AdcValue; unsigned int value; for(i=0;i&lt;4;i++) &#123; ADCCON3|=0x3E; ADCCON1|=0x40;//使用1.25V内部电压 while (!(ADCCON1&amp;0x80)); value=ADCL&gt;&gt;2; value|=((unsigned int )ADCH&lt;&lt;6); AdcValue+=value; &#125; value=AdcValue&gt;&gt;2; return value*0.0629-303.3;&#125;/********************************************************************* 函数名 :Send_String(unsigned char *Data, int len)* 函数功能:串口发送字符串函数* 输入 : void* 输出 : 无********************************************************************/void Send_String(unsigned char *Data, int len)&#123; unsigned int j; for(j=0;j&lt;len;j++) &#123; U0DBUF=*Data++; while (UTX0IF==0); UTX0IF=0; &#125;&#125;/********************************************************************* 函数名 :MAIN* 函数功能:主函数* 输入 : void* 输出 : 无********************************************************************/void main(void)&#123; P1DIR=0x03;//LED开 initUART0(); Send_String(str1,40); unsigned char strtemp[3]; AvgTemp=0; AvgTemp=getTemperature(); strtemp[0]=( unsigned char )AvgTemp/10+0x30; strtemp[1]=( unsigned char )AvgTemp%10+0x30; strtemp[2]='\\0'; Send_String(strtemp,3);&#125;#pragma vector=URX0_VECTOR__interrupt void UART0_ISR(void)&#123; URX0IF=0;//清中断标志&#125; 解析getTemperature()这个函数是本次的重点。ADCCON3|=0x3E;0011 1110：使用内部参考电压，12位分辨率，片内温度传感器ADCCON1|=0x40;0100 0000：启动AD转化while (!(ADCCON1&amp;0x80))：等待 AD 转换完成。value=ADCL&gt;&gt;2;value|=((unsigned int )ADCH&lt;&lt;6);ADCL寄存器低两位无效。For循环4次累加后再求平均值。 烧录代码 后面的17是得出的温度数值。单位摄氏度。 待解决的问题用同一个代码在不同的开发板上进行烧录测试时结果会不同。甚至有的串口助手里还返回了乱码。return value*0.0629-303.3;这里公式是参考教材上的，但是不知道如何的来的，也不知道正确性。 补充关于温度计算公式，大致是AD值与温度之间有个函数关系。这里可以参考TI公司的文档。 点击这里访问文档 后面再试试用芯片外的DHT11的温湿度传感器。 DHT11温湿度传感器DHT11的工作原理DHT11使用单一总线通信，DATA引脚和开发板单一相连接。如图所示，这是我所用的开发板原理图。DATA引脚在P0口的第4位。其总线总处于通信状态或者空闲状态。 当开发板没有和DHT11进行通信时，总线处于空闲状态，在上拉电阻的作用下，处于高电平状态； 当开发板和DHT11正在通信时，总线处于通信状态 一次完整的通信过程如下： 1.开发板把驱动总线IO配置为输出模式，准备向DHT11发送数据。 2.开发板将总线拉低至少18ms，以此来发送起始信号。再将总线拉高并延时20~40us，以此来代表起始信号结束。 3.开发板将驱动总线的IO配置为输入模式，准备接收DHT11回传的数据。 4.当DHT11检测倒单片机发送的起始信号后，就开始应答，回传采集到的传感器数据。DHT11先将总线拉低80us作为对单片机的应答（ACK），然后接着将总线拉高80us，准备回传采集到的温湿度数据。温湿度数据以固定的帧格式发送。 5.当一帧数据传输完成后，DHT11释放总线，总线在上拉电阻的作用下再次恢复到高电平状态。 固定的帧格式格式如下图： 总过程如下图： 可以发现一帧为40个bit，而每一个bit的传输时序逻辑为：每一个bit都以50us的低电平（DHT11将总线拉低）为先导，然后紧接着DHT11拉高总线，如果这个高电平持续时间为26~28us，则代表逻辑0，如果持续70us则代表逻辑1。 关于DHT11需要注意 1.DHT11上电后，要等待 1秒 以越过不稳定状态，在此期间不能发送任何指令。 2.DHT11属于低速传感器，两次通信请求之间的间隔时间不能太短，一般来说要不能低于1秒。 3.当前DHT11通信帧的小数部分默认都是0，厂商预留给以后实现。所以一般只读取整数值部分即可。校验和定义为：前4个Byte的总和的低8位。 DHT11实现代码 后面有时间再更新，目前我需要跟上opencv进度 需要联系我？请发邮件 我的邮箱：stefancharles@vip.qq.com","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"【Zigbee】串口收发实验","slug":"UART","date":"2019-10-25T16:00:00.000Z","updated":"2019-10-26T08:00:41.043Z","comments":true,"path":"2019/10/26/UART/","link":"","permalink":"https://Stefancharles.xyz/2019/10/26/UART/","excerpt":"简介最近学习通上老师布置串口收发作业的实验。与51单片机不同的是，2530配置串口稍微麻烦一些。所以记录下来。","text":"简介最近学习通上老师布置串口收发作业的实验。与51单片机不同的是，2530配置串口稍微麻烦一些。所以记录下来。 实验要求串口收发实验（从串口助手发送一个字符或者一个字符串到开发板，开发板又将收到的字符或者字符串回送到串口助手上） 实验环境 IAR v10.30.1 Win10 1903 串口调试助手 v4.13.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;ioCC2530.h&gt;#include &lt;string.h&gt;void initUART0(void);void Send_String(unsigned char *Data, int len);unsigned char str1[45]=\"Please send a string with a '#' in the end\";unsigned char Recdata[25];unsigned char RXTXflag=1;unsigned char temp;unsigned int datanumber=0;unsigned int stringlen;/********************************************************************* 函数名 :initUART0(void)* 函数功能:初始化串口0函数* 输入 : void* 输出 : 无********************************************************************/void initUART0(void)&#123; CLKCONCMD &amp;= ~0x40;//设置系统时钟源32MHz晶振 while(CLKCONSTA&amp;0x40);//等待晶振稳定 CLKCONCMD&amp;=~0x47;//设置系统主时钟频率32MHz PERCFG= 0x00;//位置1P0口 P0SEL=0x3C;//P0口是串口 P2DIR&amp;=~0xC0;//P0优先作为UART0 U0CSR|=0x80;//串口设置为UART方式 U0GCR|=9; U0BAUD|=59;//波特率19200 UTX0IF=1;//UART0 TX中断标志初始为1 U0CSR|=0x40;//允许接受 IEN0|=0x84;//开总中断，接受中断&#125;/********************************************************************* 函数名 :Send_String(unsigned char *Data, int len)* 函数功能:串口发送字符串函数* 输入 : void* 输出 : 无********************************************************************/void Send_String(unsigned char *Data, int len)&#123; unsigned int j; for(j=0;j&lt;len;j++) &#123; U0DBUF=*Data++; while (UTX0IF==0); UTX0IF=0; &#125;&#125;/********************************************************************* 函数名 :MAIN* 函数功能:主函数* 输入 : void* 输出 : 无********************************************************************/void main(void)&#123; P1DIR=0x03;//LED开 initUART0(); Send_String(str1,45); while (1) &#123; if (RXTXflag==1)//接受状态 &#123; if (temp!=0) &#123; if ((temp!='#')&amp;&amp;(datanumber&lt;25)) &#123; Recdata[datanumber++]=temp; &#125; else &#123; RXTXflag=3; &#125; temp=0; &#125; &#125; if (RXTXflag==3)//发送状态 &#123; U0CSR&amp;=~0x40;//关闭接受 Send_String(Recdata,datanumber); U0CSR|=0x40;//开接收 RXTXflag=1;//接收状态 datanumber=0; &#125; &#125; &#125;/********************************************************************* Stefan ********************************************************************/#pragma vector=URX0_VECTOR__interrupt void UART0_ISR(void)&#123; URX0IF=0;//清中断标志 temp=U0DBUF;&#125; 解析首先看硬件原理图： 确定串口在P0口。把初始化都封装在void initUART0(void)函数中，主要看下其中需要初始化哪些寄存器和如何初始化。先在芯片资料手册中找到关于CLKCONCMD的详细说明如下图： 一共8位，0-2位这三位用于设置Clock speed，也就是时钟速度。3-5位用于设置定时器输出配置。这两个各占据三位，也就是各有8种配置可以选择。6bit位用于设置系统时钟频率，7bit位设置32kHZ时钟源的选择，其中xosc是指外部的晶振给系统提供clock，rcosc是指单片机内部的RC震荡电路提供系统clock。 123CLKCONCMD &amp;= ~0x40;//设置系统时钟源32MHz晶振while(CLKCONSTA&amp;0x40);//等待晶振稳定CLKCONCMD&amp;=~0x47;//设置系统主时钟频率32MHz 然后按照说明取相应的值，使用&amp;=是为了不改变CLKCONCMD的其他位。下面再看： 123456PERCFG= 0x00;//位置1P0口P0SEL=0x3C;//P0口是串口P2DIR&amp;=~0xC0;//P0优先作为UART0U0CSR|=0x80;//串口设置为UART方式U0GCR|=9;U0BAUD|=59;//波特率19200 在前面的LED实验中，当这些IO引脚用作通用IO时，需要设置对应的PxSEL位为0。这里我们串口需要实现片内外设IO功能，所以需要设置对应的PxSEL为1。 PERCFG寄存器用于设置定时器和USART使用位置1还是备用位置2。这里结合硬件电路图设置PERCFG，USART 0使用位置1，P0_2 ,P0_3口 结合引脚映射表格所以设置PERCFG= 0x00。从硬件原理图可以看出，有些I/O位置是重叠的，可以通过寄存器P2SEL和P2DIR来设置优先级，选择端口2引脚的I/O功能（通用I/O还是外设I/O）和方向（作为输入还是输出）。 根据上面这个图设置P0优先作为UART0。 串口USART0和USART1均有两种模式：异步UART模式和同步SPI模式。根据上图设置相应的位。下面设置串行通信接口寄存器波特率 U0GCR|=9; U0BAUD|=59;对照上面的图不难设置波特率为19200。 烧录代码这里我打开串口助手。可以看到串口助手收到了来自板子的传递来的字符串。然后我们发送字符串给板子。我打算发送I can see you#。以#代表结尾。可以看到的是，这里收到了来自开发板的回复。至此，开发板又将收到的字符或者字符串回送到串口助手上。实验完成。 需要联系我？请发邮件 我的邮箱：stefancharles@vip.qq.com","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Zigbee","slug":"Zigbee","permalink":"https://Stefancharles.xyz/tags/Zigbee/"}]},{"title":"OpenCV形态学操作","slug":"morphology","date":"2019-10-07T16:00:00.000Z","updated":"2019-10-08T04:25:34.488Z","comments":true,"path":"2019/10/08/morphology/","link":"","permalink":"https://Stefancharles.xyz/2019/10/08/morphology/","excerpt":"形态学概述在图像处理技术中，有一些的操作会对图像的形态发生改变，这些操作一般称之为形态学操作。形态学操作的对象是二值化图像。有名的形态学操作中包括腐蚀，膨胀，开操作，闭操作等。其中腐蚀，膨胀是许多形态学操作的基础。","text":"形态学概述在图像处理技术中，有一些的操作会对图像的形态发生改变，这些操作一般称之为形态学操作。形态学操作的对象是二值化图像。有名的形态学操作中包括腐蚀，膨胀，开操作，闭操作等。其中腐蚀，膨胀是许多形态学操作的基础。 腐蚀和膨胀腐蚀和膨胀能实现的功能： 消除噪声 分割(isolate)出独立的图像元素，在图像中连接(join)相邻的元素。 寻找图像中的明显的极大值区域或极限值区域。 求图像的梯度 注意：腐蚀和膨胀是对高亮部分而言的，也就是白色的区域。不是黑色区域。膨胀是对高亮部分进行膨胀。腐蚀是对高亮部分进行腐蚀。 开运算开运算就是对图像先腐蚀，再膨胀。 1dst = open(src , element) = dilate(erode(src, element)) 开运算可以用来消除小物体，在纤细点处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积。 闭运算闭操作就是对图像先膨胀，再腐蚀。 1dst = close(src , element) = erode(dilate(src, element)) 闭运算可以排除小型黑色区域。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://Stefancharles.xyz/tags/OpenCV/"}]},{"title":"应用MVP架构对Android课程表重构","slug":"projects/ClassSchedule","date":"2019-10-02T16:00:00.000Z","updated":"2019-10-02T16:00:00.000Z","comments":true,"path":"2019/10/03/projects/ClassSchedule/","link":"","permalink":"https://Stefancharles.xyz/2019/10/03/projects/ClassSchedule/","excerpt":"应用MVP架构对Android课程表重构最初的课程表是由林博主开发而成。但是代码冗余的部分很多，UI也不够现代化。所以现在我应用MVP架构对课程表软件进行重构。另外使用Material Design重新设计UI。 文中若有不正确的地方，还请多多指教。","text":"应用MVP架构对Android课程表重构最初的课程表是由林博主开发而成。但是代码冗余的部分很多，UI也不够现代化。所以现在我应用MVP架构对课程表软件进行重构。另外使用Material Design重新设计UI。 文中若有不正确的地方，还请多多指教。 1.MVP分别指什么？对于一个应用而言我们需要对它抽象出各个层面，而在MVP架构中它将UI界面和数据进行隔离，所以我们的应用也就分为三个层次。 M：M层，也就是我们在程序中经常出现的model层，他的功能就是处理数据，其他任务不由他来接手。区别于MVC架构中的Model，在这里不仅仅只是数据模型。在MVP架构中Model它负责对数据的存取操作，例如对数据库的读写，网络的数据的请求等。在Android开发中通常将Activity或者Fragment作为View层。 V：V层，我们的view层，也就是显示数据的地方，我们在得到数据之后，把数据传递给view层，通过他来显示数据。同时，view层的点击事件等处理会在这里出现，但真正的数据处理不是在这里，而是在model层中处理。 P：P层，也就是Presenter层，他是我们mvp架构中的中间人，通过p层的连接，让我们可以让M层和V层进行通信。M层在获取到数据之后，把它交给P，P层在交给View层，同样，View层的点击事件等处理通过P层去通知M层，让他去进行数据处理。 这里我用一个图来大致说明MVP三者之间的关系。 在Presenter层它会从Model层获得所需要的数据，进行一些适当的处理后交由View层进行显示。这样通过Presenter将View与Model进行隔离，使得View和Model之间不存在耦合，同时也将业务逻辑从View中抽离。 用一位博主的比较专业的话来说： 在MVP架构中将这三层分别抽象到各自的接口当中。通过接口将层次之间进行隔离，而Presenter对View和Model的相互依赖也是依赖于各自的接口。这点符合了接口隔离原则，也正是面向接口编程。在Presenter层中包含了一个View接口，并且依赖于Model接口，从而将Model层与View层联系在一起。而对于View层会持有一个Presenter成员变量并且只保留对Presenter接口的调用，具体业务逻辑全部交由Presenter接口实现类中处理。 2.总体结构 1.我们把课程表的数据，数据库的读写，网络的请求操作放在data包内。这里就算是Model层。 2.utils下面放置一些本项目使用的工具类。 3.在最外层存放了两个接口，即BasePresenter和BaseView。它们是Presenter层接口和View层接口的基类，项目中所有的Presenter接口和View层接口都继承自这两个接口。 BasePresenter: 123456package com.stefan.classscheduleforusc;public interface BasePresenter &#123; void start(); void onDestroy();&#125; 在BasePresenter中只存在一个start方法和onDestroy方法。start方法一般所执行的任务是在Presenter中从Model层获取数据，并调用View接口显示。start这个方法一般是在Fragment中的onResume方法中调用。onDestroy方法用来remove 一个activity。 BaseView: 12345package com.stefan.classscheduleforusc;public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; 在BaseView中只有一个setPresenter方法，对于View层会存在一个Presenter对象。而setPresenter正是对View中的Presenter进行初始化。 4.在mvp这个包中，我们存放主要的功能模块，内部结构如图： 在每个功能模块下面将类分作xxActivity,xxFragment,xxPresenter,xxContract等。也正是这些类构成了项目中的Presenter层与View层。 3.Contract：契约类Contract：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。 我们以导入课程表这一功能为例子： 其ImptContract代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.stefan.classscheduleforusc.mvp.impt;import android.widget.ImageView;import com.stefan.classscheduleforusc.BasePresenter;import com.stefan.classscheduleforusc.BaseView;import com.stefan.classscheduleforusc.data.bean.CourseTime;/** * Created by stefan on 2019/10/03. */public interface ImptContract &#123; interface Presenter extends BasePresenter &#123; void importCustomCourses(String courseTime, String term); void importDefaultCourses(String courseTime, String term); void loadCourseTimeAndTerm(String xh, String pwd, String captcha); void getCaptcha(); &#125; interface View extends BaseView&lt;Presenter&gt; &#123; ImageView getCaptchaIV(); void showImpting(); void hideImpting(); void captchaIsLoading(boolean isLoading); void showErrToast(String errMsg, boolean reLoad); void showSucceed(); void showCourseTimeDialog(CourseTime times); &#125; interface Model &#123; void getCaptcha(ImageView iv); &#125;&#125; 在这里将Presenter中的接口和View的接口都放在了ImptContract类里面。这样一来我们能够更清晰的看到在Presenter层和View层中有哪些功能，方便我们以后的维护。我寻思着这应该就是它被叫做“契约类”的原因吧。 Presenter的实现在ImptPresenter.java中，View的实现在ImptActivity.java中。 待完成，明天见致谢最后， 感谢林博主的支持和指导。点击这里可以关注他的个人博客。 感谢一些csdn博主的博客，点击这里访问我参考的博客文章。 感谢Github上的很多开源代码： 12345678910111213141516com.android.support:designcom.android.support:appcompat-v7com.android.support.constraint:constraint-layoutorg.jsoup:jsoupio.reactivex.rxjava2:rxandroidio.reactivex.rxjava2:rxjavaorg.greenrobot:eventbusorg.greenrobot:greendaocom.mnnyang.ClassSchedulecom.google.code.gson:gsonjp.wasabeef:glide-transformationsde.hdodenhof:circleimageviewcom.zhy:okhttputilscom.github.yuzhiqiang1993:zxingcom.github.franmontiel:PersistentCookieJarcom.github.didikee:AndroidDonate","categories":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/categories/Android/"},{"name":"MVP","slug":"Android/MVP","permalink":"https://Stefancharles.xyz/categories/Android/MVP/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://Stefancharles.xyz/tags/MVP/"}],"author":"Stefan and Lin"},{"title":"OpenCV On Android的车牌识别","slug":"projects/CarPlateIdentity","date":"2019-09-25T16:00:00.000Z","updated":"2019-09-25T16:00:00.000Z","comments":true,"path":"2019/09/26/projects/CarPlateIdentity/","link":"","permalink":"https://Stefancharles.xyz/2019/09/26/projects/CarPlateIdentity/","excerpt":"OpenCV On Android的车牌识别现在已经是9月底了，下个月就要去参加新大陆物联网比赛。在那个比赛中我主要负责安卓端代码的编写。10月的比赛一结束又要全力投入OpenCV中。所以我在想，为什么不做一个基于OpenCV 的安卓端的车牌识别呢？这样一来可以锻炼安卓端代码编写能力，又可以为后续的学习打下一个基础。 文章中借鉴了很多前人的轮子和一些算法思想，在此表示感谢。另外本文的疏漏之处在所难免。希望当你看到我的这篇博客时，如果发现我的错误，请指出。感激不尽。","text":"OpenCV On Android的车牌识别现在已经是9月底了，下个月就要去参加新大陆物联网比赛。在那个比赛中我主要负责安卓端代码的编写。10月的比赛一结束又要全力投入OpenCV中。所以我在想，为什么不做一个基于OpenCV 的安卓端的车牌识别呢？这样一来可以锻炼安卓端代码编写能力，又可以为后续的学习打下一个基础。 文章中借鉴了很多前人的轮子和一些算法思想，在此表示感谢。另外本文的疏漏之处在所难免。希望当你看到我的这篇博客时，如果发现我的错误，请指出。感激不尽。 1.准备工作一、下载OpenCV-android-sdk 这里我使用OpenCV Android 3.4.6 版本点击这里下载 二、新建AS项目，依赖OpenCV 在AS新建一个新项目名字Plate_Recognition，然后在 APP 上右键 New—–&gt; Module 在弹窗里选择 Import Eclipse ADT Project 点Next 。选择你刚才解压的OpenCV目录下的 sdk/java 目录 点击 OK ,然后填下 Module Name ,例如填 “openCVLibrary346” 然后 点Next —–&gt; Finish。 但是，gradle会报错。如图所示： 不要慌张，打开刚导入的OpenCV 的 AndroidManifest.xml 删除 这行代码。如下图所示： 接下来再gradle一下就好了。 再打开 OpenCV 的 build.gradle 文件，把版本改成和APP 的build.gradle 文件一致的版本，另外还要删除 buildToolsVersion “29.0.0” 这一行， 如下图： 在APP 的 build.gradle 加入 implementation project(path: ‘:openCV’) 这行代码 ，然后再gradle一下项目。 然后添加 SO 文件。 这里插播一下什么是SO文件？ SO文件是Linux下共享库文件，它的文件格式被称为ELF文件格式。由于Android操作系统的底层基于Linux系统，所以SO文件可以运行在Android平台上。Android系统也同样开放了C/C++接口供开发者开发Native程序。由于基于虚拟机的编程语言JAVA更容易被人反编译，因此越来越多的应用将其中的核心代码以C/C++为编程语言，并且以SO文件的形式供上层JAVA代码调用，以保证安全性。 如果想要了解更深入，可以去谷歌一下SO文件。这里就不作过多的深入讨论。 我们这里，在App 的 buidl.gradle 中 defaultConfig 下加入ndk的配置： 在main下新建jinLibs 目录 ，把OpenCV SDK 的解压目录下 sdk/native/libs/armeabi-v7a 目录拷到 jniLibs 下 好了OpenCV 现在完成了，接下来检验下是否可用。 在MainActivity.java中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.stefan.plate_recognition;//import...public class MainActivity extends AppCompatActivity &#123; private final String TAG = getClass().getSimpleName(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, \"With codes ,change world.\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); &#125; &#125;); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; @SuppressLint(\"StaticFieldLeak\") @Override public void onManagerConnected(int status) &#123; super.onManagerConnected(status); if (status == LoaderCallbackInterface.SUCCESS) &#123; Log.d(TAG, \"OpenCV 加载成功\"); &#125; else &#123; Log.d(TAG, \"OpenCV 加载失败\"); &#125; &#125; &#125;; @Override protected void onResume() &#123; super.onResume(); if (!OpenCVLoader.initDebug()) &#123; Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\"); OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_4_0, getApplicationContext(), mLoaderCallback); &#125; else &#123; Log.d(TAG, \"OpenCV library found inside package. Using it!\"); mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS); &#125; &#125;&#125; 然后连接手机运行程序，值得注意的是，这里应该使用不了模拟器，模拟器不支持arm。 接下来应该可以看到log打印信息。 到这里说明OpenCV可以正常使用。 2.配置NDK，编译库文件 Android NDK 是一套允许您使用 C 和 C++ 等语言，以原生代码实现部分应用的工具集。在开发某些类型的应用时，这有助于您重复使用以这些语言编写的代码库。 目前的NDK版本已经到了r20了。但是我们暂时不使用新版本。先按照网上的其他作者的轮子学习一下，等到熟悉了过程再换新版本的NDK。 这里我们下载NDK-r14b的版本。点击这里下载地址 下载完成后，在项目中添加NDK依赖。 配置好NDK，我们在main目录下面新建 jin 目录 ，然后把Demo库下载下来，把里面的 app/src/main/jni 目录下的 include 、src、还有javaWarpper.cpp 文件复制到 jni 目录下，把 assets/lpr/ 目录下的文件全部复制到我们项目的 assets目录下的lpr文件夹。如下图： 然后项目 app文件下新建 CMakeLists.txt 文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Sets the minimum version of CMake required to build the native# library. You should either keep the default value or only pass a# value of 3.4.0 or lower.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds it for you.# Gradle automatically packages shared libraries with your APK.include_directories(src/main/jni/include)include_directories(src/main/jni)aux_source_directory(src/main/jni SOURCE_FILES)aux_source_directory(src/main/jni/src SOURCE_FILES_CORE)list(APPEND SOURCE_FILES $&#123;SOURCE_FILES_CORE&#125;)#修改修改为自己的opencv-android-sdk 的JNI路径set(OpenCV_DIR D:/OpenCV-android-sdk/sdk/native/jni)find_package(OpenCV REQUIRED)add_library( # Sets the name of the library. lpr # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # Associated headers in the same location as their source # file are automatically included. $&#123;SOURCE_FILES&#125;)# Searches for a specified prebuilt library and stores the path as a# variable. Because system libraries are included in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log)# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in the# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. lpr $&#123;OpenCV_LIBS&#125; # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;) 接下来修改 app的build.gradle 文件，最终配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455apply plugin: 'com.android.application'android &#123; compileSdkVersion 29 buildToolsVersion \"29.0.0\" defaultConfig &#123; applicationId \"com.stefan.plate_recognition\" minSdkVersion 28 targetSdkVersion 29 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" ndk &#123; //选择要添加的对应 cpu 类型的 .so 库。 abiFilters 'armeabi-v7a' // 还可以添加 'x86', 'x86_64', 'mips', 'mips64' //moduleName \"native-lib\" //abiFilters \"x86\",\"x86_64\",\"arm64-v8a\" &#125; externalNativeBuild &#123; cmake &#123; cppFlags \"-std=gnu++11\" // 注意！！！！ 注意！！！！！！ //如果是用 Linux 开发的的用户下面这行代码不用动，如果是 Win 用户请把 下面这行代码注释了 //arguments \"-DANDROID_TOOLCHAIN=gcc\", \"-DANDROID_ARM_NEON=TRUE\", \"-DANDROID_STL_FORCE_FEATURES=OFF\" &#125; &#125; &#125; externalNativeBuild &#123; cmake &#123; path \"CMakeLists.txt\" &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'androidx.appcompat:appcompat:1.1.0' implementation 'androidx.constraintlayout:constraintlayout:1.1.3' implementation 'com.google.android.material:material:1.0.0' testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test:runner:1.2.0' androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0' implementation project(path: ':openCVLibrary346')&#125; 在项目下新建PlateRecognition 类： 1234567891011121314151617181920212223package com.stefan.platerecognition.utils;/** * @auther : Stefan * time : 2019/09/29 */public class PlateRecognition &#123; static &#123; System.loadLibrary(\"lpr\"); &#125; static native long InitPlateRecognizer(String casacde_detection, String finemapping_prototxt, String finemapping_caffemodel, String segmentation_prototxt, String segmentation_caffemodel, String charRecognization_proto, String charRecognization_caffemodel, String segmentation_free_prototxt, String segmentation_free_caffemodel); static native void ReleasePlateRecognizer(long object); public static native String SimpleRecognization(long inputMat, long object);&#125; 这里包名和我不一样，到javaWartpper.cpp 文件修改成和你对应的。 DeepAssetUtil： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.stefan.platerecognition.utils;import android.content.Context;import android.os.Environment;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class DeepAssetUtil &#123; public static final String ApplicationDir = \"lpr\"; public static final String CASCADE_FILENAME = \"cascade.xml\"; public static final String HORIZONAL_FINEMAPPING_PROTOTXT = \"HorizonalFinemapping.prototxt\"; public static final String HORIZONAL_FINEMAPPING_CAFFEMODEL = \"HorizonalFinemapping.caffemodel\"; public static final String SEGMENTATION_PROTOTXT = \"Segmentation.prototxt\"; public static final String SEGMENTATION_CAFFEMODEL = \"Segmentation.caffemodel\"; public static final String RECOGNIZATION_PROTOTXT = \"CharacterRecognization.prototxt\"; public static final String RECOGNIZATION_CAFFEMODEL = \"CharacterRecognization.caffemodel\"; public static final String FREE_INCEPTION_PROTOTXT = \"SegmenationFree-Inception.prototxt\"; public static final String FREE_INCEPTION_CAFFEMODEL = \"SegmenationFree-Inception.caffemodel\"; public static final String SDCARD_DIR = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + ApplicationDir; //解压文件存放位置 private static void CopyAssets(Context context, String assetDir, String dir) &#123; String[] files; try &#123; // 获得Assets文件 files = context.getAssets().list(assetDir); &#125; catch (IOException e1) &#123; return; &#125; File mWorkingPath = new File(dir); // 如果文件路径不存在 if (!mWorkingPath.exists()) &#123; // 创建文件夹 if (!mWorkingPath.mkdirs()) &#123; // 文件夹创建不成功时调用 &#125; &#125; for (String file : files) &#123; try &#123; // 根据路径判断是文件夹还是文件 if (!file.contains(\".\")) &#123; if (0 == assetDir.length()) &#123; CopyAssets(context, file, dir + file + \"/\"); &#125; else &#123; CopyAssets(context, assetDir + \"/\" + file, dir + \"/\" + file + \"/\"); &#125; continue; &#125; File outFile = new File(mWorkingPath, file); if (outFile.exists()) continue; InputStream in; if (0 != assetDir.length()) &#123; in = context.getAssets().open(assetDir + \"/\" + file); &#125; else &#123; in = context.getAssets().open(file); &#125; OutputStream out = new FileOutputStream(outFile); // Transfer bytes from in to out byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; in.close(); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void copyFilesFromAssets(Context context) &#123; DeepAssetUtil.CopyAssets(context, ApplicationDir, SDCARD_DIR); &#125; //初始化识别资源 public static long initRecognizer(Context context) &#123; String cascade_filename = SDCARD_DIR + File.separator + CASCADE_FILENAME; String finemapping_prototxt = SDCARD_DIR + File.separator + HORIZONAL_FINEMAPPING_PROTOTXT; String finemapping_caffemodel = SDCARD_DIR + File.separator + HORIZONAL_FINEMAPPING_CAFFEMODEL; String segmentation_prototxt = SDCARD_DIR + File.separator + SEGMENTATION_PROTOTXT; String segmentation_caffemodel = SDCARD_DIR + File.separator + SEGMENTATION_CAFFEMODEL; String character_prototxt = SDCARD_DIR + File.separator + RECOGNIZATION_PROTOTXT; String character_caffemodel = SDCARD_DIR + File.separator + RECOGNIZATION_CAFFEMODEL; String segmentation_free_prototxt = SDCARD_DIR + File.separator + FREE_INCEPTION_PROTOTXT; String segmentation_free_caffemodel = SDCARD_DIR + File.separator + FREE_INCEPTION_CAFFEMODEL; copyFilesFromAssets(context); //调用JNI 加载资源函数 return PlateRecognition.InitPlateRecognizer( cascade_filename, finemapping_prototxt, finemapping_caffemodel, segmentation_prototxt, segmentation_caffemodel, character_prototxt, character_caffemodel, segmentation_free_prototxt, segmentation_free_caffemodel); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/categories/Android/"},{"name":"OpenCV","slug":"Android/OpenCV","permalink":"https://Stefancharles.xyz/categories/Android/OpenCV/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://Stefancharles.xyz/tags/OpenCV/"}],"author":"Stefan"},{"title":"新大陆安卓端代码笔记（四）","slug":"Android_Code_newland_four","date":"2019-09-21T16:00:00.000Z","updated":"2019-09-24T04:50:19.966Z","comments":true,"path":"2019/09/22/Android_Code_newland_four/","link":"","permalink":"https://Stefancharles.xyz/2019/09/22/Android_Code_newland_four/","excerpt":"新大陆安卓端代码笔记（四）在之前的博客中，主要记录了我阅读demo代码的收获，这一个博客记录我自己做一个app过程中遇到的问题和解决方案。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。","text":"新大陆安卓端代码笔记（四）在之前的博客中，主要记录了我阅读demo代码的收获，这一个博客记录我自己做一个app过程中遇到的问题和解决方案。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。 1.Android 当用户名和密码都不为空时，按钮才可用这里要明白一个地方，这个问题的关键点不在Button，而是在于EditText。因为你需要打开app一开始就设置Button不可用，因为一开始是没有输入的。而后是不能对它进行操作的。 所以，先在要在.xml里设置一下 android:enabled=”false”。 主要就是去设置文本框的监听事件，由于有两个文本框，所以直接调用两次就行，如果去嵌套着调用，既麻烦，还容易出错。 下面给出一种解决方案。 12345678910111213141516171819202122232425262728293031// TODO: 2019/9/22 若账号或密码有一项为空，则登录按钮不能点击。TextWatcher textWatcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; if(username.getText().length()==0||password.getText().length()==0)&#123; login.setEnabled(false); &#125;else&#123; login.setEnabled(true); &#125; &#125;&#125;;username.addTextChangedListener(textWatcher);password.addTextChangedListener(textWatcher);login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,\"Test!!! \" ,Toast.LENGTH_SHORT).show(); &#125;&#125;); 其中，TextWatcher这个接口是专门用来监听文本框变化的。 2.随机生成验证码，如果验证码输入错误则自动更新一次验证码这里用来生成图片验证码的java工具类是别人是轮子。大致思路是在一块固定宽高的画布上，画上固定个数的随机数字和字母，再画上固定条数的干扰线随机数和干扰线的颜色随机生成，随机数的样式随机生成。 CodeUtils.java如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.shashank.platform.loginui.util;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import java.util.Random;//// Created by Stefan on 2019/9/22.//public class CodeUtils &#123; private static final char[] CHARS = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' &#125;; private static CodeUtils mCodeUtils; private int mPaddingLeft, mPaddingTop; private StringBuilder mBuilder = new StringBuilder(); private Random mRandom = new Random(); //Default Settings private static final int DEFAULT_CODE_LENGTH = 4;//验证码的长度 这里是6位 private static final int DEFAULT_FONT_SIZE = 60;//字体大小 private static final int DEFAULT_LINE_NUMBER = 3;//多少条干扰线 private static final int BASE_PADDING_LEFT = 20; //左边距 private static final int RANGE_PADDING_LEFT = 30;//左边距范围值 private static final int BASE_PADDING_TOP = 70;//上边距 private static final int RANGE_PADDING_TOP = 15;//上边距范围值 private static final int DEFAULT_WIDTH = 300;//默认宽度.图片的总宽 private static final int DEFAULT_HEIGHT = 100;//默认高度.图片的总高 private static final int DEFAULT_COLOR = 0xDF;//默认背景颜色值 private static String code; public static CodeUtils getInstance() &#123; if(mCodeUtils == null) &#123; mCodeUtils = new CodeUtils(); &#125; return mCodeUtils; &#125; //生成验证码图片 public Bitmap createBitmap() &#123; mPaddingLeft = 0; //每次生成验证码图片时初始化 mPaddingTop = 0; Bitmap bitmap = Bitmap.createBitmap(DEFAULT_WIDTH, DEFAULT_HEIGHT, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); code = createCode(); canvas.drawColor(Color.rgb(DEFAULT_COLOR, DEFAULT_COLOR, DEFAULT_COLOR)); Paint paint = new Paint(); paint.setTextSize(DEFAULT_FONT_SIZE); for (int i = 0; i &lt; code.length(); i++) &#123; randomTextStyle(paint); randomPadding(); canvas.drawText(code.charAt(i) + \"\" , mPaddingLeft, mPaddingTop, paint); &#125; //干扰线 for (int i = 0; i &lt; DEFAULT_LINE_NUMBER; i++) &#123; drawLine(canvas, paint); &#125; canvas.save();//保存 canvas.restore(); return bitmap; &#125; /** * 得到图片中的验证码字符串 * @return */ public static String getCode() &#123; return code; &#125; //生成验证码 public String createCode() &#123; mBuilder.delete(0, mBuilder.length()); //使用之前首先清空内容 for (int i = 0; i &lt; DEFAULT_CODE_LENGTH; i++) &#123; mBuilder.append(CHARS[mRandom.nextInt(CHARS.length)]); &#125; return mBuilder.toString(); &#125; //生成干扰线 private void drawLine(Canvas canvas, Paint paint) &#123; int color = randomColor(); int startX = mRandom.nextInt(DEFAULT_WIDTH); int startY = mRandom.nextInt(DEFAULT_HEIGHT); int stopX = mRandom.nextInt(DEFAULT_WIDTH); int stopY = mRandom.nextInt(DEFAULT_HEIGHT); paint.setStrokeWidth(1); paint.setColor(color); canvas.drawLine(startX, startY, stopX, stopY, paint); &#125; //随机颜色 private int randomColor() &#123; mBuilder.delete(0, mBuilder.length()); //使用之前首先清空内容 String haxString; for (int i = 0; i &lt; 3; i++) &#123; haxString = Integer.toHexString(mRandom.nextInt(0xFF)); if (haxString.length() == 1) &#123; haxString = \"0\" + haxString; &#125; mBuilder.append(haxString); &#125; return Color.parseColor(\"#\" + mBuilder.toString()); &#125; //随机文本样式 private void randomTextStyle(Paint paint) &#123; int color = randomColor(); paint.setColor(color); paint.setFakeBoldText(mRandom.nextBoolean()); //true为粗体，false为非粗体 float skewX = mRandom.nextInt(11) / 10; skewX = mRandom.nextBoolean() ? skewX : -skewX; paint.setTextSkewX(skewX); //float类型参数，负数表示右斜，整数左斜 paint.setUnderlineText(true); //true为下划线，false为非下划线 paint.setStrikeThruText(true); //true为删除线，false为非删除线 &#125; //随机间距 private void randomPadding() &#123; mPaddingLeft += BASE_PADDING_LEFT + mRandom.nextInt(RANGE_PADDING_LEFT); mPaddingTop = BASE_PADDING_TOP + mRandom.nextInt(RANGE_PADDING_TOP); &#125;&#125; .xml文件如下： 12345678910111213141516171819202122232425262728293031&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"15dp\" android:layout_marginRight=\"15dp\" android:layout_marginTop=\"20dp\" android:orientation=\"horizontal\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"45dp\"&gt; &lt;EditText android:id=\"@+id/et_phoneCodes\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:textStyle=\"bold\" android:textColor=\"#96ffffff\" android:textSize=\"16sp\" android:hint=\"@string/pic_number\" /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"100dp\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"10dp\" /&gt; &lt;/LinearLayout&gt; 到这里为止，图片验证码的准备工作已经做好了。接下来就是把图片验证码的逻辑放到MainActivity里。显然我们把它放在button的login的点击事件里比较好。当用户按下login时，我们进行验证码比对，如果输入正确则跳转到联网登陆，不正确则刷新验证码，要求用户重新输入。 关键代码如下： 12345678910111213141516171819202122232425// TODO: 2019/9/22 登陆按键的点击事件login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO: 2019/9/22 对图片验证码进行验证，验证成功则进行登陆 codeStr = et_phoneCodes.getText().toString().trim(); Log.e(\"codeStr\", codeStr); if (null == codeStr || TextUtils.isEmpty(codeStr)) &#123; Toast.makeText(MainActivity.this,\"Please Enter confirmation code.\",Toast.LENGTH_SHORT).show(); return; &#125; String code = CodeUtils.getCode(); Log.e(\"code\", code); if (code.equalsIgnoreCase(codeStr)) &#123; Toast.makeText(MainActivity.this,\"Welcome Home!.\",Toast.LENGTH_SHORT).show(); signIn();//验证码正确后进行账号和密码的验证 &#125; else &#123; Toast.makeText(MainActivity.this,\"Please Enter the Right confirmation code.\",Toast.LENGTH_SHORT).show(); bitmap = CodeUtils.getInstance().createBitmap(); code = CodeUtils.getInstance().getCode(); image.setImageBitmap(bitmap);//输入错误后更换验证码 &#125; &#125;&#125;); 完成以后，就可以看到效果了。 好了，验证码这一个任务已完成。 3.从云平台获取温度数据并显示在仪表盘上这里又要再次借用一下别人写好的轮子了。 绘制温度仪表盘的工具类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422package com.shashank.platform.loginui;//// Created by Stefan on 2019/9/23.//TempView.javaimport android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.util.TypedValue;import android.view.View;public class TempView extends View &#123; /** * 控件宽 */ private int mWidth; /** * 控件高 */ private int mHeight; private String mTempTitle = \"温度(℃)\"; private String mHumTitle = \"湿度(%)\"; /** * 刻度高 短针 */ private int mScaleHeight = dp2px(10); /** * 刻度高 长针 */ private int mScaleHeight1 = dp2px(15); /** * 刻度盘/ */ private Paint mDialPaint; /** * 文本画笔 */ private Paint mTitlePaint; /** * 画湿度圆环的画笔 */ private Paint mHumCirclePaint; /** * 当前湿度值的小圆点 */ private Paint mHumValueCirclePaint; /** * 湿度圆环左边和右边的小圆点画笔 */ private Paint mHumLeftCirclePaint; private Paint mHumRightCirclePaint; /** * 当前温度 */ private int mTemperature = 15; // /** * 最低温度 */ private int mMinTemp = 10; /** * 最高温度 */ private int mMaxTemp = 50; /** * 当前湿度 */ private int mHumidity = 100; /** * 最低湿度 */ private int mMinHum = 0; /** * 最高湿度 */ private int mMaxHum = 100; /** * 温度每份的角度 */ private float mAngleOneTem = (float) 270 / (mMaxTemp - mMinTemp); /** * 湿度每份的角度 */ private float mAngleOneHum = (float) 270 / (mMaxHum - mMinHum); /** * 温度，刻度的半径 */ private int mTemDialRadius; /** * 湿度，内圈半径 */ private int mHumInSideRadius; /** * 湿度，圆环宽度 */ private int mHumCriWidth = dp2px(15); /** * 刻度和文字颜色 */ private String mTextColor = \"#666666\"; /** * 未达到的温度 */ private String mDialBackGroundColor = \"#666666\"; /** * 已经达到的温度 */ private String mDialForegroundColor = \"#1FC8A2\"; /** * 湿度圆环背景色 */ private String mHumCriBackground = \"#666666\"; /** * 湿度圆环前景色 */ private String mHumCriForeground = \"#1FC8A2\"; /** * 当前湿度的小圆点颜色 */ private String mHumCriValue = \"#eeeeee\"; /** * 当前湿度的小圆点的背景色 */ private String mHumCriValueBackGround = \"#30333333\"; public TempView(Context context) &#123; super(context); init(); &#125; public TempView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TempView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; //温度刻度盘 mDialPaint = new Paint(); mDialPaint.setAntiAlias(true); mDialPaint.setColor(Color.parseColor(mDialBackGroundColor)); mDialPaint.setStrokeWidth(dp2px(2)); mDialPaint.setStyle(Paint.Style.STROKE); //文字描述 mTitlePaint = new Paint(); mTitlePaint.setAntiAlias(true); mTitlePaint.setTextSize(sp2px(15)); mTitlePaint.setColor(Color.parseColor(mTextColor)); mTitlePaint.setStyle(Paint.Style.STROKE); //湿度圆环 mHumCirclePaint = new Paint(); mHumCirclePaint.setAntiAlias(true); mHumCirclePaint.setColor(Color.parseColor(mHumCriBackground)); mHumCirclePaint.setStyle(Paint.Style.STROKE); mHumCirclePaint.setStrokeWidth(mHumCriWidth); //当前湿度值 mHumValueCirclePaint = new Paint(); mHumValueCirclePaint.setAntiAlias(true); mHumValueCirclePaint.setColor(Color.parseColor(mHumCriValue)); mHumValueCirclePaint.setStyle(Paint.Style.FILL); //湿度圆环左边的小圆点 mHumLeftCirclePaint = new Paint(); mHumLeftCirclePaint.setAntiAlias(true); mHumLeftCirclePaint.setColor(Color.parseColor(mHumCriForeground)); mHumLeftCirclePaint.setStyle(Paint.Style.FILL); //湿度圆环右边的小圆点 mHumRightCirclePaint = new Paint(); mHumRightCirclePaint.setAntiAlias(true); mHumRightCirclePaint.setColor(Color.parseColor(mHumCriBackground)); mHumRightCirclePaint.setStyle(Paint.Style.FILL); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int specSize = MeasureSpec.getSize(widthMeasureSpec); // 参考宽，处理成正方形 setMeasuredDimension(specSize, specSize); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); // 控件宽、高 mWidth = mHeight = Math.min(h, w); // 温度，刻度的半径 mTemDialRadius = mWidth / 2 - dp2px(70); // 湿度，内圈半径=刻度的内圈+最长刻度+15像素 mHumInSideRadius = mTemDialRadius + mScaleHeight1 + dp2px(15); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //画温度刻度盘和内的刻度 drawTempDial(canvas); //画湿度圆弧 drawHumArc(canvas); //画左边和左边的小圆点 drwaHumArcLeftAndRight(canvas); //当前湿度值 drawHumValueArc(canvas); //湿度外边的刻度 drawHumText(canvas); //画温湿度标题文字 drawTemText(canvas); &#125; /** * 画温度刻度 和温度内圈文字 */ private void drawTempDial(Canvas canvas) &#123; canvas.save(); canvas.translate(getWidth() / 2, getHeight() / 2); // 顺时针旋转135度 canvas.rotate(-135); for (int i = mMinTemp; i &lt;= mMaxTemp; i++) &#123; if (i &lt;= mTemperature) &#123; mDialPaint.setColor(Color.parseColor(mDialForegroundColor)); &#125; else &#123; mDialPaint.setColor(Color.parseColor(mDialBackGroundColor)); &#125; if (i % 5 == 0) &#123; //从刻度的内圈开始，往外画 canvas.drawLine(0, -mTemDialRadius, 0, -mTemDialRadius - mScaleHeight1, mDialPaint); if (i % 10 == 0) &#123; float tempWidth = mDialPaint.measureText(i + \"\"); canvas.drawText(i + \"\", 0 - tempWidth / 2, -mTemDialRadius + dp2px(20), mTitlePaint); &#125; &#125; else &#123; canvas.drawLine(0, -mTemDialRadius, 0, -mTemDialRadius - mScaleHeight, mDialPaint); &#125; canvas.rotate(mAngleOneTem); &#125; canvas.restore(); &#125; /** * 画温湿度标题 * * @param canvas */ private void drawTemText(Canvas canvas) &#123; canvas.save(); canvas.translate(getWidth() / 2, getHeight() / 2); float tempWidth = mTitlePaint.measureText(mTempTitle); float humWidth = mTitlePaint.measureText(mHumTitle); canvas.drawText(mTempTitle, -tempWidth / 2, mTemDialRadius + dp2px(5), mTitlePaint); canvas.drawText(mHumTitle, -humWidth / 2, mHumInSideRadius + dp2px(7), mTitlePaint); canvas.restore(); &#125; /** * 画湿度圆环 */ private void drawHumArc(Canvas canvas) &#123; canvas.save(); canvas.translate(getWidth() / 2, getHeight() / 2); canvas.rotate(135); mHumCirclePaint.setColor(Color.parseColor(mHumCriBackground)); RectF rectF = new RectF(-mHumInSideRadius, -mHumInSideRadius, mHumInSideRadius, mHumInSideRadius); //画背景 canvas.drawArc(rectF, 0, 270, false, mHumCirclePaint); mHumCirclePaint.setColor(Color.parseColor(mHumCriForeground)); //画前景 canvas.drawArc(rectF, 0, mAngleOneHum * mHumidity, false, mHumCirclePaint); canvas.restore(); &#125; /** * 画当前湿度值的小圆点 */ private void drawHumValueArc(Canvas canvas) &#123; canvas.save(); canvas.translate(getWidth() / 2, getHeight() / 2); //旋转到0，再旋转到当前湿度值 canvas.rotate(-135 + mAngleOneHum * mHumidity); //画背景 mHumValueCirclePaint.setColor(Color.parseColor(mHumCriValueBackGround)); canvas.drawCircle(0, -mHumInSideRadius, (mHumCriWidth + dp2px(10)) / 2, mHumValueCirclePaint); //画前景 mHumValueCirclePaint.setColor(Color.parseColor(mHumCriValue)); canvas.drawCircle(0, -mHumInSideRadius, (mHumCriWidth + dp2px(7)) / 2, mHumValueCirclePaint); canvas.restore(); &#125; /** * 左边右边分别画一个小圆点 * * @param canvas */ private void drwaHumArcLeftAndRight(Canvas canvas) &#123; canvas.save(); canvas.translate(getWidth() / 2, getHeight() / 2); //旋转到0 canvas.rotate(-135); canvas.drawCircle(0, -mHumInSideRadius, mHumCriWidth / 2, mHumLeftCirclePaint); canvas.rotate(270); canvas.drawCircle(0, -mHumInSideRadius, mHumCriWidth / 2, mHumRightCirclePaint); canvas.restore(); &#125; /** * 画湿度的文字 */ private void drawHumText(Canvas canvas) &#123; canvas.save(); canvas.translate(getWidth() / 2, getHeight() / 2); // 顺时针旋转135度 canvas.rotate(-135); for (int i = mMinHum; i &lt;= mMaxHum; i++) &#123; if (i % 10 == 0) &#123; float tempWidth = mTitlePaint.measureText(i + \"\"); canvas.drawText(i + \"\", 0 - tempWidth / 2, -mHumInSideRadius - mHumCriWidth, mTitlePaint); &#125; canvas.rotate(mAngleOneHum); &#125; canvas.restore(); &#125; public void setMinTemp(int minTemp) &#123; setData(minTemp, mMaxTemp, mTemperature, mMinHum, mMaxHum, mHumidity); &#125; public void setMaxTemp(int maxTemp) &#123; setData(mMinTemp, maxTemp, mTemperature, mMinHum, mMaxHum, mHumidity); &#125; public void setTemp(int temp) &#123; setData(mMinTemp, mMaxTemp, temp, mMinHum, mMaxHum, mHumidity); &#125; private void setTempTitle(String tempTitle) &#123; this.mTempTitle = tempTitle; invalidate(); &#125; public void setMinHum(int minHum) &#123; setData(mMinTemp, mMaxTemp, mTemperature, minHum, mMaxHum, mHumidity); &#125; public void setMaxHum(int maxHum) &#123; setData(mMinTemp, mMaxTemp, mTemperature, mMinHum, maxHum, mHumidity); &#125; public void setHum(int hum) &#123; setData(mMinTemp, mMaxTemp, mTemperature, mMinHum, mMaxHum, hum); &#125; private void setHumTitle(String humTitle) &#123; this.mHumTitle = humTitle; invalidate(); &#125; /** * @param minTemp 最小温度 * @param maxTemp 最大温度 * @param temp 设置的温度 * @param minHum 最小湿度 * @param maxHum 最大湿度 * @param hum 当前湿度 */ public void setData(int minTemp, int maxTemp, int temp, int minHum, int maxHum, int hum) &#123; this.mMinTemp = minTemp; this.mMaxTemp = maxTemp; if (temp &lt; minTemp) &#123; this.mTemperature = minTemp; &#125; else if (temp &gt; maxTemp) &#123; this.mTemperature = maxTemp; &#125; else &#123; this.mTemperature = temp; &#125; this.mMinHum = minHum; this.mMaxHum = maxHum; if (hum &lt; minHum) &#123; this.mHumidity = minHum; &#125; else if (hum &gt; maxHum) &#123; this.mHumidity = maxHum; &#125; else &#123; this.mHumidity = hum; &#125; mAngleOneTem = (float) 270 / (mMaxTemp - mMinTemp); mAngleOneHum = (float) 270 / (mMaxHum - mMinHum); invalidate(); &#125; public int dp2px(float dp) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, getResources().getDisplayMetrics()); &#125; private int sp2px(float sp) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, sp, getResources().getDisplayMetrics()); &#125;&#125; 代码比较长，里面提供了设置温度和湿度的函数接口，到时候只需要实例化这个仪表盘对象，再调用setTemp()函数即可。 值得注意的是，这个仪表盘可以显示温度和湿度，并且提供了函数修改仪表盘上的最大和最小刻度，以及修改Title的函数。后面很多情况都可以用这个轮子。 接下来就是在login跳转后的新的activity中写一个getTemperature()的函数了。这里需要结合新大陆的SDK来进行。核心代码如下： 1234567891011121314151617181920212223242526272829303132333435// TODO: 2019/9/24 从云平台获取温度数据，显示在仪表盘上。注意apitTag要和云平台标识名一致public void getTemperature()&#123; netWorkBusiness.getSensor(deviceID, \"currentTemp\", new NCallBack&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt;() &#123; @Override public void onResponse(final Call&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt; call, final Response&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt; response) &#123; BaseResponseEntity baseResponseEntity = response.body(); if (baseResponseEntity!=null)&#123; //获取到了内容,使用json解析. final Gson gson=new Gson(); JSONObject jsonObject; String msg=gson.toJson(baseResponseEntity); try &#123; jsonObject = new JSONObject(msg); //解析数据. JSONObject resultObj = (JSONObject) jsonObject.get(\"ResultObj\"); String TempValue=resultObj.getString(\"Value\"); tempurature=Double.valueOf(TempValue).intValue(); mDeviceTempHum.setTemp(tempurature);//显示温度数据到仪表盘 &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override protected void onResponse(BaseResponseEntity&lt;SensorInfo&gt; response) &#123; &#125; public void onFailure(final Call&lt;BaseResponseEntity&lt;SensorInfo&gt;&gt; call, final Throwable t) &#123; Toast.makeText(ShowTemp.this,\"温度获取失败\", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 接下来就是利用线程每隔2分钟调用一次getTemperature()函数了。 先插播一个我在新建一个activitity过程中遇到的问题。 就是Android的顶部导航栏变成空白，导致界面非常不好看。 分两步： 首先在Showtemp这个activity的java代码中添加下面代码： 123456 // TODO: 2019/9/23 状态栏设置 if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123; Window window = this.getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125;&#125; if里面的是Android SDK版本，其实可以不用加进去，因为我们用的29了。然后在其对应的xml文件中加入下面代码： 1android:fitsSystemWindows=\"true\" 这样以后，界面如图： 4.线程的使用核心代码如下： 1234567891011121314151617// TODO: 2019/9/24 每个2分钟刷新温度数据并且显示出来private void refreshData()&#123; message = Message.obtain();//从消息池获取空消息对象 message.what = FLAG_MSG;//标识信息，以便用不同的方式处理Message handler.sendMessage(message);//立刻发送消息&#125;@SuppressLint(\"HandlerLeak\")private Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; if(msg.what==FLAG_MSG)&#123; getTemperature(); &#125; message = handler.obtainMessage(FLAG_MSG);//从消息池获取空消息对象，标识为FLAG_MSG handler.sendMessageDelayed(message,2000); // 延时2s发送 &#125;&#125;; 5.温度到达上限报警代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@SuppressLint(\"SetTextI18n\")public void dialog() &#123; //标题居中 TextView title = new TextView(this); title.setText(\"Warning!\"); title.setPadding(0, 25, 0, 0); title.setGravity(Gravity.CENTER); //创建对话框对象 AlertDialog alertDialog = new AlertDialog.Builder(ShowTemp.this).create(); alertDialog.setIcon(R.drawable.advise); //设置对话框的图标 alertDialog.setCustomTitle(title);//设置标题 //设置要显示的内容 alertDialog.setMessage(\"Temperature exceeds limit!\"); alertDialog.setButton(DialogInterface.BUTTON_NEGATIVE, \"Cancel reminder\", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; alarmFlag = false; allowCount = false; &#125; &#125;); alertDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"Remind later\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; alarmFlag = false; allowCount = true; count = 0;//每点击一次稍后提醒就把count置0，重新计数2分钟 refreshCount(); &#125; &#125;); alertDialog.show();//显示对话框 Button mNegativeButton = alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE); Button mPositiveButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE); LinearLayout.LayoutParams mNegativeButtonLL = (LinearLayout.LayoutParams) mNegativeButton.getLayoutParams(); mNegativeButtonLL.weight = 1; mNegativeButton.setLayoutParams(mNegativeButtonLL); LinearLayout.LayoutParams mPositiveButtonLL = (LinearLayout.LayoutParams) mPositiveButton.getLayoutParams(); mPositiveButtonLL.weight = 1; mPositiveButton.setLayoutParams(mPositiveButtonLL);&#125; 当点击取消提醒时，把允许弹窗的提示标志位置否。点击稍后提醒则开始计时。达到设定的时间后再次把允许弹窗的提示标志位置真。 当然可以弹窗时可以设置手机响铃和震动等，这个比较简单，这里就不贴具体代码了。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://Stefancharles.xyz/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"}]},{"title":"【教师节】谢谢老师为我们所作的一切","slug":"Teachers_day","date":"2019-09-09T16:00:00.000Z","updated":"2019-09-10T02:31:24.016Z","comments":true,"path":"2019/09/10/Teachers_day/","link":"","permalink":"https://Stefancharles.xyz/2019/09/10/Teachers_day/","excerpt":"高中毕业后，每当我觉得孤独时，我总会清晰地回忆起您在课堂上和课堂外告诉我们的一句话： 带着勤奋和严谨工作、带着正直和善良做人、怀着爱心和温暖生活。 清晰到足够我回忆起每个细节，似乎那天刚刚高二分班后第一次见面，您叫我去黑板上翻译英语短语的事情就发生在昨天。谢谢您，阳老师，谢谢您曾经为我们所作的一切。教师节快乐！","text":"高中毕业后，每当我觉得孤独时，我总会清晰地回忆起您在课堂上和课堂外告诉我们的一句话： 带着勤奋和严谨工作、带着正直和善良做人、怀着爱心和温暖生活。 清晰到足够我回忆起每个细节，似乎那天刚刚高二分班后第一次见面，您叫我去黑板上翻译英语短语的事情就发生在昨天。谢谢您，阳老师，谢谢您曾经为我们所作的一切。教师节快乐！ Dear Miss Yang, Time flies by, and a world of changes has occurred. Years have passed, it has been two years since I graduated from high school. The first time I met you in high school seems to be yesterday. You asked me to translate English phrases on the blackboard. I still remember that day clearly. Time went by, and I did a lot of wrong things. I let many people down. I regret very much when I think of it in my free time. Sorry , I am sorry about everything. After graduating from high school, whenever I feel lonely and helpless, I often remember that you used to tell us that we should work hard, work with integrity, be kind and honest, and live with love and warmth. Our parents gave us a life and it was you who taught us how to live it. You introduced honesty, integrity and passion to our character. Happy teacher’s day 2019! Thank you , For everything that you have done for us! Sincerely Your Student Stefan 高中毕业后，每当我觉得孤独时，我总会清晰地回忆起您在课堂上和课堂外告诉我们的一句话： 带着勤奋和严谨工作、带着正直和善良做人、怀着爱心和温暖生活。 清晰到足够我回忆起每个细节，似乎那天刚刚高二分班后第一次见面，您叫我去黑板上翻译英语短语的事情就发生在昨天。 谢谢您，阳老师，谢谢您曾经为我们所作的一切。教师节快乐！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://Stefancharles.xyz/categories/随笔/"}],"tags":[]},{"title":"【Android】线程与消息处理","slug":"ThreadAndMessage","date":"2019-09-05T16:00:00.000Z","updated":"2019-09-08T12:20:29.993Z","comments":true,"path":"2019/09/06/ThreadAndMessage/","link":"","permalink":"https://Stefancharles.xyz/2019/09/06/ThreadAndMessage/","excerpt":"简介对于比较耗时间的操作，通过会为其开辟一个单独的线程来执行，以尽可能减少用户的等待时间。在Android中，默认情况下，所有的操作都是在主线程下进行的，主线程负责管理与UI相关的事件，而在用户自己创建的子线程中，不能对UI组件进行操作。因此，Android提供了消息处理机制传递机制解决问题。 主要包括： 1.如何创建和开启线程 2.如何让线程休眠 3.如何中断线程 4.循环者Looper 5.消息处理类Handler的应用 6.消息类Message的应用","text":"简介对于比较耗时间的操作，通过会为其开辟一个单独的线程来执行，以尽可能减少用户的等待时间。在Android中，默认情况下，所有的操作都是在主线程下进行的，主线程负责管理与UI相关的事件，而在用户自己创建的子线程中，不能对UI组件进行操作。因此，Android提供了消息处理机制传递机制解决问题。 主要包括： 1.如何创建和开启线程 2.如何让线程休眠 3.如何中断线程 4.循环者Looper 5.消息处理类Handler的应用 6.消息类Message的应用 1.创建线程在Android中，有两种创建线程的方法： 可以使用Thread类的构造方法创建线程对象，并重写run()方法实现 通过实现runnable接口实现 通过Thread类的构造方法创建线程在Android中，可以使用Thread类提供的构造方法来创建线程： 1Thread(Runnable runnable) 这个构造方法的参数runnable可以通过创建一个 Runnable类的对象并重写其run()方法实现。 例如创建一个名为thread的线程，示例代码： 123456Thread thread = new Thread(new Runnable()&#123; @Override public void run()&#123; //TODO... &#125;&#125;); 通过实现Runnable接口创建线程实现Runnable接口语法如下： 1public class ClassName extends Object implements Runnable 当一个类实现Runnable接口后，还需要实现其run()方法，在run()方法中，可以编写需要执行的操作。 例如，要创建一个实现了Runnable接口的Activity，示例代码： 1234567891011public class MainActivity extends Activity implements Runnable&#123; @Override public void onCreate(Bundle savedInstaceState)&#123; super.onCreate(saveInstanceState); setContentView(R.layout.main); &#125; @Override public void run()&#123; //TODO... &#125;&#125; 2.开启线程创建线程后，还需要开启线程，线程才能被执行。Thread类有start()方法用来启动线程。 例如有一个名为thread的线程，想要开启它，代码： 1thread.start(); 3.线程的休眠线程的休眠就是让线程暂停一段时间后再执行。想要线程休眠一秒，代码： 1Thread.sleep(1000); 4.中断线程例如有一个名为thread的线程，想要中断它，代码： 1234567thread.interrupt();//...public void run()&#123; while(!Thread.currentThread().isInterrupted())&#123; //... &#125;&#125; 值得注意的点是，如果在线程中执行了wait(),join(),sleep()方法时，线程的中断状态会被清除并抛出InterrupedException. 如果想要在线程中执行wait(),join(),sleep()方法，就需要一个布尔型的标记变量记录线程的中断状态。可以通过这个标记变量来控制循环的执行和停止。 1234567private boolean isInterrput = false;//...public void run()&#123; while(!isInterrupt)&#123; //... &#125;&#125; 当需要中断线程的时候，把isInterrput的值设置为true。 5.Handler消息传递机制在前面已经写到了在Android中如何创建，开启，休眠和中断线程。不过此时并没有在新创建的子线程中对UI界面上的内容进行操作。 假设直接在子线程run()中直接修改UI中的文本框或者其他，将会抛出异常。 所以Android引入了 Handler消息传递机制，这样，在新创建的线程中操作UI界面。 6.关于Looper在细讲Handler之前，先得说下这个Looper。 在Android中，一个线程对应一个Looper对象，一个Looper对象又对应一个MessageQueue，也就是MessageQueue被封装到了Looper中。MessageQueue用来存放Message,其Message按照FIFO原则执行。 Looper对象用来为一个线程开启消息循环，从而操作MessageQueue。默认情况下，Android中新创建的线程是没有开启消息循环的，但主线程除外。系统自动为主线程创建Looper对象，开启消息循环。所以在主线程中，可以用下面的代码创建Handler对象，而不会出错。 1Handler handler2 = new Handler(): 如果想要在非主线程中创建Handler对象，首先需要Looper类的prepare()方法来初始化一个Looper对象，然后创建Handler对象，再使用Looper类的loop()方法启动Looper，从消息队列中获取和处理消息。 这里具体代码我暂时不举例了，后面有时间就补上。 7.Handler（消息处理类）消息处理类（ Handler）允许发送和处理Message和Runnable对象到其所在的线程的MessageQueue中。Handler主要有以下作用： 将Message和Runnable应用post()或者sendMessage()方法发送到MessageQueue中，在发送的时候可以指定延迟时间，发送时间和要携带的Bundle数据。当MessageQueue循环到这个特定的Message时，调用相应的Handler对象的handlerMessage()方法对其进行处理。 在子线程中与主线程进行通信，也就是在工作线程中与UI线程进行通信。 在一个线程中，只能有以一个Looper和MessageQueue，但是可以有多个Handler，这些Handler可以共享一个Looper和MessageQueue。 8.Message（消息类）一个MessageQueue中可以有多个Message对象。每个Message对象可以通过Message.obtain或者Handler.obtainMessage()方法获得。 一个Message对象具有以下属性： 属性 类型 描述 arg1 int 存放整形数据 arg2 int 存放整形数据 obj Object 存放发送给接收器的Object类型的任意对象 replyTo Messenger 指定这个Messgae发送到何处的可选Messager对象 what int 指定用户自定义的消息代码，这样接收者可以了解这个消息的信息 使用Message类的属性可以携带int型数据，如果要携带其他类型的数据，可以先把数据保存到Bundle对象中，然后通过Message类的setData()方法将其添加到Message中。 有以下几个点值得注意： 尽管Message有public的默认构造方法，但是通常使用Message.obtain()或者Handler.obtainMessage()方法来从消息池中获取空消息对象。以节省资源。 如果一个Message只需要携带int，则用Message类自带的arg1,arg2比用Bundle更节省内存。 尽可能使用Message. what来标识信息，以便用不同方式处理Message。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"},{"name":"Thread","slug":"Thread","permalink":"https://Stefancharles.xyz/tags/Thread/"}]},{"title":"新大陆安卓端代码笔记（三）","slug":"Android_Code_newland_three","date":"2019-09-05T16:00:00.000Z","updated":"2019-09-11T10:06:18.320Z","comments":true,"path":"2019/09/06/Android_Code_newland_three/","link":"","permalink":"https://Stefancharles.xyz/2019/09/06/Android_Code_newland_three/","excerpt":"新大陆安卓端代码笔记（三）在新大陆安卓端代码笔记（二）博客中，主要介绍了登陆的MenuActivity的前半部分，这一个博客将着手于MenuActivity中后半部分的一些关键点。 在阅读本博客前，推荐先阅读【Android】线程与消息处理。因为本博客后文会着重写到关于新大陆安卓端的线程和消息处理方面的点。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。","text":"新大陆安卓端代码笔记（三）在新大陆安卓端代码笔记（二）博客中，主要介绍了登陆的MenuActivity的前半部分，这一个博客将着手于MenuActivity中后半部分的一些关键点。 在阅读本博客前，推荐先阅读【Android】线程与消息处理。因为本博客后文会着重写到关于新大陆安卓端的线程和消息处理方面的点。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。 1.轮询刷新数据 当确定了设备后，就需要每隔指定时间查询和更新“排队人数”。 在阅读下文前，推荐先阅读【Android】线程与消息处理。 123message = Message.obtain();//从消息池获取空消息对象message.what = FLAG_MSG;//标识信息，以便用不同的方式处理Messagehandler.sendMessage(message);//立刻发送消息 内部类泄露1@SuppressLint(\"HandlerLeak\") 关于内部类泄露，有位大佬在他的博客里是这么写的： 由于(匿名)内部类隐式地持有一个外部类的引用, 故而当内部类中执行的事情长于外部类的生命周期时, 就会导致外部类的泄露。常见的此类泄露包括Handler泄露, Thread泄露…, 这些也是我们经常会作为(匿名)内部类在Activity中使用的。 因为这个Handler是一个内部类(默认持有一个外部类也就是我们的HandlerLeakActivity的引用), 如果这个Handler的Looper/MQ所在的Thread与Main Thread不同, 则没有问题. 但是如果Handler的Looper/MQ就是Main Thread(本例中就是), 那么问题就来了: 这个Handler发送的message会放到MQ中, 这个message会对Handler有一个引用, 而Handler有HandlerLeakActivity的引用. 当我们进入这个Activity, 然后退出, 理当销毁这个Activity并回收了. 但是因为这个message会延时60s, 故而导致这个mHandler被引用, 从而activity被引用着, 而无法回收释放内存。 这里就不细说，感兴趣的同学可以细读以下别人的博客。 每隔5秒发送消息123456789private Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; if(msg.what==FLAG_MSG)&#123; getpeoplenumber(); &#125; message = handler.obtainMessage(FLAG_MSG);//从消息池获取空消息对象，标识为FLAG_MSG handler.sendMessageDelayed(message,5000); // 延时5秒发送 &#125; &#125;; 这里新创建一个消息处理类，每个MQ中的Message都要交由对应的handleMessage()方法处理，原因就是比对FLAG_MSG，如果是，则执行 getpeoplenumber()。然后再从消息池中获取一个空消息对象，标记为FLAG_MSG，并隔5秒再发送。也就是5秒后又执行一次 getpeoplenumber()。 这样也就实现了循环刷新数据。 2.获取排队人数调用netWorkBusiness对象的一个getSensor() 方法，获取响应体存入BaseResponseEntity类实例化的baseResponseEntity对象，如果这个对象不为空，则使用json解析数据。提取其中Value的值即为排队人数。 1234 private Boolean flag1 = true; //是否再次提醒 if (num &lt;= 4&amp;&amp;flag1) &#123; dialog();&#125; 当获取到的前面排队的人数小于等于4并且再次提醒为真时，弹出对话框。对话框中有“取消提醒”和“退出排队”两个Button。当按下“取消提醒”则把 flag1置false。当按下“退出排队”时，需要把人数减少一个，把数据同步到云平台，再把flag置false。 12private Boolean flag = true; //是否获取数据标志private Boolean flag1 = true; //是否再次提醒 3.dialog()对话提示框当前面排队人数只有三个人时，需要弹出对话框进行提示。这里用的Java写界面，这里就不过多强调了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void dialog()&#123; //标题居中 TextView title = new TextView(this); title.setText(\"提示\"); title.setPadding(0,25,0,0); title.setGravity(Gravity.CENTER); //创建对话框对象 AlertDialog alertDialog = new AlertDialog.Builder(MenuActivity.this).create(); alertDialog.setIcon(R.drawable.advise); //设置对话框的图标 alertDialog.setCustomTitle(title);//设置标题 //设置要显示的内容 alertDialog.setMessage(\"前面仅剩3人,请立即到现场等候办理业务\"); //添加取消提醒按钮 alertDialog.setButton(DialogInterface.BUTTON_NEGATIVE,\"取消提醒\",new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface dialog,int which)&#123; flag1 = false; &#125; &#125;); //添加放弃排队按钮 alertDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"放弃排队\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //放弃排队，人数减一 num = num -1; redusepeoplenumber(deviceID,\"number_down\",num); //放弃排队后，按键置灰，不更新数据 flag = false; ConfirmDevice.setEnabled(false); GetData.setEnabled(false); GetPastdata.setEnabled(false); &#125; &#125;); alertDialog.show();//显示对话框 //按钮剧中设置 Button mNegativeButton = alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE); Button mPositiveButton = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE); LinearLayout.LayoutParams mNegativeButtonLL = (LinearLayout.LayoutParams) mNegativeButton.getLayoutParams(); mNegativeButtonLL.weight = 1; mNegativeButton.setLayoutParams(mNegativeButtonLL); LinearLayout.LayoutParams mPositiveButtonLL = (LinearLayout.LayoutParams) mPositiveButton.getLayoutParams(); mPositiveButtonLL.weight = 1; mPositiveButton.setLayoutParams(mPositiveButtonLL);&#125; 4.放弃排队时同步数据到云平台1234567891011121314151617public void redusepeoplenumber(String id,String apiTag,Object value)&#123; //设备id,标识符，值 netWorkBusiness.control(id, apiTag, value, new Callback&lt;BaseResponseEntity&gt;() &#123; @Override public void onResponse(Call&lt;BaseResponseEntity&gt; call, Response&lt;BaseResponseEntity&gt; response) &#123; BaseResponseEntity&lt;User&gt; baseResponseEntity = response.body(); //获得返回体 if( baseResponseEntity == null)&#123; Toast.makeText(MenuActivity.this,\"请求内容为空\",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onFailure(Call&lt;BaseResponseEntity&gt; call, Throwable t) &#123; Toast.makeText(MenuActivity.this,\"请求失败\"+t.getMessage(),Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 5.获取过去数据Activity123456789101112131415GetPastdata.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(dstatus == 0)&#123; Intent intent=new Intent(MenuActivity.this,PastdataActivity.class); Bundle bundle = new Bundle(); bundle.putString(\"accessToken\",accessToken); intent.putExtras(bundle); startActivity(intent); finish(); &#125;else&#123; Toast.makeText(MenuActivity.this,\"设备输入不正确或未确定设备\",Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); 点击“查看历史数据”按钮时，新建一个Activity。跳转到另外一个界面。 由于需要绘制图表，所以这个界面需要图表控件。 12private LineChart lineChart;//声明图表控件lineChart = findViewById(R.id.pastline); 首先依然需要accessToken，使用Bundle接收从上一个Activity传过来的accessToken。实例化一个netWorkBusiness对象。 123Bundle bundle = getIntent().getExtras();String accessToken = bundle.getString(\"accessToken\"); //获得传输秘钥netWorkBusiness = new NetWorkBusiness(accessToken,\"http://api.nlecloud.com:80/\"); 然后展示图标控件。获取数据。 123lineChart = findViewById(R.id.pastline);showChart(lineChart);getPnumdata(); 6.设置图表显示样式1234567891011private void showChart(LineChart lineChart)&#123; lineChart.setDrawBorders(false);//是否在折线图上添加边框 lineChart.setNoDataText(\"暂无数据\"); //没有数据时显示 lineChart.getAxisRight().setEnabled(false);//不显示y轴右边的值 XAxis xAxis = lineChart.getXAxis(); xAxis.setDrawAxisLine(false);//不显示x轴 //设置x轴数据位置 xAxis.setPosition(XAxis.XAxisPosition.BOTTOM); xAxis.setTextColor(Color.BLACK); xAxis.setTextSize(12);&#125; 7.从云平台获取过去的人数响应体netWorkBusiness下有个getSensorData()方法。这里有很多参数说明在注释中。 1234567891011121314151617/** * 查询传感数据 * * @param deviceId 设备ID * @param ApiTags 传感标识名（可选，多个用逗号分隔，最多50个） * @param Method 查询方式（1：XX分钟内 2：XX小时内 3：XX天内 4：XX周内 5：XX月内 6：按startDate与endDate指定日期查询） * @param TimeAgo 与Method一起配对使用（当Method=1~5时），表示以现在起\"多长时间范围内\"的数据，例：(Method=2,TimeAgo=30)表示现在起30小时内的历史数据 * @param StartDate 起始时间（可选，格式YYYY-MM-DD HH:mm:ss） * @param EndDate 结束时间（可选，格式YYYY-MM-DD HH:mm:ss） * @param Sort 时间排序方式，DESC:倒序，ASC升序 * @param PageSize 指定每次要请求的数据条数，默认20，最多3000 * @param PageIndex 指定页码 */public void getSensorData(String deviceId, String ApiTags, String Method, String TimeAgo, String StartDate, String EndDate, String Sort, String PageSize, String PageIndex, NCallBack&lt;BaseResponseEntity&lt;SensorDataPageDTO&gt;&gt; callback) &#123; apiService.getSensorData(deviceId, ApiTags, Method, TimeAgo, StartDate, EndDate, Sort, PageSize, PageIndex, accessToken).enqueue(callback);&#125; 8.解析x轴和y轴数据并显示123456789101112131415161718192021222324JSONObject jsonObject = null;String msg = gson.toJson(baseResponseEntity);jsonObject = new JSONObject(msg); //解析数据.JSONObject resultobj = jsonObject.getJSONObject(\"ResultObj\");int count = Integer.parseInt(resultobj.get(\"Count\").toString()); //获取记录数10JSONArray jsonArray = resultobj.getJSONArray(\"DataPoints\");JSONObject jsonObject1 = jsonArray.getJSONObject(0);JSONArray jsonArray1 = jsonObject1.getJSONArray(\"PointDTO\");List&lt;HashMap&lt;String,Object&gt;&gt; data = new ArrayList&lt;&gt;(100);List&lt;Entry&gt; entries = new ArrayList&lt;&gt;();List&lt;String&gt; list = new ArrayList&lt;&gt;();//C++模板for(int i=0;i&lt;count;i++)&#123;JSONObject resultObj1 = jsonArray1.getJSONObject(i);Pnum = resultObj1.get(\"Value\").toString();Time = resultObj1.get(\"RecordTime\").toString();entries.add(new Entry(Float.parseFloat(Pnum),i));list.add(Time);&#125;LineDataSet lineDataSet = new LineDataSet(entries,\"历史排队人数\");LineData Pdata = new LineData(list,lineDataSet);lineChart.setData(Pdata);lineChart.setScaleEnabled(true);lineChart.invalidate(); 这一段大致就是一层一层解析数据，找到自己需要的x轴和y轴的数据。 JSONObject和JSONArray1.JSONObject json对象，就是一个键对应一个值，使用的是大括号{ }，如：{key:value} 2.JSONArrayjson数组，使用中括号[ ],只不过数组里面的项也是json键值对格式的。Json对象中添加的是键值对，JSONArray中添加的是Json对象。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://Stefancharles.xyz/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"}]},{"title":"新大陆安卓端代码笔记（一）","slug":"Android_Code_newland_one","date":"2019-09-03T16:00:00.000Z","updated":"2019-09-08T12:26:49.300Z","comments":true,"path":"2019/09/04/Android_Code_newland_one/","link":"","permalink":"https://Stefancharles.xyz/2019/09/04/Android_Code_newland_one/","excerpt":"新大陆安卓端代码笔记（一）距离比赛还有一个月，暑假就稍微学了一下安卓端的皮毛，现在临时我被任命为一个参赛小组的安卓端代码的负责人。生活太难了。 学习过程中记录一下学习过程中的心得和问题，以备不时之需。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。","text":"新大陆安卓端代码笔记（一）距离比赛还有一个月，暑假就稍微学了一下安卓端的皮毛，现在临时我被任命为一个参赛小组的安卓端代码的负责人。生活太难了。 学习过程中记录一下学习过程中的心得和问题，以备不时之需。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。 Bundle 的使用简介Bundle类是一个key-value对，“A mapping from String values to various Parcelable types.” 两个activity之间的通讯可以通过bundle类来实现 步骤代码1.new一个bundle类1Bundle bundle=new Bundle(); 2.bundle压入数据1bundle.putString(\"accessToken\",accessToken); 3.new一个intent对象，并将bundle加入intent中12345Intent intent=new Intent();intent.setClass=(MainActivity.this,target.class);intent.putExtras(bundle);//or use // intent putExtra(\"acesstoken\",bundle); 4.在目标class中提取数据12Bundle bundle = getIntent().getExtras(); String data = bundle.getString(\"Data\");//读出数据 5.详细使用12Bundle bundle = getIntent().getExtras();accessToken = bundle.getString(\"accessToken\"); //获得传输密钥 getIntent得到一个Intent，是指上一个activity启动的intent，这个方法返回intent对象，然后调用intent.getExtras（）得到intent所附带的额外数据。 其实可以这么看，在MainActivity中，我们先需要登陆，看下面这段代码： 在一开始实例化一个netWorkBusiness对象，这个对象里有一个signIn的方法，实例化的时候NetWorkBusiness类需要两个参数，一个是accessToken，另外一个是platformAddress。正确登陆后才能获取accessToken，这里还没登陆，所以先传入空，但是不影响。因为可以查看NetWorkBusiness类中其对应方法： 123 public void signIn(SignIn signIn, Callback&lt;BaseResponseEntity&lt;User&gt;&gt; callback) &#123; apiService.signIn(signIn).enqueue(callback);&#125; 所以这里有没有正确的accessToken并不影响signIn方法的调用。下面再获取BaseResponseEntity，包括以下数据成员， BaseResponseEntity中的T是User，包括下面数据成员， 下图： 关键在于，实例化的baseResponseEntity对象中，有类的一个方法叫做getResultObj()，这个方法返回ResultObj，getAccessToken()也是其方法，返回accessToken。 蓝色圈的语句是把用户名和密码配置保存起来，下次打开app的时候可以直接登陆。我认为这里可能有很不安全的因素，一般使用SharedPreferences来保存软件配置信息，这里密码直接如从保存应该不安全。 这个项目这里不是重点，所以就不做深究。 上图橙色圈的语句为下一个界面“埋下伏笔”，将获取好了的accessToken传递到MenuActivity。如下图： 在MenuActivity中的init()函数中接住accessToken，并new一个netWorkBusiness对象。 额外的点这里账号密码保存再多写几句。 在这篇博客中非常不详细地介绍了SharedPreferences，这用来保存第一次输入的账号和密码。 12sp = getSharedPreferences(\"nlecloud\",MODE_PRIVATE);editor = sp.edit(); 这里sp对象用来读取SharedPreferences中的数据，editor用来向SharedPreferences中写入数据。sp的声明是 ： 1private SharedPreferences sp； sp是SharedPreferences的类型的对象。 （经过罗老板的指点）第一句调用getSharedPreferences方法背后生成一个名为nlecloud的SharedPreferences文件， 第二句，editor的声明是： 1private SharedPreferences.Editor editor; 差不多理解为editor是SharedPreferences的叫做Editor的子类的类型的对象。 123456if(sp.getString(\"username\",_username)!=null&amp;&amp;sp.getString(\"passwod\",_password)!=null)&#123; if(!sp.getString(\"username\",_username).equals(\"\")&amp;&amp;!sp.getString(\"password\",_password).equals(\"\"))&#123; username.setText(sp.getString(\"username\",\"1\")); //判断SharedPreferences文件中，用户名、密码是否存在 password.setText(sp.getString(\"password\",\"2\")); //第二个参数是该值如果获取不到的默认值 &#125; &#125; 下一次应用开启时执行上面的过程。 下一篇博客传送门点击这里—&gt;新大陆安卓端代码笔记（二）","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://Stefancharles.xyz/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"}]},{"title":"新大陆安卓端代码笔记（二）","slug":"Android_Code_newland_two","date":"2019-09-03T16:00:00.000Z","updated":"2019-09-08T12:33:56.061Z","comments":true,"path":"2019/09/04/Android_Code_newland_two/","link":"","permalink":"https://Stefancharles.xyz/2019/09/04/Android_Code_newland_two/","excerpt":"新大陆安卓端代码笔记（二）在新大陆安卓端代码笔记（一）中，主要介绍了登陆的activity，这一个博客将着手于MenuActivity中的关键点。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。","text":"新大陆安卓端代码笔记（二）在新大陆安卓端代码笔记（一）中，主要介绍了登陆的activity，这一个博客将着手于MenuActivity中的关键点。 文章不严谨和疏漏的地方在所难免，如果可以的话，请留言给我，感激不尽。 1.初始化控件菜单界面大致如图： 在MenuActivity中首先对这些控件进行初始化： 1234567891011void init()&#123; EquipmentID = findViewById(R.id.equimentID); //设备id Pnumber = findViewById(R.id.pnumber);//排队人数 Waittime = findViewById(R.id.waittime); //等待时间 ConfirmDevice = findViewById(R.id.confirmDevice); //确认设备 GetData = findViewById(R.id.getData); //最新数据 GetPastdata = findViewById(R.id.getPastdata);//历史数据 Bundle bundle = getIntent().getExtras(); accessToken = bundle.getString(\"accessToken\"); //获得传输密钥 netWorkBusiness = new NetWorkBusiness(accessToken,\"http://api.nlecloud.com:80/\");//进行登录连接&#125; 一个不怎么需要注意的点是，这里已经不在需要强制转换了。findViewById前的强制类型转换是多余的。如下所示是不必要的： 12mRvMsg = (RecyclerView)findViewById(R.id.rv_msg);mEtPort = (EditText) findViewById(R.id.et_port); 2.“确定设备”的点击事件123456ConfirmDevice.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; getDeviceInfo(); &#125;&#125;); 点击确定设备按钮，调用getDeviceInfo()函数来确定设备是否存在。 这里涉及到Gson。 Gson是一个可以用来将Java对象转换为JSON字符串的Java库。当然，它也可以把JSON字符串转换为等价的Java对象。 12345678910111213141516public class User &#123; public String name=\"maplejaw\"; public int age=18; public User()&#123; //无参构造方法 &#125;&#125;// 序列化 User obj = new User(); Gson gson = new Gson(); String json = gson.toJson(obj); // ==&gt; json is &#123;\"name\":\"maplejaw\",\"age\":18&#125; //反序列化 User obj2 = gson.fromJson(json, User.class); 提取Gson中设备存在的关键字Status首先需要知道获取设备ID返回的内容。 先去查询新大陆API查看我们所需要的API请求方式和地址，包体请求参数等。 然后去API在线调试填入刚刚找到的相关请求网址等。 从上面可以看出，如果设备存在，则Status返回0，否则返回非0.所以这也就有以下： 123456dstatus = (int) jsonObject.get(\"Status\");if(dstatus==0)&#123;Toast.makeText(MenuActivity.this,\"欢迎使用设备\",Toast.LENGTH_SHORT).show();&#125;else&#123;Toast.makeText(MenuActivity.this,\"设备不存在,请确认\",Toast.LENGTH_SHORT).show();return;&#125; 需要值得注意的是，AccessToken那一栏需要先用正确的账号登陆去发POST请求，得到AccessToken（很长）后复制进来。 3.基本程序单元Activity在Android中，Activity代表手机屏幕的一屏，在一个Activity中可以添加很多组件，这些组件负责具体的功能。在一个Android应用中，可以有多个Activity，这些Activity组成了Activity栈，当前的Activity在栈顶，之前的Activity被压入下面，成为非活动的Activity。 在Activity的生命周期中，有4个状态： 活动状态：当前的Activity，在栈顶，可以获得焦点 暂停状态：没有焦点的Activity，可见，低内存时不被系统结束 停止状态：不可见，但是这个Activity保存状态和信息，低内存时可能被系统结束 销毁状态：Activity结束 一个Activity被系统回调的方法1234567onCreate();//创建Activity时onStart();//启动Activity时onRestart()://重启Activity时onPause()://暂停Activity时onResume()://Activity从暂停状态--&gt;活动状态onStop();//停止Activity时onDestory()://销毁Activity时 创建Activity大致分为两个步骤： （1）创建一个Activity，一般是继承某个Activity类，或者Activity子类。具体代码如下 1234import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity&#123;&#125; (2)重写需要回调的方法。一般都要重写onCreate()方法，并且在该方法中调用setContentView()方法设置要显示的视图。具体代码如下： 1234 protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125; 配置Activity创建了Activity后，还需要在AndroidManifest.xml中进行配置。如果没有配置就启动Activity则会报错。在标记中添加标记。 格式如下： 123456789&lt;activityandroid:icon=\"@drawable/xx\"android:name=\"实现类\"android:lable=\"说明文字\"android:theme=\"主题\"...&gt;...&lt;/activity&gt; 一个地方值得注意：icon栏中图标文件名不包括其拓展名 启动Activity假设一个Android项目中有很多的Activity，这个时候要设置一个应用启动的入口Activity。在AndroidManifest.xml中，如下代码设置。 123456&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 也可以使用startActivity()方法来启动需要的Activity，语法如下 1public void startActivity(Intent intent) 值得注意的是，该方法没有返回值，只有一个Intent类型的入口参数。 Intent是Android应用各组件之间的通信方式，一个Activity用过Intent来表达自己的“意图”，在创建Intent对象时，需要指定想要启动的Activity。 关于Intent的具体用法我会在后面具体写。语法举例如下： 123456Intent intent = new Intent(MainActivity.this,MenuActivity.class);Bundle bundle = new Bundle();bundle.putString(\"accessToken\",accessToken);intent.putExtras(bundle);startActivity(intent);finish(); 当然这里还涉及到bundle的用法，前面我稍微写了一部分，但是感觉理解的不够精髓，后面再详细写这个。 关闭Activity就如上面我举例的代码片段。方法是 1public void finish(); 在对应的事件或者你觉得需要的地方调用finish()方法即可。 4.多个Activity的使用在Android应用中，很多Activity之间经常需要交换数据，下面介绍怎么使用Bundle在Activity之间交换数据，以及如何调用另外一个Activity并返回结果。 使用Bundle在Activity之间交换数据在Android中，可以将要保存的数据放在Bundle对象中，然后通过Intent提供的putExtras()方法将要携带的数据保存在Intent中。在MainActivity中： 123456Intent intent = new Intent(MainActivity.this,MenuActivity.class);Bundle bundle = new Bundle();bundle.putString(\"accessToken\",accessToken);intent.putExtras(bundle);startActivity(intent);finish(); 在MenuActivity中： 12Bundle bundle = getIntent().getExtras();accessToken = bundle.getString(\"accessToken\"); //获得传输密钥 调用另外Activity并返回结果有时需要在一个Activity中调用另外一个Activity，当用户在第二个Activity中操作好后，程序自动返回到第一个Activity。第一个Activity必须能够获取用户在第二个Activity中选择的结果。这个也是通过Intent和bundle来实现，不过区别在于这个时候需要使用startActivityForResult()方法来启动另外一个Activity。 （1）在MainActivity中设置请求码常量请求码即requestCode，这个可以自己设置一个值，这是为了让程序知道返回的数据是来自于哪一个新的Activity。例如： 1final int CODE = 0x01; （2）启用新的Activity1startActivityForResult(intent,CODE); （3）在新的Activity中设置返回的结果码12345@Overridepublic void onClick(View v)&#123; setResult(0x01,intent); finish():&#125; （4）在第一个Activity中重写onActivityResult()方法在这个方法中，需要判断resultCode结果码和预先设置的相同，如果相同则做应该做的事情。关键代码如下： 1234567@Overrideprotected void onActivityResult(int requestCode,int resultCode ,Intent data)&#123; super.onActivityResult(requestCode , resultCode, data); if(requestCode == CODE &amp;&amp; resultCode == CODE)&#123; //TODO:..... &#125;&#125; 5.Intent对象在Intent对象中，包含接收这个Intent的组件感兴趣的信息（比如执行的操作和数据），以及Android系统感兴趣的信息（比如处理这个 Intent的类别和任何启动目标Activity的说明） Intent可以分为显式和隐式两类。 显式Intent通过组件名称来指定目标组件。由于其他应用程序的组件名称对于开发人员通常是未知的，所以显式Intent通常用于应用程序内部消息，例如Activity启动子Service或者其他Activity。 隐式Intent不指定组件名称，通常用来激活其他应用程序的组件。在缺乏指定目标时，Android系统需要找到处理Intent的最佳组件。即单个的Activity或者Service来执行请求动作或者一组BroadcastReceiver来响应广播通知。这个是通过比较Intent对象内容和Intent过滤器来实现的。 Intent过滤器是与组件关联的结构，它可以潜在地接受Intent。如果组件没有任何Intent过滤器，就只能接受显式Intent；如果组件有Intent过滤器，则可以接受显式和隐式的Intent。 Intent包括： 组件名称(Component Name) 动作(Action) 数据(Data) 种类(Category) 额外(Extras) 标记(Flags) 等内容。关于上面的内容不详细展开，具体的可以去Android的官方文档查看。这里写一些需要注意的点。 举例：标准Activity动作：常量ACTION_MAIN对应说明为“作为初始的Activity启动，没有数据输入/输出”。 在使用这些动作的时候，需要将其转换为对应字符串信息。例如将ACTION_MAIN转换为android.intent.action.MAIN。 123456&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 关于Intent过滤器本身还有很多内容，我这里暂时不深究。因为这次项目中涉及不深，后面有机会再加。 下一篇博客传送门点击这里—&gt;新大陆安卓端代码笔记（三）","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://Stefancharles.xyz/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"}]},{"title":"【Android】数据存储 SharedPreferences 存储类","slug":"SharedPreferences","date":"2019-09-03T16:00:00.000Z","updated":"2019-09-04T02:08:39.751Z","comments":true,"path":"2019/09/04/SharedPreferences/","link":"","permalink":"https://Stefancharles.xyz/2019/09/04/SharedPreferences/","excerpt":"简介在Android开发中，经常需要将少量简单类型数据保存在本地，如：用户设置，用户登录名等。这些需要保存的数据可能一两个字符串，像这样的数据一般选择使用SharedPreferences来保存。 SharedPreferences：一个轻量级的存储类，特别适合用于保存软件配置参数。用xml文件存放数据。SharedPreferences可以保存的数据类型有：int、boolean、float、long、String、StringSet。","text":"简介在Android开发中，经常需要将少量简单类型数据保存在本地，如：用户设置，用户登录名等。这些需要保存的数据可能一两个字符串，像这样的数据一般选择使用SharedPreferences来保存。 SharedPreferences：一个轻量级的存储类，特别适合用于保存软件配置参数。用xml文件存放数据。SharedPreferences可以保存的数据类型有：int、boolean、float、long、String、StringSet。 存储数据保存数据一般分为四个步骤： 使用Activity类的getSharedPreferences方法获得SharedPreferences对象； 使用SharedPreferences接口的edit获得SharedPreferences.Editor对象； 通过SharedPreferences.Editor接口的putXXX方法保存key-value对； 通过过SharedPreferences.Editor接口的commit方法保存key-value对。 读取数据 使用Activity类的getSharedPreferences方法获得SharedPreferences对象； 通过SharedPreferences对象的getXXX方法获取数据； 示例方法12private SharedPreferences sp;sp = getSharedPreferences(\"nlecloud\",MODE_PRIVATE; 参数说明： name：命名 mode：模式，包括 MODE_PRIVATE（只能被自己的应用程序访问） MODE_WORLD_READABLE（除了自己访问外还可以被其它应该程序读取） MODE_WORLD_WRITEABLE（除了自己访问外还可以被其它应该程序读取和写入） 12private SharedPreferences.Editor editor;editor = sp.edit();","categories":[{"name":"笔记","slug":"笔记","permalink":"https://Stefancharles.xyz/categories/笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://Stefancharles.xyz/tags/Android/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://Stefancharles.xyz/tags/SharedPreferences/"}]},{"title":"WareHouse","slug":"projects/Warehouse","date":"2019-08-29T16:00:00.000Z","updated":"2019-08-29T16:00:00.000Z","comments":true,"path":"2019/08/30/projects/Warehouse/","link":"","permalink":"https://Stefancharles.xyz/2019/08/30/projects/Warehouse/","excerpt":"WareHouse Management本文分为以下几个部分： 1.团队成员 2.需求分析 3.系统设计 4.程序实现 5.程序测试","text":"WareHouse Management本文分为以下几个部分： 1.团队成员 2.需求分析 3.系统设计 4.程序实现 5.程序测试 1.团队成员点击 这里 查看团队成员。 2.需求分析① 环境说明 Windows 10 1903 Qt 5.9.0 C++ ② 功能需求说明 ③ 约束说明 ④ 逻辑说明 在卖出时，如果所有货物已经全部卖出，要提示用户“所有货物已卖出”，并删除该货物在数据库中的记录；如果卖出数量大于库存，则卖出失败。 查找包含两个子功能，查询记录和显示结果，表格中说明的是查找商品的约束条件，显示库存不需用用户输入其他信息。 每类货物有一个ID，ID相同被看作为同一类 查找功能两个查询条件是或的关系，即只要输入ID或商品名字就可以查询，如果两个都输入那么将会输入ID匹配以及name匹配的所有货物。 最大容量1500. ⑤ 数据流图 ⑥ 用例图 3.系统设计① 类图设计 ② MVP架构说明 MVP从MVC演变而来，通过表示器将视图与模型巧妙地分开。在该模式中，视图通常由表示器初始化，它呈现用户界面（UI）并接受用户所发出命令，但不对用户的输入作任何逻辑处理，而仅仅是将用户输入转发给表示器。通常每一个视图对应一个表示器，但是也可能一个拥有较复杂业务逻辑的视图会对应多个表示器，每个表示器完成该视图的一部分业务处理工作，降低了单个表示器的复杂程度，一个表示器也能被多个有着相同业务需求的视图复用，增加单个表示器的复用度。表示器包含大多数表示逻辑，用以处理视图，与模型交互以获取或更新数据等。模型描述了系统的处理逻辑，模型对于表示器和视图一无所知。 目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式透过对复杂度的简化，使程序结构更加直观。软件系统透过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。专业人员可以依据自身的专长分组。 ① MainWindow负责用户界面，即View，获取用户输入或将执行结果显示给用户，在仓库管理系统中，它主要是获取用户指令是买入、卖出、查找还是清空仓库，并根据用户不同的输入来改变界面以适合相应的操作。然后如果是买入、卖出或者查找，还需要用户输入货物的相关信息。等这些信息都录入完毕，它就向下层发送相关指令，进行处理。最后等下层处理完后，会返回处理结果，MainWindown在负责把处理结果显示给用户。 ② Warehouse负责逻辑处理，即Presenter, 根据用户的输入，进行判断，并将需要进行数据库操作的信号传给下层，同时负责把下层处理结果传递给上层。 ③ Database负责数据库操作，即Modle,接收从上层传来的数据，并按照指令更新数据库或返回相应数据。 ④ Goods类是表示货物的实体类。是为了方便表示而存在。 ③ 异常处理 ① 在程序中使用try，throw,catch异常处理方法。在遇到系统无法处理的异常情况时，会直接抛出异常，显示给用户，部分异常抛出信息中有对用户操作的建议，比如“物品Id和name不匹配”。 ② 为了避免用户输入导致系统奔溃，收到用户输入后在Warehouse类中进行检查其是否符合上表中的约束，在保证安全后在传给下层。 ④ 已实现和未实现的内容 使用登录界面，保证只有密码用户才能进入系统 较为漂亮的UI界面 登录界面掩码 使用本地数据库管理仓库数据 核心业务与上层UI分离 对商品CRUD的操作 连接云数据库，例如阿里云主机 FluentDesing 新建登录用户 4.程序实现1.good.h123456789101112131415161718#ifndef GOOD_H#define GOOD_H#include &lt;QString&gt;class Goods&#123;public: Goods(); void setId(int Id_i); int getId(); void setName(QString name_i); QString getName(); void setCount(int count_i); int getCount();private: int id; QString name; int count;&#125;;#endif // GOOD_H 2.login.h12345678910111213141516171819202122232425#ifndef LOGIN_H#define LOGIN_H#include &lt;QDialog&gt;namespace Ui &#123;class Login;&#125;class Login : public QDialog&#123; Q_OBJECTpublic: explicit Login(QWidget *parent = 0); ~Login();private slots: void on_pushButton_clicked();private: Ui::Login *ui;&#125;;#endif // LOGIN_H 3.MainWindow.h1234567891011121314151617181920212223242526272829303132333435363738#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include \"warehouse.h\"namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void on_addGoods_clicked(); void on_delGoods_clicked(); void on_showGoods_clicked(); void on_search_clicked(); void on_empty_clicked(); void on_ok_clicked(); void on_exit_clicked();private: Ui::MainWindow *ui; char commod; Warehouse wre; void clear();&#125;;#endif // MAINWINDOW_H 4.Warehouse.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#ifndef WAREHOUSE_H#define WAREHOUSE_H#include \"good.h\"#include \"database.h\"#include &lt;exception&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#define ALL 1500using namespace std;namespace Ui &#123;class Warehouse;&#125;class Warehouse&#123;public: Warehouse(); ~Warehouse(); void empty();//初始化储存商品信息的vector bool inputCheck(string &amp;id, QString &amp;name, string &amp;count);//检查用户输入的商品名和数量是否合法 //买入： //买入，对应买入模块，表示当前进货一批数量为count的name商品 bool add_goods(string id,QString name, string count); //更新库存列表，对应新增商品子功能，新增name商品且初始数量为count bool add_to_list(int id,QString name, int count); //卖出： //卖出，对应卖出模块，表示当前出货一批数量为count的name商品 bool delete_goods(string id,string count); //查询： ///显示当前库存列表，包括商品名及其库存量 void show_goods(); //查看仓库中的name商品 void find_goods(QString id, QString name); void readGoodsFromDataBase();private: vector&lt;Goods&gt; goods; Database db; int stringToNum(const string&amp; str) &#123; istringstream iss(str); int num; iss &gt;&gt; num; return num; &#125; //模板，将字符串类型的变量变为int型&#125;;#endif // WAREHOUSE_H 5.连接QSQLITE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include \"database.h\"#include &lt;QSqlDatabase&gt;#include &lt;QMessageBox&gt;#include &lt;QSqlError&gt;#include &lt;QSqlQuery&gt;#include &lt;QVariant&gt;bool Database::connect(const QString &amp;dbName)&#123; QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\"); db.setHostName(\"localhost\"); db.setDatabaseName(\"dbname\"); db.setUserName(\"stefan\"); db.setPassword(\"pwd123\"); db.setDatabaseName(dbName); if (!db.open()) &#123; QMessageBox::critical(0, QObject::tr(\"Database Error\"), db.lastError().text()); return false; &#125; return true;&#125; bool Database::creatDataBase() &#123; if (connect(\"demo.db\")) &#123; QSqlQuery query; //判断表是否已经存在 QString sql = QString(\"select * from sqlite_master where name='%1'\").arg(\"goods\"); query.exec(sql); if(query.next()) return true; query.finish(); if (!query.exec(\"CREATE TABLE goods(\" \"id INT,\" \"name VARCHAR,\" \"number INT)\")) &#123; QMessageBox::critical(0, QObject::tr(\"Database Error\"), query.lastError().text()); return false; &#125; return true; &#125; return false; &#125; bool Database::writeAnItemToDataBase(int id_in, QString name_in, int number_in) &#123; QSqlQuery query; if(number_in == -1) &#123;//删除指定商品 query.prepare(\"delete from goods where id = :id_in\"); query.bindValue(\":id_in\", id_in); if(!query.exec()) &#123; QMessageBox::critical(0, QObject::tr(\"Database Error -1\"), query.lastError().text()); return false; &#125; return true; &#125; query.prepare(\"select * from goods where id = :id_in\"); query.bindValue(\":id_in\", id_in); query.exec(); if(query.next()) &#123;//如果该商品存在，那么更新它的数据 query.finish(); query.prepare(\"update goods set number = :number_in where id = :id_in\"); query.bindValue(\":id_in\",id_in); query.bindValue(\":number_in\", number_in); if(!query.exec()) &#123; QMessageBox::critical(0, QObject::tr(\"Database Error-2\"), query.lastError().text()); return false; &#125; return true; &#125; else &#123;//如果不存在这个商品，那个添加这个商品 query.finish(); query.prepare(\"insert into goods(id, name, number) values(:id_in,:name_in,:number_in)\"); query.bindValue(\":id_in\",id_in); query.bindValue(\":name_in\",name_in); query.bindValue(\":number_in\", number_in); if(!query.exec()) &#123; QMessageBox::critical(0, QObject::tr(\"Database Error-3\"), query.lastError().text()); return false; &#125; &#125; return true; &#125; 6.UI 一览 5.程序测试1.黑盒测试2.白盒测试3.系统测试","categories":[{"name":"C++","slug":"C","permalink":"https://Stefancharles.xyz/categories/C/"},{"name":"Qt","slug":"C/Qt","permalink":"https://Stefancharles.xyz/categories/C/Qt/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://Stefancharles.xyz/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://Stefancharles.xyz/tags/Qt/"}],"author":"Stefan"}]}